<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hongwen Xin&#39;s Blog</title>
  
  
  <link href="https://penpenf28.github.io/atom.xml" rel="self"/>
  
  <link href="https://penpenf28.github.io/"/>
  <updated>2023-11-07T01:21:58.397Z</updated>
  <id>https://penpenf28.github.io/</id>
  
  <author>
    <name>Hongwen Xin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPU相关</title>
    <link href="https://penpenf28.github.io/2023/11/06/GPU%E7%9B%B8%E5%85%B3/"/>
    <id>https://penpenf28.github.io/2023/11/06/GPU%E7%9B%B8%E5%85%B3/</id>
    <published>2023-11-06T03:31:36.000Z</published>
    <updated>2023-11-07T01:21:58.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是自己对于GPU相关知识的总结，以Nvidia系列GPU为主，具体的架构和编程相关可能会在之后写cuda内容的时候介绍。</p></blockquote><h1>GPU发展历程</h1><p><strong>早期阶段（1980年代）</strong>： 最初，GPU(Graphic Processing Unit)主要用于处理简单的2D图形，用于显示计算机屏幕上的图像。这些早期的GPU是图形加速卡的一部分，用于图形用户界面（GUI）操作和基本的图形渲染。<br><strong>3D加速的兴起（1990年代）</strong>： 随着电脑游戏和3D图形应用的兴起，GPU逐渐开始支持3D图形加速。3D加速卡开始崭露头角，提供更快的三维图形处理和渲染。NVIDIA和ATI（后来被AMD收购）等公司在这个时期推出了一系列创新的产品。<br><strong>通用计算（2000年代）</strong>： GPU不再仅限于图形处理，而是开始进入通用计算领域。CUDA（NVIDIA的并行计算架构）和OpenCL等技术使开发者能够利用GPU的并行处理能力执行更广泛的计算任务，如科学计算、数据分析和人工智能。<br><strong>深度学习和人工智能（2010年代至今）</strong>： GPU在深度学习和人工智能领域的发展迅速。由于深度学习模型对大量数据和大规模并行处理的需求，GPU的并行计算能力成为训练神经网络的理想选择。NVIDIA的CUDA架构和基于Pytorch等深度学习框架的优化使GPU成为训练和推理神经网络的首选硬件之一。<br><strong>异构计算和AI加速（2020年代）</strong>： GPU不仅限于传统的图形和通用计算任务，还在AI加速领域继续发展。除了NVIDIA之外，公司如AMD和英特尔也在努力开发支持AI加速的GPU架构。同时，出现了专门用于加速机器学习和深度学习任务的专用芯片，如NVIDIA的Tensor Cores和Google的TPUs（张量处理单元）等。</p><h1>CPU vs GPU</h1><p>现代深度学习为什么选择GPU而不是CPU？<br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/1.png" alt="1" title="1"></p><p>图像来自于<a href="https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf">CUDA C++编程指南</a><br>CPU</p><ul><li>CPU的内核数量较少，常见的有4核和8核</li><li>由于CPU一般需要处理低延时任务，因此需要大量的L1，L2，L3 cache来减少访问指令和数据时产生的延迟，如上图左边所示，大部分晶体管用于构建控制电路和存储单元，少部分晶体管用来完成实际的运算工作</li><li>CPU的每个核心都可以处理不同的指令序列，每个核心都有自己的控制器和缓存单元，擅长逻辑控制，适合处理串行和复杂的任务</li></ul><p>GPU</p><ul><li>GPU拥有大量的小型核心，通常为数百至数千核心</li><li>GPU的关注点不在于低延时和控制，对cache的需求相对较小，可以用大部分的晶体管来构建计算核心，如上图右边所示，这些核心可以执行大量的相似操作，在处理大规模数据和并行任务时非常高效，缺点是单核自由度远远低于CPU</li></ul><p>在上图中，GPU的每一行(红框)有多个核，但是只有一个控制单元和L1 cache，表示这多个核在同一时刻只能执行相同的指令，这种模式被称为SIMT(Single Instruction Multiple Threads)。<br>在深度学习中涉及大量的矩阵运算，这种计算方式属于计算密集型，且操作重复，易于数据并行，非常适合于交给GPU进行任务的执行。</p><ul><li>计算密集：数值计算的比例远大于内存操作，内存访问的延时可以被计算掩盖，因此对cache的需求相对CPU没有那么大</li><li>数据并行：大量的数据可以拆分为执行相同指令的小任务，对复杂流程控制的需求较低</li></ul><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/2.png" alt="2" title="2"><br>来自于<a href="https://www.bilibili.com/video/BV1TU4y1j7Wd?p=1&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e">李沐老师的视频</a></p><ul><li>CPU边上绿色的是主存</li><li>GPU的内存就是显存</li><li>GPU核数量远远大于CPU，每秒计算数可以简单理解为核的数目*主频</li><li>GPU的控制流远远弱于CPU，因为CPU要处理很多复杂任务，很多的if-else</li></ul><p>总结</p><ul><li>CPU：可以处理通用计算</li><li>GPU：使用更多的小核和更大的内存带宽，适合能大规模并行的计算任务</li></ul><h1>通信</h1><p>GPU并不能单独工作，需要与CPU协同处理任务，流程大概如下<br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/3.png" alt="3" title="3"><br>图像来自于<a href="https://face2ai.com/CUDA-F-1-1-%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97-CUDA/">谭升的博客</a></p><ul><li>CPU准备数据并分配GPU内存</li><li>拷贝数据到GPU中（可能多个GPU协同工作）</li><li>GPU开始执行数据任务，期间CPU可以做自己的事情</li><li>GPU计算完成将结果拷贝回CPU</li><li>销毁内存</li></ul><p>其中数据的传输可以被看作外部通信，主要有三种方式。<br><strong>PCIe</strong><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/4.png" alt="4" title="4"><br>图像来自于李沐老师的视频(<a href="https://www.bilibili.com/video/BV1TU4y1j7Wd?p=1&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e">https://www.bilibili.com/video/BV1TU4y1j7Wd?p=1&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e</a>)</p><ul><li>PCIe（Peripheral Component Interconnect Express）是一种计算机总线标准，用于连接各种内部硬件设备，如图形卡、网卡、存储设备和其他扩展卡到主板上的插槽。它提供了高带宽和高速度的数据传输通道，是现代计算机系统中最常见的总线标准之一</li><li>PCIe的版本通常用&quot;x&quot;表示，例如PCIe 3.0、PCIe 4.0、PCIe 5.0等。每个版本的PCIe都有不同的数据传输速率和带宽。新版本通常会提供更高的速度和带宽，以适应不断增长的数据传输需求</li><li>PCIe的速度通常以“xN”表示，N代表总线的通道数。PCIe 3.0 x16具有每秒达到约15.75 GB/s的速度，而PCIe 4.0 x16则将速度提高到每秒达到约31.51 GB/s，PCIe 5.0则进一步增加了速度，提供了更高的带宽</li></ul><p><strong>NVLink</strong><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/5.png" alt="5" title="5"><br>在nvlink之前，为了获得更多强力的计算节点，可以用将多个GPU通过PCIe与CPU直接相连，他们之间的pcie 3.0*16有接近32GB/s的双向带宽，但是当训练数据不断增长时，这个互联方案会成为系统的bottleneck。<br>为了解决这个问题，NVidia开发了全新的互联架构NVLink，主要用于多GPU系统之间的互联，实现显存和性能扩展。<br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/6.gif" alt="6" title="6"><br>同时NVidia还发明了NVSwitch技术来连接多个NVLink，在单节点内和节点间实现以 NVLink 能够达到的最高速度进行多对多 GPU 通信。<br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/7.png" alt="7" title="7"><br><strong>GPUDirect RDMA</strong><br>上面两种通信方式一般用于单机多卡GPU通讯，而GPUDirect** **RDMA(Remote Direct Memory Access)一般用于多机多卡GPU通信，RDMA是一种绕过远程主机而直接访问其内存中数据的技术，通过这种方式允许GPU直接访问RDMA网络设备中的数据，无需通过主机内存或CPU的中介。<br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/8.png" alt="8" title="8"></p><h1>N厂GPU架构</h1><blockquote><p>架构统计截止到文章发布2023年11月2日。</p></blockquote><p>术语解释</p><ul><li>SM：Stream Multiprocessor，流多处理器，SM是一个并行处理单元，用于执行并行计算任务，为了处理大规模并行工作负载而设计的，涉及诸如图形处理、深度学习训练、科学计算和其他需要大量并行计算的任务。每个SM包含多个CUDA核心（CUDA Cores），这些CUDA核心能够执行并行指令，执行数学计算、逻辑操作和其他运算。同时，SM还包括一些高速缓存和寄存器文件，这些缓存和寄存器用于存储数据和指令，以便于处理任务</li><li>FLOPS：每秒浮点运算次数（Floating Point Operations Per Second），是衡量计算机或处理器性能的指标</li><li>CUDA Core：CUDA Core是NVIDIA GPU上的计算核心单元，用于执行通用的并行计算任务，是最常看到的核心类型。NVIDIA 通常用最小的运算单元表示自己的运算能力，CUDA Core 指的是一个执行基础运算的处理元件。CUDA Core 数量，通常对应的是 FP32 计算单元的数量</li><li>Tensor Core：Tensor Core 是 NVIDIA Volta 架构及其后续架构（如Ampere架构）中引入的一种特殊计算单元。它们专门用于深度学习任务中的张量计算，如矩阵乘法和卷积运算。Tensor Core 核心特别大，通常与深度学习框架（如 TensorFlow 和 PyTorch）相结合使用，它可以把整个矩阵都载入寄存器中批量运算，实现十几倍的效率提升</li></ul><h2 id="Fermi-2010">Fermi - 2010</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/9.png" alt="9" title="9"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/10.png" alt="10" title="10"></p><ul><li>第一个为高性能计算应用提供所需功能的架构</li><li>支持符合IEEE 754-2008标准的双精度浮点</li><li>ECC支持</li><li>多级别缓存</li><li>第三代SM，16个SM<ul><li>每个SM有32个CUDA Core</li><li>Dual Warp Scheduler 同时调度和分派来自两个独立 warp 的指令</li></ul></li><li>NVIDIA GigaThread TM 引擎<ul><li>并发内核执行</li><li>乱序线程块执行</li></ul></li><li>代表产品<ul><li>NVIDIA GeForce GTX 480</li><li>NVIDIA GeForce GTX 580</li></ul></li></ul><h2 id="Kepler-2012">Kepler - 2012</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/11.png" alt="11" title="11"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/12.png" alt="12" title="12"></p><ul><li>将SM升级为SMX，15个SMX<ul><li>每个SMX有192个单精度的CUDA Core，64个DP双精度运算单元</li></ul></li><li>为高性能科学计算而设计，减少SMX单元数，增加每组SMX单元中CUDA内核数</li><li>相比Fermi架构效率更高，性能更好</li><li>双精度浮点运算能力高并更加强调功耗比</li><li>代表产品<ul><li>NVIDIA GeForce GTX 680</li><li>NVIDIA Tesla K40</li><li>NVIDIA Quadro K5000</li></ul></li></ul><h2 id="Maxwell-2014">Maxwell - 2014</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/13.png" alt="13" title="13"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/14.png" alt="14" title="14"></p><ul><li>SM升级为SMM，16个SMM<ul><li>每个SMM中4个处理块，每个处理块有32个CUDA Core</li><li>CUDA Core总数从Kepler架构的192个减少到128个，但是每个SMM单元拥有更多的逻辑控制电路，便于精确控制</li></ul></li><li>支持统一虚拟内存技术，允许CPU直接访问显存和GPU访问主存</li><li>代表产品<ul><li>NVIDIA GeForce GTX 970</li><li>NVIDIA GeForce GTX 980</li><li>NVIDIA Tesla M40</li><li>NVIDIA Quadro M6000</li></ul></li></ul><h2 id="Pascal-2016">Pascal - 2016</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/15.png" alt="15" title="15"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/16.png" alt="16" title="16"></p><ul><li>改进设计，第一个考虑Deep Learning的架构</li><li>将处理器和数据集成在同一个程序包内，以实现更高的计算效率</li><li>60个SM<ul><li>单个SM中设置2个处理块，每个处理块有32个FP32 CUDA Core，即单个SM只有64个CUDA Core，少于Maxwell的128个和Kepler的192个</li><li>单个SM增加了32个FP64 CUDA Core，即DP Unit</li></ul></li><li>NVLink<ul><li><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/17.png" alt="17" title="17"></li><li>提供了NVLink用以单机内多GPU内的点到点通信，带宽达到了160GB/s, 大约5倍于PCIe 3.0 x16</li></ul></li><li>代表产品<ul><li>NVIDIA Tesla P100</li><li>NVIDIA GeForce GTX 1080</li><li>NVIDIA GeForce GTX 1070</li><li>NVIDIA Quadro P6000</li></ul></li></ul><h2 id="Volta-2017">Volta - 2017</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/18.png" alt="18" title="18"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/19.png" alt="19" title="19"></p><ul><li>对SM重新设计，比前代Pascal设计能效高50%，以Deep Learning为核心</li><li>新增Tensor Core</li><li>84个SM<ul><li>单个SM设置4个处理块，每个处理块设置8个FP64 CUDA Core，16个INT32 CUDA Core，16个FP32 CUDA Core，2个Tensor Core，共160+8个Core</li></ul></li><li>独立线程调度，不同于以前的SIMT架构，即一个线程束(Warp)中的32个线程共享一个程序计数器和栈，而Volta架构中每个线程都有自己的程序计数器和堆栈，使得线程之间的细粒度控制成为可能</li><li>升级NVLink</li><li>代表产品<ul><li>NVIDIA Tesla V100</li><li>NVIDIA Titan V</li><li>NVIDIA Quadro GV100</li></ul></li></ul><h2 id="Turing-2018">Turing - 2018</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/20.png" alt="20" title="20"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/21.png" alt="21" title="21"></p><ul><li>这一代中去掉了对FP64的支持</li><li>加入专门用于光线追踪的RT(Ray-Tracing)，使得实时光线追踪成为可能</li><li>增加了深度学习超采样(Deep Learning Super Sampling, DLSS)，它是由NVIDIA开发的一种基于深度学习的图形增强技术，通过利用人工智能和机器学习技术提高实时图形渲染的性能和画质，特别是在游戏中。</li><li>72个SM<ul><li>每个SM中有4个处理块，每个处理块有16个INT32 CUDA Core，16个FP32 CUDA Core，2个Tensor Core，共128+8个Core</li></ul></li><li>Tensor Core中增加了对INT8/INT4/Binary的支持，深度学习的量化部署渐渐成熟</li><li>代表产品<ul><li>NVIDIA GeForce RTX 2080 Ti</li><li>NVIDIA GeForce RTX 2070 Super</li><li>NVIDIA Quadro RTX 6000</li><li>NVIDIA Titan RTX</li><li>NVIDIA Tesla T4</li></ul></li></ul><h2 id="Ampere-2020">Ampere - 2020</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/22.png" alt="22" title="22"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/23.png" alt="23" title="23"></p><ul><li>升级了Tensor Core<ul><li>Ampere A100中Tensor Core的性能比Volta架构中Tensor Core的性能提高了2.5倍，比传统CUDA Core执行单精度浮点乘加的性能提高了20倍</li></ul></li><li>84个SM<ul><li>又把FP64加回来了</li><li>单个SM有4个处理块，每个处理块有8个FP64 CUDA Core，16个FP32 CUDA Core，16个INT32 CUDA Core，1个Tensor Core</li></ul></li><li>代表产品<ul><li>NVIDIA A100 Tensor Core GPU</li><li>NVIDIA A800 Tensor Core GPU</li><li>NVIDIA GeForce RTX 3080</li><li>NVIDIA GeForce RTX 3090</li><li>NVIDIA Quadro RTX 8000</li></ul></li></ul><h2 id="Hopper-2022">Hopper - 2022</h2><p><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/24.png" alt="24" title="24"><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/25.png" alt="25" title="25"></p><ul><li>新增Transformer Engine，Transformer模型的训练速度是上一代的6倍</li><li>动态编程指令（DPX）</li><li>NVLink第四代</li><li>支持PCIe 5.0并采用了HBM3，有5TB/s的对外带宽和3TB/s的内部存储带宽</li><li>144个SM<ul><li>每个SM有4个处理块，每个处理块有16个INT32 CUDA Core，32个FP32 CUDA Core，16个FP64 CUDA Core，1个Tensor Core(第四代)</li></ul></li><li>代表产品<ul><li>NVIDIA H100 SXM5</li><li>NVIDIA H100 PCIe</li></ul></li></ul><h1>常见N厂GPU&amp;&amp;价格</h1><table><thead><tr><th>产品型号</th><th>GPU</th><th>架构</th><th>SM个数</th><th>CUDA Core个数</th><th>Tensor Core个数</th><th>FP32单元峰值(GFLOPS)</th><th>Tensor单元峰值(TFLOPS, FP16)</th><th>存储器接口</th><th>存储器大小</th><th>内存带宽(GB/s)</th><th>散热功耗TDP/瓦</th><th>晶体管数量/10亿</th><th>芯片大小/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>m</mi><mi>m</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{mm}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">mm</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></th><th>工艺/nm</th><th>二级市场价格/￥(截止到2023-11-2)</th></tr></thead><tbody><tr><td>NVIDIA GeForce GTX 580</td><td>GF110</td><td>Fermi</td><td>16</td><td>512</td><td>NA</td><td>1332</td><td>NA</td><td>384-bit GDDR5</td><td>6GB</td><td>192.4</td><td>250</td><td>3.0</td><td>520</td><td>40</td><td>NA</td></tr><tr><td>NVIDIA Tesla K40</td><td>GK100</td><td>Kepler</td><td>15</td><td>2880</td><td>NA</td><td>5046</td><td>NA</td><td>384-bit GDDR5</td><td>Up to 12GB</td><td>288.4</td><td>235</td><td>7.1</td><td>551</td><td>28</td><td>4599</td></tr><tr><td>NVIDIA Tesla M40</td><td>GM200</td><td>Maxwell</td><td>24</td><td>3072</td><td>NA</td><td>6844</td><td>NA</td><td>384-bit GDDR5</td><td>Up to 24GB</td><td>288.4</td><td>250</td><td>8.0</td><td>601</td><td>28</td><td>998</td></tr><tr><td>NVIDIA Tesla P100</td><td>GP100</td><td>Pascal</td><td>56</td><td>3584</td><td>NA</td><td>10609</td><td>NA</td><td>4096-bit HBM2</td><td>16GB</td><td>732.2</td><td>300</td><td>15.3</td><td>610</td><td>16 FinFET+</td><td>3899</td></tr><tr><td>NVIDIA Tesla V100</td><td>GV100</td><td>Volta</td><td>80</td><td>5120</td><td>640</td><td>15670</td><td>125</td><td>4096-bit HBM2</td><td>32GB</td><td>897</td><td>300</td><td>21.1</td><td>815</td><td>12 FFN</td><td>36999</td></tr><tr><td>NVIDIA Tesla T4</td><td>TU104</td><td>Turing</td><td>40</td><td>2560</td><td>320</td><td>8141</td><td>65</td><td>256-bit GDDR6</td><td>16GB</td><td>320</td><td>70</td><td>13.6</td><td>545</td><td>12</td><td>6699</td></tr><tr><td>NVIDIA A100 PCIe 80GB</td><td>GA100</td><td>Ampere</td><td>108</td><td>6912</td><td>432</td><td>19490</td><td>312</td><td>5120-bit HBM2e</td><td>80GB</td><td>1935</td><td>300</td><td>54.2</td><td>826</td><td>7</td><td>180000</td></tr><tr><td>NVIDIA H100 PCIe 80GB</td><td>GH100</td><td>Hopper</td><td>132</td><td>16896</td><td>528</td><td>62080</td><td>969</td><td>5120-bit HBM3</td><td>80GB</td><td>2039</td><td>350</td><td>80</td><td>814</td><td>4</td><td>240000</td></tr></tbody></table><p>本表大部分数据来自于<a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_09459601.html">通用图形处理器设计-GPGPU编程模型与架构原理</a>，价格部分来自于京东，顺带推荐GPU数据查询网站<a href="https://www.techpowerup.com/gpu-specs/">GPU Database</a>。<br><strong>V100 vs A100 vs H100</strong><br><img src="/2023/11/06/GPU%E7%9B%B8%E5%85%B3/26.png" alt="26" title="26"></p><h1>参考&amp;&amp;致谢</h1><ul><li><a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_09459601.html">通用图形处理器设计-GPGPU编程模型与架构原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/413145211">英伟达GPU架构演进近十年，从费米到安培</a></li><li><a href="https://www.zhihu.com/question/21980949">丽台科技</a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9623445">Evolution of the Graphics Processing Unit(GPU)</a></li><li><a href="https://www.bilibili.com/video/BV1TU4y1j7Wd?p=1&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e">李沐老师的视频</a></li><li><a href="https://face2ai.com/CUDA-F-1-1-%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97-CUDA/">谭升的博客</a></li><li><a href="https://chat.openai.com/chat">ChatGPT</a></li><li><a href="https://www.nvidia.cn/technologies/">NVIDIA技术</a></li><li><a href="https://blog.csdn.net/tony_vip/article/details/117131380">nvidia nvlink互联与nvswitch介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/654417967">聊透 GPU 通信技术——GPU Direct、NVLink、RDMA</a></li><li><a href="https://www.nvidia.cn/design-visualization/nvlink-bridges/">nvlink-bridges</a></li><li><a href="https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf">NVIDIA_CUDA_Programming_Guide</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&amp;mid=2247492895&amp;idx=1&amp;sn=572040d50dcc39bb7e93c1f75e121599&amp;chksm=fe426b29c935e23f80ba9ec00f2bbbef26c4a6af6c0457bc41d1e10f2d9fb78b66b91fe5edb0&amp;scene=21#wechat_redirect">GPU架构与计算入门指南</a></li><li><a href="https://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf">NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf</a></li><li><a href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/tesla-product-literature/NVIDIA-Kepler-GK110-GK210-Architecture-Whitepaper.pdf">NVIDIA-Kepler-GK110-GK210-Architecture-Whitepaper.pdf</a></li><li><a href="https://www.microway.com/download/whitepaper/NVIDIA_Maxwell_GM204_Architecture_Whitepaper.pdf">NVIDIA_Maxwell_GM204_Architecture_Whitepaper.pdf</a></li><li><a href="https://images.nvidia.com/content/pdf/tesla/whitepaper/pascal-architecture-whitepaper.pdf">pascal-architecture-whitepaper.pdf</a></li><li><a href="https://www.nvidia.cn/content/dam/en-zz/zh_cn/Solutions/Data-Center/volta-gpu-architecture/Volta-Architecture-Whitepaper-v1.1-CN.compressed.pdf">volta-gpu-architecture/Volta-Architecture-Whitepaper-v1.1-CN.compressed.pdf</a></li><li><a href="https://images.nvidia.cn/aem-dam/en-zz/Solutions/geforce/ampere/pdf/NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf">NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf</a></li><li><a href="https://resources.nvidia.com/en-us-tensor-core/gtc22-whitepaper-hopper">gtc22-whitepaper-hopper</a></li><li><a href="https://www.techpowerup.com/gpu-specs/">GPU Database</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要是自己对于GPU相关知识的总结，以Nvidia系列GPU为主，具体的架构和编程相关可能会在之后写cuda内容的时候介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;GPU发展历程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;早期阶段（1980年代）&lt;</summary>
      
    
    
    
    <category term="Hardware" scheme="https://penpenf28.github.io/categories/Hardware/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Batch Normalization和Layer Normalization</title>
    <link href="https://penpenf28.github.io/2023/10/25/Batch-Normalization%E5%92%8CLayer-Normalization/"/>
    <id>https://penpenf28.github.io/2023/10/25/Batch-Normalization%E5%92%8CLayer-Normalization/</id>
    <published>2023-10-25T02:38:39.000Z</published>
    <updated>2023-11-03T01:11:45.984Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要内容来自于<a href="https://www.bilibili.com/video/BV1X44y1r77r?p=3&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e">李沐老师的视频</a>，<a href="https://www.cnblogs.com/shine-lee/p/11989612.html">shine-lee的博客</a>，本文主要是以上内容的总结</p></blockquote><h1>Batch Normalization(BN批量归一化)</h1><p>为什么需要BN(Batch Normalization)？</p><ul><li>训练深度网络时，反向传播时每一层的参数会更新，在之后的前向传播时前面层的输出数据会不断变化，会导致后续的层需要不断适应这种变化（这种现象被称为<strong>内部协变量偏移</strong>），内部协变量偏移会导致训练困难和结果的不稳定</li><li>神经网络层数比较深时，反向传播的梯度由后向前计算，如果不做任何处理，那么后面的梯度变化会更加的敏感，前面的梯度变化不明显（因为一般情况下梯度会是n个较小的数相乘，乘到后面可能变化非常不明显，即梯度消失，反之则是梯度爆炸）</li><li>神经网络中前面的layer可能提取一些表面信息，后面的layer根据这些信息来提取高级信息，因此前面的层发生变化对后面的层影响较大，为了避免过于震荡，需要将学习率设置的足够小，会导致收敛比较慢的问题</li><li>Batch Normalization来解决这个问题</li></ul><hr><p>方法</p><ul><li>输入为一个batch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，其中每个元素为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>i</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x_i, i \in B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></li><li>获取小批量里面的均值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和方差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>B</mi></mrow></msub><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B = \frac{1}{|B|}\sum_{i\in B}{x_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3271em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>B</mi></mrow></msub><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>B</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">\sigma^2_B = \frac{1}{|B|}\sum_{i\in B}{(x_i - \mu_B)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3271em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>进行Standardization<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>^</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>B</mi></msub></mrow><msqrt><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup><mo>+</mo><mi>ϵ</mi></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\hat{x_i} = \frac{x_i - \mu_B}{\sqrt{\sigma_B^2 + \epsilon}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.684em;vertical-align:-0.8296em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.4761em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0198em;"><span class="svg-align" style="top:-3.4286em;"><span class="pstrut" style="height:3.4286em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em;"><span style="top:-2.1607em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3393em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">ϵ</span></span></span><span style="top:-2.9918em;"><span class="pstrut" style="height:3.4286em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5429em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.5429em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4368em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8296em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>是防止除零引入的极小量</li></ul></li><li>进行Scale and shift<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>γ</mi><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>^</mo></mover><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">y_{i} = \gamma \hat{x_i} +\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li><li>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>为方差(scale参数)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>为均值(shift参数)，均为可学习的参数</li></ul></li></ul><p><img src="/2023/10/25/Batch-Normalization%E5%92%8CLayer-Normalization/1.png" alt="1" title="1"></p><p>图片来自于<a href="http://fancyerii.github.io/2019/03/09/transformer-illustrated/">李理的博客</a><br>在BN层中，不同层的输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>不存在信息交流</p><hr><p>位置</p><ul><li>一般放在全连接层和卷积层输出之后，激活函数之前，一般不用于激活函数之后</li><li>全连接层和卷积层的输入</li></ul><p><img src="/2023/10/25/Batch-Normalization%E5%92%8CLayer-Normalization/2.png" alt="2" title="2"></p><ul><li>全连接层<ul><li>在全连接层中，数据一般是二维的，通常表示为 [batch_size, features]</li><li>当应用Batch Normalization时，沿着batch维度（即第0维度）对每个特征进行标准化</li><li>即作用在特征维，将每组特征做BN</li></ul></li><li>卷积层<ul><li>在卷积层中，数据通常是四维的，表示为 [batch_size, channels, height, width]</li><li>一个卷积核产生一个feature map，一个feature map对应一对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li><li>同一个batch同channel的feature map共享一对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，即卷积层有n个卷积核，那么有n对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>参数</li><li>与全连接层不同，卷积层中的BN是沿着batch维度、高度和宽度对每个通道进行标准化</li><li><img src="/2023/10/25/Batch-Normalization%E5%92%8CLayer-Normalization/3.png" alt="3" title="3"></li><li>即作用在通道维，将每组channel做BN</li></ul></li><li><strong>主要使用在深层网络中</strong></li></ul><hr><p>训练阶段</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>对于一个batch来说都是固定的参数</li><li>只需要反向传播时更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>即可</li></ul><hr><p>推理阶段</p><ul><li>在这个阶段所有参数都是固定的，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>都是固定值<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>在推理阶段可能只有1个值，可以采用训练收敛最后几个mini batch的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>的期望作为推理阶段的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\mu_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>在训练结束后，两者收敛，直接采用收敛值即可</li></ul></li></ul><hr><p>作用</p><ul><li>Batch Normalization固定小批量中的均值和方差，然后学习出合适的偏移和缩放，来避免梯度的剧烈变化</li><li>可以加速收敛速度，但一般不改变模型精度，可以将学习率适当调大</li><li>对权重初始化和尺度不再敏感</li><li>抑制了梯度消失，可以使用sigmoid和tanh作为激活函数了</li><li>BN层具有某种正则作用，不太依赖dropout，减少过拟合</li></ul><hr><p>为什么BN层有效？</p><ul><li>让损失函数更加平滑，有利于梯度下降，具体可以阅读<a href="https://arxiv.org/abs/1805.11604">论文</a></li><li>直觉上的解释，没有BN层的情况下，网络没法直接控制每层的输入分布，其分布由前面层的权重共同决定，网络想要调整分布的话，需要通过复杂的反向传播过程来调整前面每个权重的实现，BN层相当于将分布的均值和方差从权重中剥离出来，只需要调整<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>两个参数就可以调整每层的分布，让分布和权重的配合更加容易</li></ul><hr><p>适用场景</p><ul><li>每个batch较大，数据分布比较接近</li><li>训练之前需要做好充分的shuffle</li></ul><p>缺点</p><ul><li>不适用于batch较小的情况，BN是对整个batch样本统计均值和方差</li><li>由于运行过程中需要统计每个batch的统计信息，因此不适用于动态网络结构和RNN</li></ul><hr><p>其他</p><ul><li>没有scale and shift是否可行？<ul><li>可以，但可能会导致网络的表达能力下降</li><li>浅层模型中，只需要模型适应数据分布即可，但是在深层模型中，需要输入分布和权重相互协调，强制把输入分布限制在zero mean unit variance并不见得最好，加入参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>有利于分布和权重相互协调</li></ul></li><li>BN层放在Relu前面还是后面？<ul><li>原paper建议在Relu前，因为Relu输出非负，不能近似为高斯分布</li><li>但是也有其他研究说明前后差距不大</li></ul></li></ul><hr><p>code<br><strong>全连接层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatchNormalizationManual</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_features, epsilon=<span class="number">1e-5</span>, momentum=<span class="number">0.1</span></span>):</span><br><span class="line">        self.num_features = num_features</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self.momentum = momentum</span><br><span class="line"></span><br><span class="line">        self.gamma = torch.ones(num_features).requires_grad_()</span><br><span class="line">        self.beta = torch.zeros(num_features).requires_grad_()</span><br><span class="line"></span><br><span class="line">        self.running_mean = torch.zeros(num_features)</span><br><span class="line">        self.running_var = torch.ones(num_features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, training=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">if</span> training:</span><br><span class="line">            <span class="comment"># Compute batch mean and variance</span></span><br><span class="line">            batch_mean = torch.mean(x, dim=<span class="number">0</span>)</span><br><span class="line">            batch_var = torch.var(x, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update running statistics</span></span><br><span class="line">            self.running_mean = self.momentum * batch_mean + (<span class="number">1.0</span> - self.momentum) * self.running_mean</span><br><span class="line">            self.running_var = self.momentum * batch_var + (<span class="number">1.0</span> - self.momentum) * self.running_var</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Normalize</span></span><br><span class="line">            x_norm = (x - batch_mean) / torch.sqrt(batch_var + self.epsilon)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Normalize using running statistics</span></span><br><span class="line">            x_norm = (x - self.running_mean) / torch.sqrt(self.running_var + self.epsilon)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Scale and shift</span></span><br><span class="line">        out = self.gamma * x_norm + self.beta</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其中self.momentum用于平滑地更新并跟踪训练数据的运行均值和方差，通常设置为0.9或0.99,有助于减少运行统计数据的批次之间的波动，使得BN在训练中更稳定</li><li>在实际的应用或推断阶段，模型通常使用平滑的运行统计数据进行标准化，而不是使用单个批次的统计数据</li></ul><p><strong>卷积层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConvBatchNormalizationManual</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_channels, epsilon=<span class="number">1e-5</span>, momentum=<span class="number">0.1</span></span>):</span><br><span class="line">        self.num_channels = num_channels</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self.momentum = momentum</span><br><span class="line"></span><br><span class="line">        self.gamma = torch.ones(num_channels).requires_grad_()</span><br><span class="line">        self.beta = torch.zeros(num_channels).requires_grad_()</span><br><span class="line"></span><br><span class="line">        self.running_mean = torch.zeros(num_channels)</span><br><span class="line">        self.running_var = torch.ones(num_channels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, training=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">if</span> training:</span><br><span class="line">            <span class="comment"># Compute batch mean and variance for each channel</span></span><br><span class="line">            batch_mean = torch.mean(x, dim=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">            batch_var = torch.var(x, dim=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update running statistics</span></span><br><span class="line">            self.running_mean = self.momentum * batch_mean.squeeze() + (<span class="number">1.0</span> - self.momentum) * self.running_mean</span><br><span class="line">            self.running_var = self.momentum * batch_var.squeeze() + (<span class="number">1.0</span> - self.momentum) * self.running_var</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Normalize</span></span><br><span class="line">            x_norm = (x - batch_mean) / torch.sqrt(batch_var + self.epsilon)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Normalize using running statistics</span></span><br><span class="line">            x_norm = (x - self.running_mean.view(<span class="number">1</span>, self.num_channels, <span class="number">1</span>, <span class="number">1</span>)) / \</span><br><span class="line">                     torch.sqrt(self.running_var.view(<span class="number">1</span>, self.num_channels, <span class="number">1</span>, <span class="number">1</span>) + self.epsilon)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Scale and shift</span></span><br><span class="line">        out = self.gamma.view(<span class="number">1</span>, self.num_channels, <span class="number">1</span>, <span class="number">1</span>) * x_norm + \</span><br><span class="line">              self.beta.view(<span class="number">1</span>, self.num_channels, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Layer Normalization(层归一化)</h1><p>既然有了BN，为什么还需要LN？</p><ul><li>LN与BN的本质不同是normalization的方向不同<ul><li>BN是对batch的维度去做归一化，也就是针对不同样本的同一特征做操作。LN是对hidden的维度去做归一化，也就是针对单个样本的不同特征做操作</li><li>具体而言，BN就是在每个维度上统计所有样本的值，计算均值和方差；LN就是在每个样本上统计所有维度的值，计算均值和方差</li></ul></li><li>在NLP领域，LN更加合适<ul><li>如果将一批文本的作为一个batch，BN的操作方向是将每个相同位置进行scale and shift，而文本的复杂性较高，不同句子的同一位置分布大概率是不同的，因此BN不符合NLP的规律</li><li>在训练过程中，对BN来说需要保存每个step的统计信息（均值和方差）。在测试时，由于变长句子的特性，测试集可能出现比训练集更长的句子，所以对于后面位置的step，是没有训练的统计量使用的</li><li>与 BN 不同，LN 是一种横向的规范化，它综合考虑一层所有维度的输入，计算该层的平均输入值和输入方差，然后用同一个规范化操作来转换各个维度的输入</li></ul></li></ul><hr><p>方法</p><ul><li>和BN类似，但是normalization的方向不同</li><li>输入为一个batch <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，其中每个元素为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>i</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x_i, i \in B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，每个元素又有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|D|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">∣</span></span></span></span>个特征</li><li>获取单个样本特征均值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\mu_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和方差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>L</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi>D</mi></mrow></msub><msub><mi>x</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mu_L = \frac{1}{|D|}\sum_{j\in D}{x_{i,j}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi>D</mi></mrow></msub><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>−</mo><msub><mi>μ</mi><mi>L</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">\sigma^2_L = \frac{1}{|D|}\sum_{j\in D}{(x_{i,j} - \mu_L)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>进行Standardization<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>^</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>L</mi></msub></mrow><msqrt><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo>+</mo><mi>ϵ</mi></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\hat{x_i} = \frac{x_i - \mu_L}{\sqrt{\sigma_L^2 + \epsilon}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.684em;vertical-align:-0.8296em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.4761em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0198em;"><span class="svg-align" style="top:-3.4286em;"><span class="pstrut" style="height:3.4286em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em;"><span style="top:-2.1607em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">L</span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3393em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">ϵ</span></span></span><span style="top:-2.9918em;"><span class="pstrut" style="height:3.4286em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5429em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.5429em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4368em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8296em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>防止除零引入的极小量</li></ul></li><li>进行Scale and shift<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>γ</mi><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>^</mo></mover><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">y_{i} = \gamma \hat{x_i} +\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li><li>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>为方差(scale参数)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>为均值(shift参数)，均为可学习的参数</li></ul></li></ul><p><img src="/2023/10/25/Batch-Normalization%E5%92%8CLayer-Normalization/4.png" alt="4" title="4"><br>这里可以输入形状[batch, seq_len, dims]看作[3, 6, 1]<br>图片来自于<a href="http://fancyerii.github.io/2019/03/09/transformer-illustrated/">transformer-illustrated</a></p><hr><p>训练阶段</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\mu_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>对于单个的样本来说都是固定的参数</li><li>只需要反向传播时更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>即可</li></ul><hr><p>推理阶段</p><ul><li>推理阶段和训练阶段处理方式其实是一致的</li><li>在这个阶段所有参数都是固定的，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\mu_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>都是固定值<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\mu_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^2_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4247em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span></span></span></span>直接根据需要预测的数据计算出来即可</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>在训练结束后，两者收敛，直接采用收敛值即可</li></ul></li></ul><hr><p>作用</p><ul><li>LN不依赖于其他数据，不依赖于batch的大小，针对单个数据在其所有特征上进行归一化</li><li>LN不需要保存mini-bacth的均值和方差，节省了额外的存储空间</li></ul><hr><p>适用场景</p><ul><li>mini-batch训练</li><li>transformer架构</li><li>变长的序列数据的NLP任务</li><li>RNN</li><li>动态网络场景</li></ul><p>缺点</p><ul><li>在CNN架构中，特别是图像任务上，LN效果一般不如BN</li><li>没有考虑批次信息，LN只对单个数据进行归一化，可能会错过某些和数据总体分布相关的信息</li><li>在某些任务中，输入数据的不同特征可能有不同的重要性或规模。由于 LN是在所有特征上进行归一化，这可能会抹平这些特征之间的差异，从而对模型的性能产生负面影响</li></ul><hr><p>code</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LayerNormalization</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dims, eps=<span class="number">1e-6</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(LayerNormalization, self).__init__()</span><br><span class="line">        self.gamma = nn.Parameter(torch.ones(dims))</span><br><span class="line">        self.beta = nn.Parameter(torch.zeros(dims))</span><br><span class="line">        self.eps = eps</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 计算均值和标准差时需要指定最后一个维度</span></span><br><span class="line">        mean = x.mean(-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        std = x.std(-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.gamma * (x - mean) / (std + self.eps) + self.beta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用例子：</span></span><br><span class="line">ln = LayerNormalization(dims=<span class="number">512</span>)</span><br><span class="line">input_tensor = torch.rand(<span class="number">32</span>, <span class="number">10</span>, <span class="number">512</span>)  <span class="comment"># batch=32, seq_len=10, dims=512</span></span><br><span class="line">output = ln(input_tensor)</span><br></pre></td></tr></table></figure><h1>参考&amp;&amp;致谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1X44y1r77r/?vd_source=c3ee641e50e4973352c9085f2fd7974e">李沐老师的视频</a></li><li><a href="https://www.cnblogs.com/shine-lee/p/11989612.html">shine-lee的博客</a></li><li><a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></li><li><a href="https://arxiv.org/abs/1805.11604">How Does Batch Normalization Help Optimization?</a></li><li><a href="https://arxiv.org/abs/1612.04010">An empirical analysis of the optimization of deep network loss surfaces</a></li><li><a href="http://gradientscience.org/batchnorm/">batchnorm</a></li><li><a href="https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html">Understanding the backward pass through Batch Normalization Layer</a></li><li><a href="https://abay.tech/blog/2018/07/01/why-does-batch-normalization-work/">Why Does Batch Normalization Work?</a></li><li><a href="https://zhuanlan.zhihu.com/p/74516930">NLP中 batch normalization与 layer normalization</a></li><li><a href="https://zhuanlan.zhihu.com/p/33173246">详解深度学习中的Normalization，BN/LN/WN</a></li><li><a href="https://zhuanlan.zhihu.com/p/492803886">Transformer中的归一化(五)：Layer Norm的原理和实现 &amp; 为什么Transformer要用LayerNorm</a></li><li><a href="http://fancyerii.github.io/2019/03/09/transformer-illustrated/">Transformer图解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;主要内容来自于&lt;a href=&quot;https://www.bilibili.com/video/BV1X44y1r77r?p=3&amp;amp;vd_source=c3ee641e50e4973352c9085f2fd7974e&quot;&gt;李沐老师的视频&lt;/a&gt;，</summary>
      
    
    
    
    <category term="Deep Learning" scheme="https://penpenf28.github.io/categories/Deep-Learning/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab3-KV-Raft</title>
    <link href="https://penpenf28.github.io/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/"/>
    <id>https://penpenf28.github.io/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/</id>
    <published>2023-10-19T02:41:53.000Z</published>
    <updated>2023-10-19T02:56:23.913Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-kvraft.html">Lab 3</a>相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h1>Part 3A</h1><h2 id="实验说明">实验说明</h2><ul><li>使用在lab2中编写的Raft实现fault-tolerant key-value DB集群</li><li>整个服务分为Clerk端和Server端，在Clerk端发出请求，在Server端处理请求并同步，再将结果返回给Clerk端</li><li>需要完成的请求<ul><li>key value均为string类型</li><li>Get(key): 由Clerk调用，获取Server数据库中key值对应的value</li><li>Put(key, value): 由Clerk调用，将key-value键值对添加到Server数据库中，如果原来存在key键值对，则用新的覆盖旧的</li><li>Append(key, value): 由Clerk调用，将value添加到Server数据库对应key中，可以理解为字符串的拼接</li></ul></li><li>在请求的基础上，结合lab2实现的Raft来完成多台Clerk的linearizability(线性一致性)<ul><li>什么是linearizability？</li><li>图像来自于<a href="https://anishathalye.com/testing-distributed-systems-for-linearizability/">博客</a></li><li><img src="/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/1.png" alt="1" title="1"></li><li><img src="/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/2.png" alt="2" title="2"></li><li>上面给出两张图像，横轴代表时间，纵轴代表Client</li><li>第一张图满足linearizability，而第二张图不满足linearizability</li><li>观察Get的结果，Client 4 Get返回0，Client 3 Get返回1，则按照图一橙色线作为操作完成的时间点即(linearization point)，可以得到正确的结果，而图二无论怎么切割都无法使得先Get 1后Get 0</li></ul></li><li><a href="https://github.com/wuYin/blog/blob/master/distributed_systems/raft-lab3A-fault-tolerant-kv-service.md">Test分析</a><ul><li><strong>TestBasic3A</strong>：正常情况下，保证单个 Client 命令能执行成功，保证 5 台 KVServer 日志一致。</li><li><strong>TestUnreliable3A</strong>：处理 RPC 调用超时，重试请求。</li><li><strong>TestOnePartition3A</strong>：处理多台 Client 和多台 Server 都发生网络分区的情况。</li><li><strong>TestPersistPartitionUnreliableLinearizable3A</strong>：在节点失效、网络不可靠的环境中保证线性一致性。</li></ul></li></ul><h2 id="设计概述">设计概述</h2><p><a href="http://nil.csail.mit.edu/6.824/2021/notes/raft_diagram.pdf">官方diagram</a>，个人感觉不是特别清晰，根据自己的实现重新画了一个简化版本的<br><img src="/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/3.png" alt="3" title="3"><br><img src="/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/4.png" alt="4" title="4"><br><img src="/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/5.png" alt="5" title="5"></p><h3 id="Clerk">Clerk</h3><ul><li>Clerk自身参数除了默认的servers，还需要定义自身的Clerk id(cid)和当前系统中的leader id</li><li>Clerk负责向对应的KV-Server传递Command信息，传递过程使用RPC进行通信，因此需要定义一些RPC请求回复变量<ul><li>对于Get方法，需要传递给KV-Server的只有key，返回信息则是key对应的value</li><li>对于Put和Append方法，合并为PutAppend方法，传递的参数除了key，value外，还需要Clerk id和Request id（用来唯一定义这条Command）</li></ul></li></ul><h3 id="KV-Server">KV-Server</h3><ul><li>Make时创建一个后台协程DoApply，一直监听Raft系统向自己传输的需要apply的Command<ul><li>注意，并不是监听Clerk向自己发送的Command！！！<ul><li>因为在Clerk向自身KV-Server发送相关Command时，Server本身是作为一个信息转发站，将Command信息先发送到Raft服务中，让集群中各个节点完成同步，集群同步后再通过管道将需要apply的Command发送到Server进行实际的apply</li></ul></li></ul></li></ul><h3 id="整体流程">整体流程</h3><ul><li>首先通过各类Make方法构建整个系统<ul><li>对于Client，通过rand方法生成自己的cid</li></ul></li><li>用户操作客户端Clerk发起命令，以Put(key, value)为例<ul><li>1 找到leader，并将参数通过RPC传递给leader对应KV-Server的PutAppend方法</li><li>2 该KV-Server使用管道将传递进来的参数继续传递给Raft系统，等待系统完成大多数commit并向KV-Server发送需要apply的Command（已经在lab2中完成），并为这个Command创建一个channel(Command Index -&gt; channel 的映射)，通过DoApply向这个channel发送信息来判断是否apply成功<ul><li>如果等待超时，回到第一步</li><li>从管道中成功接收到信息，说明这条Command已经成功apply到KV系统中</li></ul></li><li>3 KV-Server配置RPC reply信息并返回success</li><li>4 Clerk收到RPC的回复信息，并返回</li></ul></li><li>Server通过DoApply协程监听Raft系统向自己传输的需要apply的Command<ul><li>从管道接收到需要apply的Command(以Put为例)，如果Command valid，则更新kv.kv( kv.kv[args.Key] = args.Value )，并向刚才创建的channel发送成功的信息，证明已经完成了这条Command的apply</li><li>继续循环监听kv.applyCh</li></ul></li></ul><h3 id="Fault-tolerance">Fault-tolerance</h3><ul><li>Raft相关fault已经在Lab 2中妥善处理，主要关注KV-Server的fault<ul><li>Server直接宕机(Lab 3B中使用Snapshot处理)</li><li>Clerk和Server之间的RPC丢失问题(下面栗子来源于<a href="https://zhuanlan.zhihu.com/p/568777696">十一的博客</a>)</li></ul></li></ul><ol><li>Client 向 Server 发送 Append(x, 1) 的请求</li><li>Server 成功接收，Raft 层达成共识，应用至状态机。此时状态机状态 {x: 1}</li><li>由于网络原因，Server 向 Client 返回的结果丢失</li><li>Client 苦苦等待，也没有收到 Server 返回的结果，于是超时重试。绕了一圈后又回到了这个 Server (此 Server 仍为 Leader)</li><li>Client 又向 Server 发送 Append(x, 1) 的请求，Server 成功接收，Raft 层达成共识，应用至状态机。此时状态机状态 {x: 11}</li><li>这次 Server 成功向 Client 返回了结果。</li><li>Client 成功收到了返回的结果，结束请求。然而原本的 Append(x, 1) 请求，造成了 Append(x, 11) 的后果。</li></ol><p>出现上述问题的原因是Raft允许相同的command 传递给Server进行apply多次，因此我们需要在Server的服务中对传输的command去重。<br><strong>方案</strong><br>在Server中添加一个映射map kv.clc (means client latest command)，所有Client对应的最新的一次操作，即Client -&gt; Command的映射，在Server apply之前查看当前Client的上一次执行的最新命令是否和这次的相同，如果相同，说明是重复的命令，无需执行，这样可以避免命令apply多次的问题，用这种方式完成一定的Fault-tolerance。</p><h2 id="注意">注意</h2><p>对于Clerk</p><ul><li>ReTry间隔设置为300毫秒</li><li>没有用到Lock</li><li>注意当前leader失效的情况，如果失效，我采用的是逐个寻找的方法</li></ul><p>对于Server</p><ul><li>也需要注意当前leader失效的情况，需要判断Server apply命令后leader是否发生变化</li><li>在操作map映射时需要注意Lock的使用，对于kv.kv即存储的键值对，个人没有使用Lock，因为每个Server都保存者自己的数据，没有竞争</li></ul><h1>Part 3B</h1><h2 id="实验说明-2">实验说明</h2><ul><li>在3A中，Client Operation通过leader同步到其他的follwer中，同步过程使用Raft维护数据的一致性，随着Client Operation的增多，每个Server和对应的Raft服务不可能无休止的存储数据(kv.kv rf.log)，因此需要Snapshot（快照）来压缩使用空间</li><li>如果之前Lab 2的Snapshot做到完备实现的话，3B是比较简单的</li></ul><h2 id="设计概述-2">设计概述</h2><ul><li>Raft的Snapshot已经在Lab 2中完成，但是还需要KV-Server传输相关数据保存至snapshot</li><li>Client操作不涉及Snapshot</li><li>对于KV-Server需要保存什么？<ul><li>生成快照时的数据库</li><li>3A中为了fault-tolerance所设置的map映射，即kv.clc，所有Client对应的最新的一次操作，避免Command的重复apply</li></ul></li><li>什么时候需要生成Snapshot？<ul><li>DoApply一直在监听Raft传来的Command，当传来的Command合法，执行完成后发现kv.rf.GetStateSize() &gt;= kv.maxraftstate &amp;&amp; kv.maxraftstate != -1时，就需要进行Raft的Snapshot，调用Snapshot时不要忘记添加KV-Server需要保存的数据</li></ul></li><li>什么时候需要安装Snapshot？<ul><li>DoApply一直在监听Raft传来的Command，当传来的Command不合法时，说明当前Server缺少内容，这时就需要CondInstallSnapshot进行Snapshot的安装</li></ul></li></ul><p><img src="/2023/10/19/MIT6-824-2021-Lab3-KV-Raft/6.png" alt="6" title="6"></p><h2 id="注意-2">注意</h2><ul><li>KV-Server的在初始化时需要readSnapshot，确保如果Server之前宕机的话可以恢复之前的状态</li></ul><h1>总结</h1><ul><li>Lab 3A在Lab 2的基础上完成了一个异步Fault-tolerant Key-Value数据库，依靠底层 Raft 算法在节点崩溃重启甚至不可用、网络延迟丢包甚至分区的环境下，依旧对多个Client 保证数据的线性一致性</li><li>Lab 3B则实现了实时监测Raft状态信息，阶段生成快照，当发现自身缺失信息时则安装快照，维持了数据的一致性</li><li>关于fault-tolerance，3A中利用一个映射保存Client和他上一次最新apply的命令来保证不会重复提交的问题，3B则是利用Snapshot进行Server的恢复，避免了机器宕机后造成的数据不一致问题</li><li>Test时可能遇到超时的问题，考虑一下在Lab 2中Lock是否合理使用，不合理的Lock可能会导致争用异常激烈</li></ul><h1>参考内容 &amp;&amp; 致谢</h1><ul><li><a href="http://nil.csail.mit.edu/6.824/2021/papers/raft-extended.pdf">raft论文</a> Sec 7 &amp;&amp; 8</li><li><a href="https://github.com/wuYin/blog/blob/master/distributed_systems/raft-lab3A-fault-tolerant-kv-service.md">wuYin的Github1</a></li><li><a href="https://github.com/wuYin/blog/blob/master/distributed_systems/raft-lab3B-kv-service-log-compaction.md">wuYin的Github1</a></li><li><a href="https://sworduo.github.io/2019/06/21/MIT6-824-lab3-kvservice/">sworduo的博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/568777696">十一的博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/463146084">谭新宇的博客</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2021/labs/lab-kvraft.html&quot;&gt;Lab 3&lt;/a&gt;相关实验要求并熟悉基础代码。&lt;br&gt;
本文只提供相关实现思路，希望可以读者由此获得灵感。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络极简总结</title>
    <link href="https://penpenf28.github.io/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/"/>
    <id>https://penpenf28.github.io/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-16T12:41:42.000Z</published>
    <updated>2023-10-17T01:05:23.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文结构和内容主要参考自<a href="https://www.cnblogs.com/SivilTaram/">SivilTaram的博客</a>和<a href="https://chhzh123.github.io/blogs/2020-02-10-gnn/">chhzh123的博客</a>并加上自己的一些理解</p></blockquote><h1>图神经网络</h1><p>数据常常可以被分类为欧式数据和非欧式数据。<br>欧式数据通常是我们在日常生活中遇到的最常见的数据类型，例如图像、音频和文本数据，这些数据由简单的序列或网格组成，较为结构化。<br>非欧式数据不属于传统的固定维度向量空间。例如，社交网络、知识图谱、复杂的文件系统都是非欧式数据。这类数据的关键特点是它们之间的关系不能简单地通过欧氏距离来度量，是非结构化的。<br><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/1.png" alt="1" title="1"></p><p>非欧式数据促使了图神经网络（Graph Neural Network, GNN）的出现和发展，GNN中所处理的图一般情况下指的是图论中的图，由若干节点以及连接节点的边所构成的数据结构。</p><hr><p>输入：通常为一个Graph Network<br>输出：节点Label；新的Link；生成新图或者子图</p><p>对于图不同的任务</p><ul><li>节点层面</li><li>Edge(Link)层面 (推荐系统)</li><li>整图方面（分子分类），子图方面（导航）</li></ul><p>常见的任务</p><ul><li>节点分类</li><li>Link预测</li><li>图分类</li></ul><h2 id="原理">原理</h2><p>给定一组图数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>在图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>中都有一个关联的特征向量，初始化时，这些特征可以是节点的属性，标签或其他与节点相关的信息，将节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的特征表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">h_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>GNN的基本操作是通过消息传递(Message Passing)来更新节点表示，每个节点从其邻居接受信息，然后使用这些信息来更新自己的表示。<br>具体来说，每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>时刻接受从其邻居<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻产生的信息，并更新其特征表示为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><msub><mi>T</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msubsup><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mi>v</mi><msub><mi>T</mi><mi>i</mi></msub></msubsup><mo separator="true">,</mo><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><msub><mi>T</mi><mi>i</mi></msub></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h^{T_{i+1}}_v = Combine(h^{T_i}_v, Aggregate(h^{T_i}_{N(v)}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1383em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4384em;vertical-align:-0.5152em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">mbin</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9232em;"><span style="top:-2.3598em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5152em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><msub><mi>T</mi><mi>i</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">h^{T_i}_{N(v)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4384em;vertical-align:-0.5152em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9232em;"><span style="top:-2.3598em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5152em;"><span></span></span></span></span></span></span></span></span></span>是节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻的所有邻居特征表示</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Aggregate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span>是聚集函数，用于将所有邻居特征聚合为一个单一的向量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Combine</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">mbin</span><span class="mord mathnormal">e</span></span></span></span>是组合(or Update)函数，用于将聚合后的邻居特征与自身特征结合在一起</li><li>每一个时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>共享权重</li></ul><p>有了上面公式之后，可以通过迭代消息传递层(GNN Layer)来增加模型的深度，每个节点特征可以通过多跳邻居进行更新，在某种程度上GNN和RNN较为相似。</p><h1>图卷积</h1><p><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/2.png" alt="2" title="2"><br>图片来自<a href="https://www.cnblogs.com/SivilTaram/">SivilTaram的博客</a></p><ul><li>将图片中的每一个像素点视为一个节点可以表示为左图，一个普通的图结构可以表示为右图</li><li>左侧是一个传统卷积核，右侧是一个图卷积核</li><li>可以观察到以左图为代表的欧式空间中，邻居的节点数量都是固定的，但是在右图这种非欧式结构中，节点的邻居数量并不固定，因此传统的卷积核无法适用到图结构中</li></ul><p>如何解决邻居节点数量不固定的问题？</p><ul><li>将非欧式空间的图转换为欧式空间</li><li>找出方法使得卷积核可以从变长邻居节点中抽取特征</li></ul><h2 id="图卷积框架">图卷积框架</h2><p><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/3.png" alt="3" title="3"><br>图片来自<a href="https://www.cnblogs.com/SivilTaram/">SivilTaram的博客</a></p><ul><li>输入为一张Graph Network</li><li>在每层Convolution Layer中，对每个节点的邻居进行卷积操作(Aggregate)，使用卷积结果更新节点，再经过激活函数如Relu作为输出</li><li>以上述操作为一个基本单元，进行Layer的叠加</li><li>将最后的输出转换为需求任务进行处理(比如节点分类或者图分类)</li></ul><p>GCN对比GNN</p><ul><li>GCN与GNN的根本不同在于，GCN是多层堆叠，每一层的参数是不同的，而GNN是迭代求解，每一层的参数是共享的，GNN与RNN结构上比较相似。</li></ul><p>空域卷积和频域卷积是图卷积网络中两种主要的卷积方法，下面分别介绍这两种方法。</p><h2 id="空域卷积-Spatial-Convolution">空域卷积(Spatial Convolution)</h2><p>基本思想</p><ul><li>直接在图上进行卷积，模拟传统CNN中的卷积</li></ul><p>工作方式</p><ul><li>使用节点的邻居信息，例如节点特征的新值可以是自身特征和邻居特征的加权组合</li></ul><h3 id="消息传递模型-Message-Passing-Model">消息传递模型(Message Passing Model)</h3><p>这里的消息传递模型和前述GNN中的消息传递为同一内容，这一模型将空域卷积分解为两个过程：消息传递与状态更新，针对GCN重新改写GNN中的消息传递公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mi>v</mi><mi>l</mi></msubsup><mo separator="true">,</mo><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mi>l</mi></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h^{l+1}_v = Combine(h^{l}_v, Aggregate(h^{l}_{N(v)}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1461em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-0.447em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">mbin</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.428em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.447em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></p><ul><li>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>代表图卷积的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层，上式的物理意义是收到来自第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层每个节点的信息后，根据这些信息来更新自身节点第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>层的状态</li><li>在GNN中是根据级联的时间来更新状态，共享参数，在GCN中则是根据级联的层来更新状态，每一层有自己的参数</li></ul><h3 id="图采样与聚合-Graph-Sample-and-Aggregate">图采样与聚合(Graph Sample and Aggregate)</h3><p>在消息传递模型下，卷积操作的对象是整张图的每个节点，意味着需要将所有的节点放入内存或者显存中才能进行卷积操作，对于实际场景下的大规模图，这种方式显然是不可行的。<br>GraphSAGE(<u>SA</u>mple &amp;&amp; aggre<u>G</u>at<u>E</u>)提出的动机就是来解决这个问题，从名字就可以看出来GraphSAGE所执行的操作，先采样(Sample)再聚合(Aggregate)。</p><p><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/4.png" alt="4" title="4"><br>流程</p><ul><li>在图中随机采样若干个结点，结点数为传统任务中的batch_size。对于每个结点，随机选择固定数目的邻居结点(这里邻居不一定是一阶邻居，也可以是二阶邻居)构成进行卷积操作的图</li><li>将邻居节点信息通过Aggregate函数聚集起来更新刚才采样的节点</li><li>计算采样点的Loss，如果是无监督任务，期望图上邻居节点编码相似，如果是监督任务，根据具体节点任务标签计算损失</li></ul><p>细化GraphSAGE状态更新公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msup><mi>W</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mi>v</mi></msub><mo separator="true">,</mo><msubsup><mi>h</mi><mi>u</mi><mi>l</mi></msubsup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>N</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_ {v}^ {l+1}  =  \sigma  (  W^ {l+1} \cdot  Aggregate(  h_ {v}  ,{  h_ {u}^ {l}  }),  \forall  u  \in  N[v])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1461em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∀</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">])</span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">W^ {l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>层的权重矩阵</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>层的激活函数</li><li>从上式可以看出GraphSAGE的设计重点放在了Aggregate函数上，它可以是不带参数的max, mean, 也可以是带参数的如LSTM等神经网络。核心的原则是它需要可以处理变长的数据。</li></ul><h3 id="直推式学习和归纳式学习">直推式学习和归纳式学习</h3><p>上一小节的GraphSAGE引入了一个新的概念-归纳式学习(inductive learning)，即通过采样与聚合中心节点的邻居信息来生成节点embedding，这是可以适用于不同graph inputs的(结点或边可以后面再持续插入); 而传统的GNN算法是直推式学习(transductive learning)，即在训练节点embedding时需加载所有节点信息。</p><h2 id="频域卷积-Spectral-Convolution">频域卷积(Spectral Convolution)</h2><p>又称谱域卷积，在频域中，图卷积的主要思想是在图的傅里叶空间（或更确切地说，是图拉普拉斯算子的特征空间）中进行卷积。<br>原公式解释起来比较复杂，可以阅读<a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html">博客</a>进行理解，这里只介绍由<a href="https://arxiv.org/abs/1609.02907">论文</a>化简后的频率卷积计算，一个基本的频域卷积操作可以写为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mover accent="true"><mi>A</mi><mo>~</mo></mover><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{H}^{(l+1)}=\sigma\left(\tilde{D}^{-\frac12}\tilde{A}\tilde{D}^{-\frac12}\mathbf{H}^{(l)}\mathbf{W}^{(l)}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.938em;"></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">h^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span> 表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的节点特征</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的可训练权重</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover><mo>=</mo><mi>A</mi><mo>+</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\tilde{A} = A + I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> 是邻接矩阵加单位矩阵，单位矩阵是为了加入自循环，这样每个节点也会考虑自己的特征</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>D</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>的度矩阵，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mover accent="true"><mi>A</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\tilde{D}_{ii}=\sum_{j}\tilde{A}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0702em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.356em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 是非线性激活函数，如Relu</li></ul><p>该公式可以在频域中捕获图上每个节点与其邻居的关系，并利用这些关系来更新节点特征，这种操作也可以多次迭代，每次迭代都会更深入的整合图的信息。<br>在一般的GCN中实现的就是频域卷积，常见的2层GCN模型代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;data/Cora&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>, transform=NormalizeFeatures())</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCN</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim, hidden_dim, output_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(GCN, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(input_dim, hidden_dim)</span><br><span class="line">        self.conv2 = GCNConv(hidden_dim, output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, data</span>):</span><br><span class="line">        x, edge_index = data.x, data.edge_index</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一层 GCN</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二层 GCN</span></span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型和优化器</span></span><br><span class="line">model = GCN(input_dim=dataset.num_features, hidden_dim=<span class="number">16</span>, output_dim=dataset.num_classes)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model = model.to(device)</span><br><span class="line">data = dataset[<span class="number">0</span>].to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(data)</span><br><span class="line">    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    out = model(data)</span><br><span class="line">    pred = out.argmax(dim=<span class="number">1</span>)</span><br><span class="line">    correct = pred[data.test_mask].eq(data.y[data.test_mask]).<span class="built_in">sum</span>().item()</span><br><span class="line">    <span class="keyword">return</span> correct / data.test_mask.<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主训练循环</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        test_acc = test()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>其他常见模型</h1><h2 id="GAT-Graph-Attention-Network">GAT(Graph Attention Network)</h2><p>回忆NLP中的Encoder-decoder模型，由于Encoder需要将一整个句子的信息压缩到一个高维空间向量，再送入Decoder进行解码，这一个高维空间向量的负担将会非常大，因此研究者就考虑让机器学会判断句子中的不同部分的重要性，从而在解码时更加有针对性地获取特征，此即Attention的思想。<br>将Attention概念引入到Graph中</p><ul><li>对于每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，GAT首先计算该节点与其邻居节点v_j之间的注意力权重，并作归一化得到alpha_ij</li><li>使用注意力权重将邻居节点的表示进行加权平均，以更新节点表示<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>i</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><msub><mi mathvariant="script">N</mi><mi>i</mi></msub></mrow></msub><msub><mi>α</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>W</mi><msubsup><mi>h</mi><mi>j</mi><mi>l</mi></msubsup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_i^{l+1}=\sigma\left(\sum_{j\in\mathcal{N}_i}\alpha_{ij}Wh_j^{l}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1661em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8892em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.14736em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1474em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></li></ul></li></ul><p>通过上述流程，每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>能够聚合来自其邻居节点的信息，而注意力机制允许每个节点对其邻居节点的贡献有所不同，从而提高了模型的表示能力。</p><h1>参考资料</h1><ul><li><a href="https://arxiv.org/ftp/arxiv/papers/1812/1812.08434.pdf">清华综述</a></li><li><a href="https://distill.pub/2021/gnn-intro/">gnn-intro</a></li><li><a href="https://distill.pub/2021/understanding-gnns/">understanding-gnns</a></li><li><a href="https://theaisummer.com/graph-convolutional-networks/?continueFlag=5f444a0790b0bff0c474b56279b5924f">introduction to graph convolutions from scratch</a></li><li><a href="https://chhzh123.github.io/blogs/2020-02-10-gnn/#gcn">chhzh123的博客</a></li><li><a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_1.html#%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0">SivilTaram的博客1</a></li><li><a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html#%E9%A2%91%E5%9F%9F%E5%8D%B7%E7%A7%AFspectral-convolution">SivilTaram的博客2</a></li><li><a href="https://chat.openai.com/chat">ChatGPT</a></li><li><a href="https://paperswithcode.com/datasets?mod=graphs&amp;page=1">数据集</a></li><li><a href="https://paperswithcode.com/methods/category/graph-models">常见模型的实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文结构和内容主要参考自&lt;a href=&quot;https://www.cnblogs.com/SivilTaram/&quot;&gt;SivilTaram的博客&lt;/a&gt;和&lt;a href=&quot;https://chhzh123.github.io/blogs/2020-0</summary>
      
    
    
    
    <category term="Deep Learning" scheme="https://penpenf28.github.io/categories/Deep-Learning/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
    <category term="Graph Neural Network" scheme="https://penpenf28.github.io/tags/Graph-Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>Transformer简单笔记</title>
    <link href="https://penpenf28.github.io/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://penpenf28.github.io/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-14T16:07:12.000Z</published>
    <updated>2023-10-16T02:35:22.762Z</updated>
    
    <content type="html"><![CDATA[<p>主要来自于<a href="https://www.bilibili.com/video/BV1hs4y1a7c9?p=1&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e">李宏毅老师的视频</a>，在此之上进行了重点信息的总结。</p><h1>Self-attention</h1><p>对于神经网络的输入，可能是一个vector或者一组vector，例如输入是一句话，可以将每个词处理后作为一组vector输入到网络中。<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/1.png" alt="1" title="1"></p><ul><li>上图是简单版本Self-attention的使用</li><li>有几个vector输入就有几个vector输出</li><li>Self-attention的输出考虑到了整个sequence</li></ul><hr><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/2.png" alt="2" title="2"><br>self-attention要做的事情简单来说，输入一组vector，根据vector之间的相关联程度，计算并输出一组output vector。</p><hr><p><strong>Self-attention输出的计算流程(以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">b^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>为例)</strong></p><ul><li>第一步，计算输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">a^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>和其他向量相关程度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">ha</span></span></span></span><ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/3.png" alt="3" title="3"></li><li>如何计算任意两两vector之间的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">ha</span></span></span></span><ul><li>常用方法如下，一般采用Dot-product</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/4.png" alt="4" title="4"></li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/5.png" alt="5" title="5"></li><li>以计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msubsup><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">alpha&#x27;_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1467em;vertical-align:-0.3948em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>为例，首先拿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">W^q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span>矩阵和输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">a^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>相乘获得中间矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">q^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></li><li>再拿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">W^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>矩阵分别和其他输入向量相乘获得中间矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">k^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">q^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">k^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>进行Dot-product获得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">alpha_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li><li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">alpha_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>通过Softmax获得最后的相关性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msubsup><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">alpha&#x27;_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1467em;vertical-align:-0.3948em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>输出</li><li>Note: 不是一定需要Softmax，可以替换其他方法</li></ul></li></ul></li><li>第二步，基于上面得到的attention scores来抽取sequence里面的重要信息<ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/6.png" alt="6" title="6"></li><li>将每个vector乘上wv矩阵得到中间矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">v^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li><li>使用先前计算的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msubsup><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">alpha&#x27;_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1467em;vertical-align:-0.3948em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>乘上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">v^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>，最后累加得到最后的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">b^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></li><li>其余的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">b^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>计算方法类似</li></ul></li></ul><hr><p>从矩阵角度来进行操作<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/7.png" alt="7" title="7"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/8.png" alt="8" title="8"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/9.png" alt="9" title="9"></p><p>简化版<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/10.png" alt="10" title="10"></p><ul><li>只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">W^q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">W^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">W^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span>需要学习</li></ul><hr><p>Attention和Self-attention的<a href="https://luweikxy.gitbook.io/machine-learning-notes/self-attention-and-transformer#selfattention-ji-zhi">区别</a>？</p><ul><li><p>以Encoder-Decoder框架为例，输入Source和输出Target内容是不一样的，比如对于英-中机器翻译来说，Source是英文句子，Target是对应的翻译出的中文句子，Attention发生在Target的元素Query和Source中的所有元素之间。</p></li><li><p>Self-attention，指的不是Target和Source之间的Attention机制，而是Source内部元素之间或者Target内部元素之间发生的Attention机制，也可以理解为Target=Source这种特殊情况下的Attention。</p></li><li><p>两者具体计算过程是一样的，只是计算对象发生了变化。</p></li></ul><h1>Multi-head Self-attention</h1><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/11.png" alt="11" title="11"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/12.png" alt="12" title="12"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/13.png" alt="13" title="13"></p><p>为什么需要Multi-head Attention？</p><ul><li>可以让Attention有更丰富的层次。有多个QKV的话，可以分别从多个不同角度来看待Attention。这样的话，输入a，对于不同的multi-headed Attention，就会产生不同的b</li><li>从<a href="https://luweikxy.gitbook.io/machine-learning-notes/self-attention-and-transformer#selfattention-ji-zhi">直觉上理解</a>为什么需要multi-headed Attention<ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/multi.png" alt="multi" title="multi"></li><li>首先观察上面左图，每个单词对应八个attention，八个attention分别用蓝色到灰色表示，首先确定一个单词it，可以从左图中看到其他单词与it的相关性</li><li>提取出橙色和绿色的色块，可以看到单词it对应橙色色块最深的是animal，绿色色块最深的是tire，橙色的注意力主要表明it是个什么东西，从东西的角度说明它是一种动物，而不是苹果或者香蕉。如果我们从状态这个层面来看，it这个动物现在是在怎么样的一个状态，它的状态是tired，而不是兴奋。所以不同的Self-Attention Head是不同方面的理解。</li></ul></li></ul><h1>Positional Encoding</h1><p>通过前面的内容可以发现，Self-attention缺少了非常重要的位置信息。<br>处理方法</p><ul><li>为每一个位置设定一个位置vector ei，每一个不同位置都有自己的一个位置vector</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/14.png" alt="14" title="14"></li><li>ei如何设定？<ul><li>hand-crafted</li><li>learn from data</li><li>尚待研究</li></ul></li></ul><h1>Transformer</h1><p>transformer本质上是一个Sequence-to-sequence(Seq2seq) model，即输入一个sequence，输出一个sequence，输出长度由model自己决定。<br>应用场景</p><ul><li>语音识别</li><li>机器翻译</li><li>语音翻译</li><li>Chatbot</li></ul><h2 id="Seq2seq-Model">Seq2seq Model</h2><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/15.png" alt="15" title="15"></p><p>Seq2seq model主要有Encoder和Decoder构成。</p><h3 id="Encoder">Encoder</h3><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/16.png" alt="16" title="16"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/17.png" alt="17" title="17"><br>黄色为输出的中间vector<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/18.png" alt="18" title="18"></p><ul><li>左边为第一步，将Self-attention的结果做residual处理，再经过一层layerNormalization，将输出作为右边第二步的输入</li><li>右边为第二步，将输入经过一次FC layer的结果继续做一次residual处理，再经过一层layerNormalization，最后再输出</li></ul><blockquote><p>思考：为什么需要用layerNormalization？阅读<a href="https://arxiv.org/abs/2003.07845">论文</a></p></blockquote><p>总览<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/19.png" alt="19" title="19"></p><ul><li>上述为原始论文的结构，该变layerNormalization的位置可能会有更好的结果</li><li>这里Input Embedding输入的三个箭头可以看做计算的Q,K,V矩阵</li></ul><h3 id="Decoder">Decoder</h3><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/20.png" alt="20" title="20"><br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/21.png" alt="21" title="21"></p><ul><li>在Encoder计算完成后，输入作为Decode的参数</li><li>开始时，输入为一个BEGIN vector，Decoder计算出初始输出</li><li>后续Decoder将自己的输出又作为输入继续计算</li><li>直到Decoder输出end标志为止</li></ul><hr><p>总览<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/22.png" alt="22" title="22"></p><hr><p>什么是Masked Multi-head Attention？</p><ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/23.png" alt="23" title="23"></li><li>可以看到在原来的Self-attention中，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">b^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>需要考虑到全部的输入vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">a^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>，但是decoder只能接受来自于自己前面序列的信息，因此变为下面的形态</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/24.png" alt="24" title="24"></li><li>具体计算的变化(以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">b^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>为例)<ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/25.png" alt="25" title="25"></li><li>可以看到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">b^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的计算不再需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">a^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">a^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>的参与</li></ul></li></ul><hr><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/26.png" alt="26" title="26"><br>Cross attention如何运行？<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/27.png" alt="27" title="27"><br>可以看到encoder输出的两个箭头分别表示K, V矩阵，与Masked Sell-attention输出的Q矩阵进行对应操作得到中间变量进行输出。</p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/28.png" alt="28" title="28"><br>在原始网络中，Decoder有许多Block，Encoder最后的输出需要分别发送到这些Block中，但是也有许多的变体。</p><hr><p>Autoregressive(AT) VS Non-autoregressive(NAT)</p><ul><li>AT是根据输入每次只产生一个输出vector</li><li>NAT不是一次只产生一个vector，而是一次将整个句子进行输出</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/29.png" alt="29" title="29"></li><li>如何确定NAT的输出长度？<ul><li>使用另外一个predictor进行预测</li><li>输出一个非常长的sequence，忽略掉第一个END之后的内容</li></ul></li><li>NAT的优点<ul><li>可并行性</li><li>可以控制输出的长度</li></ul></li><li>NAT通常比AT表现差(Multi-modality问题)</li></ul><h2 id="Training">Training</h2><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/30.png" alt="30" title="30"><br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/31.png" alt="31" title="31"></p><ul><li>Decoder每一次的输出，需要和Ground truth计算一次cross entropy，相当于做分类问题，我们需要最小化所有cross entropy的总和</li><li>每次的输入为标准答案，而不是上一次decoder的输出(Teacher Forcing)</li><li>问题: 训练过程中学习的是正确答案，但是test过程中不一定保证每一次的输出都是正确答案，如果输出错误答案，会大大影响后续的计算，如何合理解决？(exposure bias)<ul><li>训练过程中给decoder的输入增加一些错误项(Scheduled sampling)</li></ul></li></ul><h2 id="Others">Others</h2><ul><li>Beam search</li><li>BLEU score</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要来自于&lt;a href=&quot;https://www.bilibili.com/video/BV1hs4y1a7c9?p=1&amp;amp;vd_source=c3ee641e50e4973352c9085f2fd7974e&quot;&gt;李宏毅老师的视频&lt;/a&gt;，在此之上进行了重点信息的总结</summary>
      
    
    
    
    <category term="Deep Learning" scheme="https://penpenf28.github.io/categories/Deep-Learning/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
    <category term="Transformer" scheme="https://penpenf28.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Git常见命令&amp;&amp;流程</title>
    <link href="https://penpenf28.github.io/2023/10/13/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%A8%8B/"/>
    <id>https://penpenf28.github.io/2023/10/13/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%A8%8B/</id>
    <published>2023-10-13T02:13:23.000Z</published>
    <updated>2023-10-14T16:52:50.514Z</updated>
    
    <content type="html"><![CDATA[<p>个人自用</p><ul><li>git clone 仓库</li><li>git checkout -b my-feature<ul><li>切换到需要修改的分支</li></ul></li><li>修改代码</li><li>git diff<ul><li>查看当前修改后的代码与原来my-feature中的代码有哪些区别</li></ul></li><li>git add xxx<ul><li>将代码添加到暂存区</li></ul></li><li>git commit -m “xxx”<ul><li>[Feature]: New module or features.</li><li>[Bugfix]: Fix something.</li><li>[Refactor]: Style check.</li></ul></li><li>git push origin my-feature<ul><li>将本地my-feature分支推送到remote的my-feature分支，如果没有则自动创建</li></ul></li></ul><hr><ul><li>push完成后，准备合并branch到main中（这个过程是pull request， PR）</li><li>squash and merge</li><li>删除remote（主仓库）中的my-feature</li><li>git branch -D my-feature（一般不删除）<ul><li>删除local branch</li></ul></li><li>git pull origin master<ul><li>拉去主仓库中的最新更新</li></ul></li><li>结束</li></ul><hr><ul><li>如果remote main代码有更新</li><li>git checkout main</li><li>git pull origin master<ul><li>把远端的main同步到local的main中</li></ul></li><li>git checkout my-feature</li><li>git rebase main<ul><li>把my-feature暂时丢弃，将最新的main进行更新，然后再把添加my-feature的修改</li><li>有可能出现rebase conflict，手动选择你想要的代码</li><li>然后git rebase --continue</li></ul></li><li>进行完rebase后，git push -f origin my-feature<ul><li>由于进行了rebase，需要加上-f，表示force，强行push</li></ul></li></ul><hr><p>创建自己的新仓库然后更新代码</p><ul><li>首先安装git，添加ssh，配置git信息</li><li>使用<ul><li>git remote add origin <a href="https://github.com/repo_name/proj_name.git">https://github.com/repo_name/proj_name.git</a> 来关联远程仓库</li><li>如果之前关联过的</li><li>git remote set-url origin <a href="https://github.com/repo_name/proj_name.git">https://github.com/repo_name/proj_name.git</a></li><li>使用上面的重新关联</li></ul></li><li>push代码可能会出现无权限错误，用下面的token法解决<a href="https://blog.csdn.net/yjw123456/article/details/119696726">https://blog.csdn.net/yjw123456/article/details/119696726</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人自用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git clone 仓库&lt;/li&gt;
&lt;li&gt;git checkout -b my-feature
&lt;ul&gt;
&lt;li&gt;切换到需要修改的分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改代码&lt;/li&gt;
&lt;li&gt;git diff
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="Git" scheme="https://penpenf28.github.io/categories/Git/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab2-Raft-Part-2C&amp;&amp;2D</title>
    <link href="https://penpenf28.github.io/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/"/>
    <id>https://penpenf28.github.io/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/</id>
    <published>2023-10-12T13:04:05.000Z</published>
    <updated>2023-10-12T13:23:38.892Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html">Lab 2</a>Part 2C &amp;&amp; 2D相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="Part-2C">Part 2C</h3><h4 id="2C实验说明">2C实验说明</h4><ul><li>在raft每次更新重要信息后，对这些信息进行持久化保存</li><li>Test中某个server crash掉后，重新启动可以通过先前保存的持久化数据进行恢复</li></ul><h4 id="设计概述">设计概述</h4><p>在Part 2B实现的较为完备的情况下，Part 2C是比较简单的，只需要根据提示完成persist(), readPersist()函数，并在Make初始化过程中调用readPersist，关键信息更新时调用persist即可。<br>架构图可继续参考<a href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/">前文</a>。</p><h4 id="实现">实现</h4><p>根据论文中提供的信息，我们需要对term, votedFor, log进行持久化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save Raft&#x27;s persistent state to stable storage,</span></span><br><span class="line"><span class="comment">// where it can later be retrieved after a crash and restart.</span></span><br><span class="line"><span class="comment">// see paper&#x27;s Figure 2 for a description of what should be persistent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.term)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore previously persisted state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"><span class="keyword">var</span> term <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> log []*LogEntry</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;term) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;log) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;readPersist error&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.term = term</span><br><span class="line">rf.votedFor = votedFor</span><br><span class="line">rf.log = log</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要server中这些变量发生变化，调用persist()保存信息即可，在这里的持久化并不是保存到disk上，而是通过persist()类保存在内存中，Test中仅仅crash server，并没有crash掉server 对应的persister，以此实现信息的持久化，实际的工程中不会这么去做。</p><h4 id="注意">注意</h4><ul><li>注意<a href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/">前文</a>中的Figure 8问题，如果没有考虑完全会在2C中报错</li></ul><h3 id="Part-2D">Part 2D</h3><h4 id="2D实验说明">2D实验说明</h4><ul><li>raft server随着运行时间越来越长，保存的日志会越来越多，为了节约空间会做compaction(压缩)操作</li><li>压缩过程是将某一个状态之前的日志条目压缩为snapshot</li><li>当某个server落后于leader，且leader中该server的nextIndex所指示的log entry已经被leader压缩了，需要使用leader中的snapshot来更新server</li></ul><h4 id="设计概述-2">设计概述</h4><h5 id="snapshot设计">snapshot设计</h5><p><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/snapshot.png" alt="snapshot" title="snapshot"></p><ul><li>snapshot需要保存的信息<ul><li>LastIncludedIndex: Snapshot最后一个log entry的index，这个字段并不是real index，real index = LastIncludedIndex + logIndex，参考下图<ul><li><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/realIndex.png" alt="realIndex" title="realIndex"></li></ul></li><li>LastIncludedTerm: Snapshot最后一个log entry的term</li><li>MachineState(Data): Snapshot中机器的快照数据</li></ul></li><li>需要实现的函数<ul><li>Snapshot()</li><li>RPC相关，sendInstallSnapshot(), InstallSnapshot()<ul><li>当leader发现某个server nextIndex已经被压缩在快照中，没法通过正常的AppendEntriesRPC进行同步，需要编写相关的RPC使得leader向集群发送对该server安装leader Snapshot的请求，并传递相关的参数</li></ul></li><li>CondInstallSnapshot(), 由集群调用，对目标server安装Snapshot</li></ul></li></ul><h5 id="架构图">架构图</h5><p><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/structure.png" alt="structure" title="structure"></p><h5 id="整体流程">整体流程</h5><ul><li>如果当前server中log数据量超过存储极限，触发Snapshot(m.CommandIndex, w.Bytes())，触发过程发生在config.go中<ul><li>传入参数为m.CommandIndex, w.Bytes()<ul><li>m.CommandIndex 表示一直压缩到logIndex == m.CommandIndex的log entry为止</li><li>w.Bytes() 为传入的snapshot</li></ul></li></ul></li><li>如果当前leader在向其他follower复制日志(Replicate)的过程中发现某follower缺失log，且该follower对应nextIndex的log entry已经被leader压缩进snapshot中了，这时需要leader需要调用sendInstallSnapshot(), InstallSnapshot()来对该follower实现snapshot拷贝，然后该follower在下一个周期再进行正常的Replicate操作<ul><li>简单来说</li><li>leader发现某follower nextIndex对应的log缺失</li><li>发送包括LastIncludedIndex，LastIncludedTerm，Data等信息作为args的InstallSnapshotRPC</li><li>对应的follower收到InstallSnapshotRPC，根据传输过来的参数执行CondInstallSnapshot()，进行snapshot的安装</li></ul></li></ul><h4 id="实现-2">实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>)</span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>遍历自身的log，通过index找到对应的log entry，丢弃该log之前的全部log，并保存自身重要信息和snapshot</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallsnapshotArgs, reply *InstallsnapshotReply)</span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>判断args.Term是否小于rf.term<ul><li>小于说明leader失去时效性，解锁直接返回即可</li></ul></li><li>根据args更新自身term和state等相关信息，解锁</li><li>单独开一个协程向rf.applyCh发送installSnapshot的相关参数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">Snapshot:      args.Data,</span><br><span class="line">SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">CommandValid:  <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>判断lastIncludedIndex和rf.commitIndex<ul><li>小于，说明已经有更新的snapshot了，直接返回false</li></ul></li><li>判断lastIncludedIndex与rf.LogTail().Index的关系<ul><li>大于等于，只保留第一个空的占位log entry</li><li>小于保留lastIncludedIndex之后的log entry</li></ul></li><li>更新第一个占位log entry( rf.log[0] )的Index=lastIncludedIndex，Term=lastIncludedTerm，Command=nil</li><li>更新rf.commitIndex = lastIncludedIndex，rf.lastApplied = lastIncludedIndex</li><li>SaveStateAndSnapshot</li><li>return true</li></ul></li></ul><h4 id="测试">测试</h4><p>编写脚本测试500次，全部通过。<br><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/test.png" alt="test" title="test"><br>整个lab 2单次test用时约为5min40s。<br><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/time.png" alt="time" title="time"></p><h4 id="注意-2">注意</h4><ul><li>Snapshot()中直接对rf.log = rf.log[index:]进行日志丢弃是不合理的 ，go的切片机制导致截取slice时，不会创建新的数组，只是简单的改变了引用的范围，前面的内容不会被gc进行回收，可以通过append方法创建新的数组，确保之前的底层数组会被回收</li></ul><h3 id="参考内容-致谢">参考内容 &amp;&amp; 致谢</h3><ul><li><a href="https://space.bilibili.com/61981458">戌米的论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-locking.txt">raft-locking.txt</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-structure.txt">raft-structure.txt</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li><li><a href="https://zhuanlan.zhihu.com/p/543989771">十一的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/463144886">谭新宇的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/369989974">多颗糖的知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html&quot;&gt;Lab 2&lt;/a&gt;Part 2C &amp;amp;&amp;amp; 2D相关实验要求并熟悉基础代码。&lt;br&gt;
本文只提供相关实现思路，</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab2-Raft-Part-2B</title>
    <link href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/"/>
    <id>https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/</id>
    <published>2023-10-10T07:00:45.000Z</published>
    <updated>2023-10-12T13:24:48.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从本次lab改用了2021版本的实验，后续的内容更加丰富，并对lab 2a的代码进行了重构，放弃了leader candidate follower明确划分的模式</p></blockquote><p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html">Lab 2</a>Part 2B相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="2B实验说明">2B实验说明</h3><ul><li>实现leader和follower之间的log entries的插入和更新</li><li>保证leader和follower之间的log一致</li></ul><h3 id="Test分析">Test分析</h3><p>在test构建系统的过程中调用了Make函数，其中applyCh是raft向系统传送msg的通道，用来更新cfg中的各个raft中的logs信息，应用指令(apply)可以看做向applyCh中写入信息。<br>后续的test通过检查cfg中的log是否一致来判断编写的程序是否正确。</p><ul><li>cfg.nCommitted(index)返回两个参数，1多少个server认为编号为index的log entry被commited了，2被commited的命令</li><li>cfg.ones()在十秒内遍历全部的server，找到leader并Start（启动一个命令），返回该命令的log index，当前的term和是否是leader，然后检查在2s之内这个命令是否被成功提交给大多数server</li><li>rf.Start()的作用是启动新日志写入</li><li>cfg.crash1(i)直接kill掉对应的server</li><li>cfg.disconnect(i)将第i个server从集群系统中断开连接，但是server本身并没有被kill掉</li><li>在leader接收到超过半数的follower commit了对应的log，leader自身开始apply 对应的log，leader apply后通过心跳再提示follower apply对应的log，log一致性检查在cfg.applier中</li></ul><h3 id="设计概述">设计概述</h3><h4 id="架构图">架构图</h4><p><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/structure.png" alt="structure" title="structure"></p><h4 id="结构说明">结构说明</h4><ul><li>通过Make在初始化时创建四个后台协程（其实是3+n个，DoReplicate的数量取决于集群中server的数量）<ul><li>DoElection负责选举</li><li>DoHeartbeat负责心跳</li><li>DoApply负责向集群apply日志</li><li>DpReplicate负责leader与follower之间的日志同步</li></ul></li><li>日志同步的主要流程<ul><li>leader收到客户端指令后(Start)，将指令作为一个新条目（entry）追加到日志中<ul><li>一条LogEntry有三个参数：cmd-指令，term-指令的任期号，index-日志号。</li></ul></li><li>leader通过AppendEntries RPC并行的发送日志到follower，当有超过半数的follower回复后(commit)，leader就可以在本地执行该指令(apply)并把结果返回给客户端。</li><li>注意区别commit和apply，commit是指确定日志已经复制到半数节点，而apply是日志应用到状态机，因此可以理解为applyIndex&lt;=commitIndex</li></ul></li></ul><h4 id="分析">分析</h4><p>整个过程中follower可能会和leader无法保持一致如下图所示</p><ul><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/situation.png" alt="situation" title="situation"></li><li>三类原因以及解决方式<ul><li>follower由于某些延误没有给leader响应，leader会不断重发追加条目请求（AppendEntries RPC），哪怕leader已经回复了客户端（日志已经apply）</li><li>follower崩溃后恢复，这时Raft追加条目的一致性检查<ul><li>一致性检查：leader在每一个发往follower的追加条目RPC中，放入前一个日志条目的索引位置（prevLogIndex）和任期号（prevLogTerm），如果follower在他的日志中找不到前一个日志，follower会拒绝此日志，leader会重新再发送前一个日志，这样逐渐向前定位到follower第一个缺失的日志</li></ul></li><li>leader宕机，崩溃的leader可能复制了日志到部分follower，而新选择的leader可能不具备这些日志，这样导致部分follower中的日志和新leader的日志不相同<ul><li>Raft在这种情况下，leader会强制follower复制他的日志来解决不一致的问题</li><li>两者冲突的日志会被新的leader日志覆盖</li></ul></li></ul></li><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/RPC1.png" alt="RPC1" title="RPC1"></li><li>如果leaderCommit&gt;commitIndex，则commitIndex=min(leaderCommit, index of last new entry)</li></ul><p>安全性相关问题</p><ul><li>leader宕机：选举限制<ul><li>一个follower落后leader若干日志，但是没有遗漏整个任期</li><li>下次选举中，仍然有可能当选leader，当选新leader后永远无法补上之前缺失的那部分日志，造成状态机之间的不一致</li><li>增加一个限制，确保被选出来的leader一定包含之前各任期内所有被提交的日志条目</li><li>通过RequestVote RPC后俩参数<ul><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/RPC2.png" alt="RPC2" title="RPC2"></li><li>如果投票者自己的日志比candidate还新，他会拒绝掉该投票请求</li></ul></li><li>通过比较两份日志中最后一条日志条目的索引和任期号来定义谁的日志比较新</li><li>任期号不同，大的新</li><li>任期号相同，日志长的新</li></ul></li><li>leader宕机：新leader是否提交之前任期内的日志条目<ul><li>一旦当前任期内某个日志条目已经存储到过半服务器节点上，leader就知道当前日志可以被提交了</li><li>follower的提交如何被触发？raft中的提交为单点提交<ul><li>通过AppendEntries RPC中的leaderCommit 参数，表示leader提交到那个日志了，从而自己也可以应用提交到这个日志</li></ul></li><li>raft永远不会通过计算副本数目的方式来提交之前任期内的日志条目，只有自己任期内的日志才能通过计算副本数目来提交，因为可以确认自己当前的任期号是最大的</li></ul></li><li>follower和candidate宕机<ul><li>如果这俩宕机，后续发送给他们的RPC都会失败</li><li>raft通过无限的重试来处理这种失败，如果崩溃的机器重启，那么这些RPC就会成功完成</li></ul></li></ul><p>Test中的Figure 8问题<br>解释可以参考<a href="https://zhuanlan.zhihu.com/p/369989974">https://zhuanlan.zhihu.com/p/369989974</a><br>解决方式</p><ul><li>leader只能够提交自己任期内的log entry，禁止提交非自己任期内的log entry</li></ul><h3 id="实现">实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</span><br></pre></td></tr></table></figure><ul><li>Success = false的情况<ul><li>args.Term &lt; rf.term</li><li>log不匹配</li></ul></li><li>流程<ul><li>获取锁</li><li>检查args.Term和rf.Term<ul><li>如果args.Term &lt; rf.term则失败返回，反之则更新心跳，Term和state</li></ul></li><li>更新term为args.Term，更新state为Follower</li><li>进行日志匹配判定，不匹配则失败返回冲突的index，匹配则进行log合并，持久化</li><li>判定是否需要更新commitIndex<ul><li>如果需要更新则使用min(args.LeaderCommit, rf.LogTail().Index)更新，防止日志回滚</li><li>广播apply命令</li></ul></li><li>success = true</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</span><br></pre></td></tr></table></figure><ul><li>success = false 的情况<ul><li>args.Term &lt; rf.term</li><li>投过票了</li><li>args中的日志旧</li></ul></li><li>流程<ul><li>获取锁</li><li>检查args.Term和rf.Term<ul><li>如果args.Term &lt; rf.term则失败返回</li></ul></li><li>更新term为args.Term，更新state为Follower</li><li>如果检查条件为可以投票（  (没有投过票||投票给同一个人) &amp;&amp; args的日志新  ）<ul><li>更新心跳，更新rf.voteFor，更新success，持久化</li></ul></li><li>不可以投票则success=false返回</li></ul></li><li>如何确定args中log新于rf中log<ul><li>判断args log尾部entry的Term和rf log尾部entry的Term<ul><li>大于则新</li><li>等于则判断尾部的entry Index，大于等于则新</li><li>其余为旧</li></ul></li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> DoElection()</span><br></pre></td></tr></table></figure><p>在Make阶段创建的后台协程，只要rf没有被kill掉就一直运行<br>流程</p><ul><li>获取锁</li><li>判断当前是否是leader，如果是则释放锁continue</li><li>判断接受心跳时间是否超过ElectionTimeout，如果没有，则解锁进行下一次循环</li><li>超时，遍历其他server投票请求投票RPC进行选举<ul><li>选举成功（收到成功的回复数 &gt; num of server / 2），更新自身状态为leader，初始化自身nextIndex和matchIndex，并BroadcastHeartbeat广播一次心跳</li><li>完成上述操作后继续Election</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> BroadcastHeartbeat()</span><br></pre></td></tr></table></figure><p>广播心跳</p><ul><li>使用go协程向其他server 进行Replicate操作（复制日志）</li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Replicate(server <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>复制日志，主要是获取相关参数，传入Sync进行<br>流程</p><ul><li>获取锁</li><li>判断当前状态是否是leader，只有leader才可以进行Replicate操作</li><li>获取当前rf.nextIndex[server]，将位于nextIndex到rf.LogTail之间的logEntry作为参数Entries构建AppendEntriesArgs</li><li>解锁后进行Sync操作</li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Sync(server <span class="type">int</span>, args *AppendEntriesArgs) </span><br></pre></td></tr></table></figure><p>同步操作，通过sendAppendEntries来实现leader和follower之间的日志同步<br>流程</p><ul><li>向server发送sendAppendEntries并获得reply AppendEntriesReply</li><li>获取锁</li><li>判断rf.term 是否等于 args.Term，不相等说明leader已经不是leader，解锁并返回</li><li>判断rf.term和reply.Term，若reply.Term &gt; rf.term，说明leader也已经过期，重设rf的term和state</li><li>reply.Success == true<ul><li>len(args.Entries) == 0，说明是发送的是单纯心跳，不用做任何处理直接返回</li><li>获取logTailIndex := LogTail(args.Entries).Index，以此更新nextIndex和matchIndex</li><li>遍历从rf.commitIndex到logTailIndex，找到最大的超过半数节点match的Index，以此Index更新rf.commitIndex，因为只有在大多数节点都复制了日志后，且日志的任期和leader的任期一致，才能提交日志（test中的figure 8）</li><li>当rf.commitIndex &gt; rf.lastApplied时，进行applyCond.Broadcast()，提醒DoApply协程需要进行apply操作了</li></ul></li><li>reply.Success == false<ul><li>更新rf.nextIndex 和 rf.matchIndex</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> DoApply(applyCh <span class="keyword">chan</span> ApplyMsg)</span><br></pre></td></tr></table></figure><p>后台协程，用来apply log日志，通过条件变量rf.applyCond来实现协程的唤醒<br>流程</p><ul><li>获取rf.applyCond.L.Lock() （在go中，条件变量调用wait方法时必须要持有锁L.Lock()）</li><li>for循环，如果rf kill了则退出并解除相关锁<ul><li>判断当前是否需要apply （rf.lastApplied &lt; rf.commitIndex可以认为需要apply）</li><li>如果不需要则调用wait方法休眠</li><li>需要apply，则获取需要apply的log即rf.GetLogAtIndex(rf.lastApplied)，以该log的信息为参数传入到applyCh</li></ul></li></ul><h3 id="测试">测试</h3><p>编写脚本测试500次，全部通过。<br><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/test.png" alt="test" title="test"></p><h3 id="注意">注意</h3><ul><li>尽量不要简单的将log entry在rf.log中的位置直接作为index，推荐将index单独编入entry结构体中，不然后续的lab 2C 2D会非常痛苦，同理不推荐直接根据entry在log中的位置进行各种操作，可以编写根据logIndex获取对应log entry的函数来进行处理</li><li>需要仔细理解Figure 8的含义，注意在更新commitIndex时日志回滚的问题</li></ul><h3 id="参考内容-致谢">参考内容 &amp;&amp; 致谢</h3><ul><li><a href="https://space.bilibili.com/61981458">戌米的论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-locking.txt">raft-locking.txt</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-structure.txt">raft-structure.txt</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li><li><a href="https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/">Sworduo’s Blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/543989771">十一的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/463144886">谭新宇的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/369989974">多颗糖的知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从本次lab改用了2021版本的实验，后续的内容更加丰富，并对lab 2a的代码进行了重构，放弃了leader candidate follower明确划分的模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 2023 Spring Proj1 Buffer Pool</title>
    <link href="https://penpenf28.github.io/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/"/>
    <id>https://penpenf28.github.io/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/</id>
    <published>2023-08-27T10:18:26.000Z</published>
    <updated>2023-10-10T06:36:37.717Z</updated>
    
    <content type="html"><![CDATA[<h1>实验说明</h1><ul><li>实验主页<a href="https://15445.courses.cs.cmu.edu/spring2023/project1/">https://15445.courses.cs.cmu.edu/spring2023/project1/</a></li><li>本次实验主要完成buffer pool（缓存池）<ul><li>缓存池是用来在主存和磁盘之间移动物理页（physical page）的工具</li><li>该部分对于数据库管理系统（DBMS）的其他部分来说透明，举例来说，DBMS要求使用一个独有的page_id，buffer pool则帮DBMS获取这个page，不需要知道这个page一开始是否在主存中或者是从disk中取到主存再返回给DBMS的</li></ul></li></ul><h1>Task #1 - LRU-K Replacement Policy</h1><p>Task分析<br>需要使用LRU-K策略来实现frame的换入和换出。<br>普通的LRU策略是当replacer的缓存池的大小满了（这里是curr_size == replacer_size）后需要将其中最长时间没有访问的给替换出去。<br>LRU-K相对于LRU缓解了缓存污染的问题。</p><blockquote><p>LRU缓存污染：偶发性的，周期性的批量操作会导致LRU cache的命中率急剧下降，这时缓存中的数据大部分都不是热点数据<br>如何确定K？K增大，命中率会更高，但是适应性差（清楚一个缓存需要大量的数据访问，一般选择LRU-2，LRU == LRU-1）</p></blockquote><p>LRU-K Replacer在本次Task中的实现如下</p><ul><li>维护一个unordered_map&lt;frame_id_t, std::shared_ptr<LRUKNode>&gt; node_store_，用来记录全部的节点</LRUKNode></li><li>维护两个list<ul><li>std::list&lt;std::shared_ptr<LRUKNode>&gt; history_list_; 用来存放访问的节点，但是访问次数小于K次，list的排列顺序按照FIFO的规则，list尾部表示最新访问的数据，头部表示最旧访问的数据</LRUKNode></li><li>std::list&lt;std::shared_ptr<LRUKNode>&gt; cache_list_; 真正需要缓存的节点，访问次数大于等于K次，list的排列顺序遵守LRU-K的规则，参照Node元素中timestamps的头部元素进行排列，按照从小到大的规则，list尾部表示头部元素最大的(最新的)</LRUKNode></li></ul></li><li><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/node_store.png" alt="node_store" title="node_store"></li><li>history_list_.size + cache_list_.size = curr_size</li><li>LRUNode表示一个frame在LRUKReplacer中的状态<ul><li>成员变量：frame_id，size k_（最多纪录前k_个访问时间），访问次数ref_count，是否可以evict，timestamps（数组，前k个访问时间）</li><li>同时每次访问frame时（RecordAccess），ref_count都需要自增</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRUKNode</span>() &#123;</span><br><span class="line">    k_ = <span class="number">0</span>;</span><br><span class="line">    fid_ = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = -1;</span></span><br><span class="line">    is_evictable_ = <span class="literal">true</span>;</span><br><span class="line">    ref_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUKNode</span>(<span class="type">size_t</span> k, <span class="type">frame_id_t</span> fid, <span class="type">size_t</span> access_time, <span class="type">bool</span> is_evictable, <span class="type">size_t</span> ref_count)</span><br><span class="line">: <span class="built_in">k_</span>(k), <span class="built_in">fid_</span>(fid), <span class="built_in">is_evictable_</span>(is_evictable), <span class="built_in">ref_count_</span>(ref_count) &#123;</span><br><span class="line">    timestamps_.<span class="built_in">push_back</span>(access_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUKNode</span>(<span class="type">const</span> LRUKNode &amp;other) &#123;</span><br><span class="line">    k_ = other.k_;</span><br><span class="line">    fid_ = other.fid_;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = other.last_seen_timestamp_;</span></span><br><span class="line">    timestamps_ = other.timestamps_;</span><br><span class="line">    is_evictable_ = other.is_evictable_;</span><br><span class="line">    ref_count_ = other.ref_count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetFrameId</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">frame_id_t</span> </span>&#123; <span class="keyword">return</span> fid_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetRefCount</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> ref_count_; &#125;</span><br><span class="line"><span class="comment">// auto GetLastSeenTimestamp() const -&gt; size_t &#123; return last_seen_timestamp_; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetFirstTimestamp</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> timestamps_.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IsEvictable</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> is_evictable_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IncRefCount</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123; ref_count_++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetTimestamp</span><span class="params">(<span class="type">size_t</span> timestamp)</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = timestamp;</span></span><br><span class="line">    timestamps_.<span class="built_in">push_back</span>(timestamp);</span><br><span class="line">    <span class="keyword">auto</span> first_timestamp = timestamps_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span> (timestamps_.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">        timestamps_.<span class="built_in">erase</span>(timestamps_.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first_timestamp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetFrameId</span><span class="params">(<span class="type">frame_id_t</span> fid)</span> -&gt; <span class="type">void</span> </span>&#123; fid_ = fid; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetK</span><span class="params">(<span class="type">size_t</span> k)</span> -&gt; <span class="type">void</span> </span>&#123; k_ = k; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetEvictable</span><span class="params">(<span class="type">bool</span> is_evictable)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> is_same = is_evictable_ == is_evictable;</span><br><span class="line">    is_evictable_ = is_evictable;</span><br><span class="line">    <span class="keyword">return</span> is_same;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line"><span class="comment">// Remove maybe_unused if you start using them. Feel free to change the member variables as you want.</span></span><br><span class="line"></span><br><span class="line">[[maybe_unused]] <span class="type">size_t</span> k_;</span><br><span class="line">[[maybe_unused]] <span class="type">frame_id_t</span> fid_;</span><br><span class="line"><span class="comment">// [[maybe_unused]] size_t last_seen_timestamp_;</span></span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; timestamps_;</span><br><span class="line">[[maybe_unused]] <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> ref_count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRU-K的原理</p><ul><li>对一个frame访问时(RecordAceess)先搜索全部的节点node_store_<ul><li>如果存在，需要记录当前的current_timestamp，即插入到该LRUK节点的timestamp数组中，如果数组size&gt;k_，则pop掉最前面的元素，这时数组的头部元素就是前第k次访问时间。并将该节点的ref_count++</li><li>如果不存在，则新建一个LRUKNode，记录到node_store和history中（同时指向这个新建的LRUKNode）<ul><li>新加入的节点需要考虑当前需要全部元素的个数，如果curr_size == replacer_size，需要Evict掉一个节点<ul><li>Evict逻辑比较简单（只evict一个节点），分别从头到尾遍历history和cache（顺序一定是先history再cache），如果某个节点is_evictable，就把它从对应的list和node_store中erase掉</li></ul></li><li>新节点直接push_back到history尾部即可（history遵循FIFO规则），注意⚠️需要考虑k = = 1的情况，即新节点ref_count = = 1，在移入history之后又要立即移动到cache</li></ul></li></ul></li><li>如果当前节点ref_count==k，说明该节点现在在history中，达到了k次的访问次数，需要从histroy移动到cache中了<ul><li>因为是将history中的node移动到cache中，不涉及整体size大小的变化，也就不需要Evict cache</li><li>将该frame_id对应的node从history中erase</li><li>从cache_list的链表头开始遍历，比较链表节点中timestamps的头部元素和待插入的节点的timestamps的头部元素（前第k次访问时间），找到第一个比待插入节点大的链表节点（比待插入新），插入到该节点之前</li><li>通过这种操作，保证了cache_list遵循了LRU-K规则，cache最先淘汰的永远是链表头部节点</li></ul></li><li>如果当前节点ref_count&gt;k，说明该节点在访问之前就在cache中了，需要根据该节点的timestamps更新该节点在cache_list中的位置，更新规则同ref_count==k的插入规则</li></ul><p>关键点</p><ul><li>LRUNode对应每一个frame对应的node<ul><li>比较关键的是其中的timestamps_数组，用来存放每次访问的时间，数组大小最大为k，当访问数refcount&gt;=k时，把这个node从history移动到cache中真正缓存下来</li></ul></li><li>history中按照FIFO替换，cache中按照LRU-K替换</li><li>注意k==1的情况</li><li>当ref_count==k时不需要考虑size的变化，因为是history和cache之间的交互，不影响整体的size</li></ul><h1>Task #2 - Buffer Pool Manager</h1><p>Task分析<br>Task1中的replacer只是用来记录frame的使用情况，并不做具体的写入写出操作，Task2的buffer pool则需要完成具体的page的写入写出。<br>一个frame可以理解为一个实际的物理存储空间块，page表示的是逻辑上的存储，在DBMS的一整个生命周期中，page可以对应多个frame（同一时间一个page只能对应一个frame），映射关系通过NewPage构建。</p><p>Task2没有添加额外的成员变量，但是增加了一个成员函数FindFrame，各函数实现逻辑如下</p><ul><li>构造函数<ul><li>初始化时直接根据pool_size_，初始化Page* pages即缓存池</li><li>page_table_存放是的page_id到frame_id的映射</li><li>free_list_存放的是未使用的frame_id（0&lt;=id&lt;pool size），即未使用的实际上的物理frame</li></ul></li><li>增加了一个辅助函数FindFrame<ul><li>输入参数为frame_id_t *frame_id</li><li>先搜索free_list_，如果有空余的frame，那么给frame_id赋值并返回</li><li>如果没有空的frame，用replacer的Evict替换掉其中的一个frame，并将替换的frame的id保存到frame_id中，再从pages取出frame_id对应的page，如果该page dirty，则写入到disk中，然后将该page_id和frame_id的映射从page_table中清除</li></ul></li><li>NewPage<ul><li>找到一个可用的frame_id，使用该frame_id从pages中取出一页，对该页分配page_id，添加table映射，设置pin_count和replacer对于该frame的相关参数</li></ul></li><li>FetchPage<ul><li>从buffer pool中取出page_id对应的page</li><li>首先搜索page_id到frame_id的映射，保证当前page_id对应一个实际的物理frame<ul><li>如果有，则取出该frame_id对应的page，并设置pin_count和replacer</li><li>如果没有，则FindFrame，找到一个合适的物理frame，从磁盘上将该page_id的数据读取到对应的page中</li></ul></li></ul></li><li>UnpinPage<ul><li>输入为page_id和该page是否dirty</li><li>作用是解除page_id对应page的一次引用</li><li>首先是搜索该page_id是否有分配对应的物理frame，如果没有，返回false</li><li>如果有对应的frame，查看该page的pin_count<ul><li>如果小于等于0，说明已经没有数据在引用这个frame，直接返回false</li><li>如果大于0，则pin_count–，把dirty写入到page的is_dirty参数，如果解除这次引用后pin_count==0，还需要对replacer SetEvictable</li></ul></li></ul></li><li>FlushPage<ul><li>输入为page_id</li><li>将page_id对应的page写入到disk中，并更新dirty位</li><li>首先判断page_id是否合法</li><li>在page_table中搜索该page_id，判断是否分配frame<ul><li>如果没有分配，return false</li><li>如有分配，将frame_id对应的page写入到disk，并设置dirty位</li></ul></li></ul></li><li>FlushAllPages<ul><li>输入为空</li><li>遍历page_table，将全部的page都写入到disk中即可</li></ul></li><li>DeletePage<ul><li>输入为page_id</li><li>删除page_id对应的实际的page</li><li>首先遍历table，确定是否有分配实际的frame<ul><li>无，返回true</li><li>有，判断pin_count是否大于0，如果大于0，说明仍有数据引用这块page，因此不能删除，返回false</li></ul></li><li>确定这块page可以删除后<ul><li>分别在page_table清除映射，replacer清除frame，free_list_添加frame，Deallocate该page_id，Reset该page的memory，重置pin_count和dirty位，最后将该page_id设置为INVALID，return true</li></ul></li></ul></li></ul><h1>Task #3 - Read/Write Page Guards</h1><p>Task分析<br>在Task2的条件下，使用DBMS忘记调用UnpinPage可能会导致该page永远不会被Evict掉，会造成page在内存和磁盘之间来回的交换，大大影响系统性能，Task要求实现PageGuard相关成员来完成Page的使用安全性保证。<br>阅读代码后分析任务，主要是完成类的move的自定义构造函数和自定义操作符，类的Drop函数，类的析构函数，前两个Task实现清楚的话，Task3难度属于简单。</p><p>各函数实现细节如下<br>page_guard</p><ul><li>move构造函数<ul><li>将本类中的成员指向传入的右值</li><li>右值置空</li></ul></li><li>move=操作符<ul><li>如果本类和传入的右值地址相同直接返回</li><li>否则Drop掉本类当前的page</li><li>将本类中的成员指向传入的右值</li><li>右值置空</li></ul></li><li>Drop<ul><li>用来取消对当前page的引用</li><li>首先判断当前page是否为空，为空直接返回</li><li>UnpinPage，并置空当前的pageguard</li></ul></li><li>析构函数<ul><li>直接Drop</li></ul></li><li>Read和Write pageguard<ul><li>如果page存在，进行上述实现时需要释放lock</li></ul></li></ul><p>buffer_manager</p><ul><li>Fetch_R/W_Page时，如果page不空，需要上锁</li></ul><h1>Test</h1><ul><li>跑测试之前需要把DISABLE都删除<br><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/grade1.png" alt="grade1" title="grade1"></li></ul><p>leader board rank<br><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/grade2.png" alt="grade2" title="grade2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实验主页&lt;a href=&quot;https://15445.courses.cs.cmu.edu/spring2023/project1/&quot;&gt;https://15445.courses.cs.cmu.edu/spring2023/proje</summary>
      
    
    
    
    <category term="Database" scheme="https://penpenf28.github.io/categories/Database/"/>
    
    
    <category term="CMU15-445" scheme="https://penpenf28.github.io/tags/CMU15-445/"/>
    
    <category term="Database" scheme="https://penpenf28.github.io/tags/Database/"/>
    
    <category term="C++" scheme="https://penpenf28.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 2023 Spring Proj0 C++ Primer</title>
    <link href="https://penpenf28.github.io/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/"/>
    <id>https://penpenf28.github.io/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/</id>
    <published>2023-08-24T16:32:23.000Z</published>
    <updated>2023-10-10T06:36:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1>实验说明</h1><ul><li>实验主页<a href="https://15445.courses.cs.cmu.edu/spring2023/project0/">https://15445.courses.cs.cmu.edu/spring2023/project0/</a></li><li>本次Proj主要完成copy-on-write trie前缀树</li><li>C++17</li></ul><p><img src="/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/cover.png" alt="structure" title="structure"></p><h1>Task #1 - Copy-On-Write Trie</h1><p>Task 1要求完成一个copy-on-write前缀树，需要学习一下相关C++17的语法以及智能指针的使用，学习完成后此任务难度不高。</p><h3 id="Get">Get</h3><p>Get函数主要是根据给定的key来查找是否有对应的value并返回，此部分不涉及copy-on-write。</p><ul><li>设置一个std::shared_ptr<const trienode> node = 根节点</const></li><li>遍历key的每一个字符c，如果可以从node的children中找到对应的child，那么令node = next_node，否则返回nullptr</li><li>遍历至最后一个节点，判断是否是value节点，使用dynamic_cast&lt;const TrieNodeWithValue<T> *&gt;进行强制的类型转换获取value并返回<ul><li>dynamic_cast 只适用于指针和引用类型，不能用于普通对象</li><li>dynamic_cast 在转换时，源类型必须至少含有一个虚函数，以确保运行时类型信息的存在</li><li>dynamic_cast 的转换只能在具有多态关系的类层次结构中进行</li></ul></T></li></ul><h3 id="Put">Put</h3><p>Put函数主要是将对应的key和value插入到前缀树中，在向下遍历的过程中，遇到已有的节点需要Clone一份新的节点。</p><ul><li>需要三个新的变量new_root和前后指针parent和child<ul><li>std::shared_ptr<TrieNode> new_root = this-&gt;root_ ? this-&gt;root_-&gt;Clone() : std::make_shared<TrieNode>(); 因为是从根节点开始向下遍历，如果根节点存在的话也需要Clone一份，不存在的话就新建。</TrieNode></TrieNode></li><li>这里向下遍历用到了前后指针的技巧parent和child，初始parent指向nullptr，child指向new_root</li></ul></li><li>通过遍历key的字符c向下遍历整个前缀树，如果当前parent的对应的孩子节点不为空，就需要copy(Clone)后赋值给child，并更新parent的children，然后令parent=child并继续下一轮迭代</li><li>遍历到最终字符时使用std::make_shared&lt;TrieNodeWithValue<T>&gt;(child-&gt;children_,std::make_shared<T>(std::move(value)));给最终的child赋值<ul><li>该代码作用是创建一个TrieNodeWithValue类型的指针，括号内是初始化TrieNodeWithValue的构造函数的参数列表，其中需要传入child-&gt;children_因为当前节点可能不是叶子节点，需要把它的孩子节点拷贝进来</li></ul></T></T></li><li>将最后更新的child节点更新到parent的children中，返回new_root构建的Trie即可(return Trie(new_root))</li></ul><h3 id="Remove">Remove</h3><p>Remove操作也需要用到copy-on-write思想，不能在原来的树上直接进行操作，考虑到如果当前节点是叶子节点，删除后他的parent的children为空，这时parent也需要删除，继续向上迭代，这种方式很容易联想到使用stack来回溯解决。</p><ul><li>初始化和Put中相同的三个变量，多加一个stack&lt;std::pair&lt;std::shared_ptr<TrieNode>, char&gt;&gt; stk，用来保存访问过的node，便于回溯</TrieNode></li><li>遍历key的字符c，遍历的过程中copy-on-write，并将遍历过的node加入到stack中<ul><li>如果找到空节点，说明要删除的节点根本不存在，直接return nullptr</li></ul></li><li>找到了需要删除的节点<ul><li>如果该节点没有孩子，直接将该节点置空</li><li>如果该节点有孩子，通过child = make_shared<TrieNode>(nxt-&gt;children_)删除掉value</TrieNode></li></ul></li><li>开始回溯<ul><li>不断的获取栈顶元素parent，如果child==nullptr，erase掉parent的children中的对应元素，如果此时parent为空，则也将parent置空，令child=parent</li><li>重复上述过程，直到stack空为止</li></ul></li></ul><h1>Task #2 - Concurrent Key-Value Store</h1><p>Task 2需要学习一下C++中mutex的使用，难度属于简单，lab设置为多个读者和一个写者。</p><h3 id="Get-2">Get</h3><ul><li>首先lock root并获取当前的root，随即释放掉lock，不要直接在持有锁的情况下遍历前缀树来获取value，这样会非常影响性能</li><li>用刚才获取的root调用Get方法并返回即可，</li></ul><h3 id="Put-2">Put</h3><ul><li>写者在Put过程中需要一直持有write_lock避免其他线程对临界区的访问</li><li>获取root的方式和Get相同，然后对root调用Put方法即可</li></ul><h3 id="Remove-2">Remove</h3><ul><li>流程和Put相同，只是调用的方法不同</li></ul><h1>Task #3 - Debugging</h1><p>配置vscode debug文件完成，具体参照<a href="https://www.youtube.com/watch?v=G9gnSGKYIg4">https://www.youtube.com/watch?v=G9gnSGKYIg4</a>。</p><ul><li>build项目，make trie_debug_test -j$(nproc)</li><li>将trie_debug_test配置到vscode的debug文件中</li><li>F5断点观察结果即可</li></ul><p>个人配置文件如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Use IntelliSense to learn about possible attributes.</span><br><span class="line">    // Hover to view descriptions of existing attributes.</span><br><span class="line">    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Debug&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/lab/build/test/trie_debug_test&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中program参数配置你想要debug的程序</li></ul><h1>Task #4 - SQL String Functions</h1><p>实现两个简单的Upper和Lower函数</p><ul><li>首先需要在string_expression.h中实现这两个函数<ul><li>根据expr_type_来选择哪一个函数，然后对函数进行实现</li></ul></li><li>然后在plan_func_call.cpp中对函数进行注册<ul><li>使用func_name返回对应实现的函数</li></ul></li></ul><h1>Test</h1><p><img src="/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/test.png" alt="test" title="test"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实验主页&lt;a href=&quot;https://15445.courses.cs.cmu.edu/spring2023/project0/&quot;&gt;https://15445.courses.cs.cmu.edu/spring2023/proje</summary>
      
    
    
    
    <category term="Database" scheme="https://penpenf28.github.io/categories/Database/"/>
    
    
    <category term="CMU15-445" scheme="https://penpenf28.github.io/tags/CMU15-445/"/>
    
    <category term="Database" scheme="https://penpenf28.github.io/tags/Database/"/>
    
    <category term="C++" scheme="https://penpenf28.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 2020 Lab2 Raft Part 2A</title>
    <link href="https://penpenf28.github.io/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/"/>
    <id>https://penpenf28.github.io/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/</id>
    <published>2023-07-21T12:25:54.000Z</published>
    <updated>2023-10-10T06:56:00.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后续实验对此部分代码进行了重构，因此代码不具备参考性，仅适用于本次实验</p></blockquote><p>阅读本文前请先仔细阅读<a href="%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-raft.html%5D">Lab 2</a>Part 2A相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="2A实验说明">2A实验说明</h3><ul><li>2A部分需要完成Raft系统中的leader election和heartbeats</li><li>保证系统中最多只有一个leader，如有特殊情况可以发生leader的取代</li><li>相关RPC的调用可以阅读labrpc文件夹中的代码</li></ul><h3 id="Test分析">Test分析</h3><p>代码编写完成后通过go test进行测试，可以理解为C艹中的单元测试，这里通过make_config构建起整个系统cfg。</p><ul><li>cfg中包括有多个raft对象，每个raft对象对应有自己的ClientEnd数组peers，表示自己与其他raft的连接，可以理解为传输数据的通道（通过RPC）</li><li>网络中各个raft初始化完成后通过connect进行raft之间的连接（对应RPC通信）</li><li>每个raft有三种state对应论文中的leader，candidate，follower</li><li>以计算机网络的视角来看，cfg.net对应网络层，ClientEnd对应传输层，raft对应应用层</li><li>整体Test系统构建流程<ul><li>make_config构建系统<ul><li>初始化若干个raft对象</li><li>将若干raft对象进行连接</li></ul></li><li>插入检查，宕机，sleep等操作</li><li>end</li></ul></li><li>第一个测试TestInitialElection2A首先是初始化整个系统，设置了3个raft对象，不进行fail操作，中间sleep一段时间检查你的系统是否稳定（即没有发生宕机的情况下你的leader是否可以稳定的一直发送心跳）</li><li>第二个测试TestReElection2A会在中间加入节点的disconnect，后续重新connect，考验设计系统的鲁棒性</li></ul><h3 id="设计概述">设计概述</h3><blockquote><p>实验大部分思路来自于<a href="https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/">https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/</a> and <a href="https://zhuanlan.zhihu.com/p/543989771">https://zhuanlan.zhihu.com/p/543989771</a>，在此基础上进行修改，十分感谢！</p></blockquote><h4 id="结构说明">结构说明</h4><ul><li>每个raft通过Make函数来构建起单个的raft系统<ul><li>在Make中对raft中的参数进行初始化</li><li>实验要求Make立即返回，因此整个系统的运行应该放在一个goroutine中，这里设计了Schedule函数进行调度</li></ul></li><li>利用Schedule函数进行状态的变换（ follower&lt;-&gt;candidate&lt;-&gt;leader ）<ul><li>followerTick()<ul><li>follower在2a中考虑三种情况<ul><li>收到来自leader的心跳，继续follower状态</li><li>自己给其他candiadte投票，继续follower状态</li><li>超时，既没有收到心跳，也没有给别人投票，自己变为candidate状态</li></ul></li></ul></li><li>candidateTick()<ul><li>candidate需要考虑四种情况<ul><li>收到来自leader的心跳，切换到follower状态</li><li>自己给其他candiadte投票，切换到follower状态</li><li>自己赢得选举，切换到leader状态</li><li>选举超时，继续下一轮选举，保持candidate状态</li></ul></li></ul></li><li>leaderTick()<ul><li>leader需要考虑四种情况<ul><li>收到来自leader的心跳，切换到follower状态</li><li>自己给其他candiadte投票，切换到follower状态</li><li>收到的心跳reply中有大于自己term（任期），切换到follower状态</li><li>心跳计时到期，保持leader状态，开始下一轮心跳发送</li></ul></li></ul></li></ul></li><li>RPC相关（对应操作用颜色标注，红色表示心跳RPC，绿色表示投票RPC）<ul><li>心跳RPC  AppendEntries<ul><li>根据args更新自身raft对象中的参数并返回reply</li></ul></li><li>投票RPC  RequestVote<ul><li>根据args更新自身raft对象中的参数并返回reply</li></ul></li></ul></li></ul><h4 id="架构图">架构图</h4><p><img src="/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/structure.png" alt="structure" title="structure"></p><h3 id="具体实现">具体实现</h3><h4 id="Definition">Definition</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower  = <span class="number">0</span></span><br><span class="line">Candidate = <span class="number">1</span></span><br><span class="line">Leader    = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// heart_beat</span></span><br><span class="line"><span class="keyword">type</span> AppendEntryArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span></span><br><span class="line">LeaderId     <span class="type">int</span></span><br><span class="line">PrevLogIndex <span class="type">int</span></span><br><span class="line">PrevLogTerm  <span class="type">int</span></span><br><span class="line">Entries      []LogEntry</span><br><span class="line">LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AppendEntryReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="type">int</span></span><br><span class="line">Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">ItemId <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的LogEntry在2A中暂时不用，其余定义按照paper编写即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    state <span class="type">int</span> <span class="comment">//当前的状态</span></span><br><span class="line">    electionTimeout *time.Timer <span class="comment">//选举时间定时器</span></span><br><span class="line"></span><br><span class="line">    currentTerm <span class="type">int</span>        <span class="comment">//当前的任期号</span></span><br><span class="line">    voteFor     <span class="type">int</span>        <span class="comment">//当前获得选票的候选人id</span></span><br><span class="line">    logEntries  []LogEntry <span class="comment">//日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</span></span><br><span class="line"></span><br><span class="line">    appendCh <span class="keyword">chan</span> *AppendEntryArgs <span class="comment">//leader发送的心跳</span></span><br><span class="line">    voteCh   <span class="keyword">chan</span> *RequestVoteArgs <span class="comment">//candidate发送的投票</span></span><br><span class="line">    l2fCh    <span class="keyword">chan</span> <span class="type">bool</span>             <span class="comment">//leader心跳收到比自己大的term，变为follower</span></span><br><span class="line"></span><br><span class="line">    heartBeatTimeOut <span class="type">int</span> <span class="comment">//1秒10次心跳</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>appendCh表示自己成功接收到来自于leader的心跳，在心跳RPC中处理</li><li>voteCh表示自己成功给某个candidate投票，在投票RPC中处理</li><li>l2fCh表示leader收到心跳回复中有比自己大的term</li><li>通过electionTimeout来控制选举超时的时间（定义为450-550ms）</li><li>heartBeatTimeOut设置为100ms</li></ul><h4 id="Schedule">Schedule</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Schedule() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">switch</span> rf.state &#123;</span><br><span class="line">        <span class="keyword">case</span> Leader:</span><br><span class="line">            rf.leaderTick()</span><br><span class="line">        <span class="keyword">case</span> Candidate:</span><br><span class="line">            rf.candidateTick()</span><br><span class="line">        <span class="keyword">case</span> Follower:</span><br><span class="line">            rf.followerTick()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据rf当前的状态执行对应的Tick即可。</li></ul><h4 id="AppendEntries-Heart-beat-RPC">AppendEntries(Heart_beat) RPC</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heart_beat from leader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntryArgs, reply *AppendEntryReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.voteFor = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    reply.Success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(args *AppendEntryArgs)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> rf.appendCh &lt;- args:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            &lt;-rf.appendCh</span><br><span class="line">            rf.appendCh &lt;- args</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收来自于leader的heart_beat args，如果leader的任期比自己小，则赋值reply后直接返回，不向appendCh中发送数据，表示自己没有接收到心跳，自己自动通过timeOut转变为candidate</li><li>leader任期大于等于自己，则更新自己的相关成员，向appendCh中发送数据表示接受到心跳</li><li>接收心跳后根据appendCh进行状态的转换（在follower，candidate，leader中处理）</li></ul><h4 id="Request-vote-RPC">Request_vote RPC</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rf.voteFor != <span class="number">-1</span> &amp;&amp; rf.voteFor != args.CandidateId &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//票还没投过，可以投</span></span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">    rf.voteFor = args.CandidateId</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">    <span class="comment">//same as heartbeat...</span></span><br><span class="line">    &#125;(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果请求投票的candidate的任期比自己小，则不给他投票</li><li>如果任期比自己大，给他投票</li><li>如果之前投过票了就不能再投票</li><li>投票之后向voteCh发送数据表示自己已经投过票了，根据该信息转换自己当前的状态（在follower，candidate，leader中处理）</li></ul><h4 id="Follower">Follower</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerTick() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rf.resetTimeout()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> args := &lt;-rf.appendCh:</span><br><span class="line">            <span class="comment">//收到了来自于leader的心跳，继续follower</span></span><br><span class="line">        <span class="keyword">case</span> args := &lt;-rf.voteCh:</span><br><span class="line">            <span class="comment">//自己投票给了其他candidate，继续follower</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.electionTimeout.C:</span><br><span class="line">            <span class="comment">//超时没收到心跳，变为candidate</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据channel中的信息进行自身成员的更新和状态转换即可。</li></ul><h4 id="Candidate">Candidate</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> candidateTick() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.voteFor = rf.me</span><br><span class="line">    rf.currentTerm++</span><br><span class="line">    currentTerm := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    args := &amp;RequestVoteArgs&#123;</span><br><span class="line">        Term:        currentTerm,</span><br><span class="line">        CandidateId: rf.me,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    voteCnt := <span class="number">1</span></span><br><span class="line">    voteNote := <span class="literal">false</span></span><br><span class="line">    voteWin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">    voteLock := sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选举超时统计</span></span><br><span class="line">    rf.resetTimeout()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> ok := rf.sendRequestVote(i, args, reply); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">                    voteLock.Lock()</span><br><span class="line">                    voteCnt++</span><br><span class="line">                    <span class="keyword">if</span> !voteNote &amp;&amp; voteCnt &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                        voteNote = <span class="literal">true</span></span><br><span class="line">                        voteLock.Unlock()</span><br><span class="line">                        voteWin &lt;- <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        voteLock.Unlock()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换状态，简单的修改state即可</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.appendCh:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.voteCh:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-voteWin:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.electionTimeout.C:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进行candidateTick，首先根据论文所述，进入candidate状态先将自身的currentTerm+1，然后向其余的节点发送请求投票的RPC，收集到超过一半的选票后变为leader</li><li>如果在此期间收到了心跳或者自己给其他candidate投票，则关闭其给其他节点发送的请求投票的RPC并将状态变为follower</li><li>如果选举超时，那么开启新一轮选举</li><li>注意需要将rf.currentTerm提前保存下来，保证发送给其他节点的Term是开始时的Term，否则直接调用rf.currentTerm可能导致发送给其他节点的Term并不相等。</li></ul><h4 id="Leader">Leader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderTick() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    currentTerm := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            args := &amp;AppendEntryArgs&#123;</span><br><span class="line">                Term:     currentTerm,</span><br><span class="line">                LeaderId: rf.me,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, currentT <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                reply := &amp;AppendEntryReply&#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> ok := rf.sendAppendVote(i, args, reply); ok &#123;</span><br><span class="line">                    rf.mu.Lock()</span><br><span class="line">                    <span class="keyword">if</span> rf.currentTerm != currentT &#123;</span><br><span class="line">                        rf.mu.Unlock()</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    rf.mu.Unlock()</span><br><span class="line">                    <span class="keyword">if</span> reply.Success &#123;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rf.mu.Lock()</span><br><span class="line">                        <span class="keyword">if</span> reply.Term &gt; currentT &#123;</span><br><span class="line">                            rf.currentTerm = reply.Term</span><br><span class="line">                            rf.mu.Unlock()</span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                            <span class="keyword">case</span> rf.l2fCh &lt;- <span class="literal">true</span>:</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                &lt;-rf.l2fCh</span><br><span class="line">                                rf.l2fCh &lt;- <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            rf.mu.Unlock()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i, currentTerm)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Duration(rf.heartBeatTimeOut) * time.Millisecond):</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.appendCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.voteCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.l2fCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意leader在执行的过程中用一个for循环包裹，heart_beat每隔一段时间就进行发送，在本文中采用的是time.After，实验手册中建议直接使用time.Sleep</li><li>leader在每次for循环中向其余的节点发送心跳RPC，并根据reply判断是否放弃leader身份</li><li>如果计时器结束，说明一切正常，继续下一轮的心跳发送</li><li>如果收到了其他节点的心跳，说明其他节点成为了leader，自己需要放弃leader身份</li><li>如果给其他节点投票，说明其他节点的Term比自己新，自己需要放弃leader身份</li><li>如果其他节点心跳的reply中Term比自己新，自己需要放弃leader身份</li></ul><h3 id="测试">测试</h3><p>编写脚本测试500次，全部通过。<br><img src="/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/test.png" alt="test" title="test"></p><h3 id="注意">注意</h3><ul><li>实验过程中可以利用util中的DPrintf打印相关信息，方便debug</li><li>重点在于分析清楚各个goroutines的生命周期</li><li>不要忘记实现GetState()和Kill()，不在Kill中对节点处理的话可能会导致断连的节点依旧打印信息</li><li>使用go test -race检测代码中潜在的race问题</li><li>可能造成bug的原因<ul><li>第一个test报错warning: term changed even though there were no failures原因是系统会通过checkTerms来检查当前的Term（任期号），在两次checkTerms中加入sleep，这期间你的系统是保持稳定的，即选举成功后没有发生任何crash或disconnect，leader一直持续的向其他节点发送心跳，因此两次checkTerms的Term应该不变，报错的原因就是你的两次Term发生了变化，说明系统不稳定，即使没有bug但是leader还是在更换</li><li>第二个test中断连一个leader后又把他重新加入网络，可能会导致两个leader</li><li>注意goroutines传入参数的设置，避免直接使用外部数据，通过参数传递使用你需要的数据，直接使用外部数据，数据可能会发生变化</li><li>在sendRPC返回ok的过程中可能会失败（disconnect），这类的RPC返回的非常慢（经过测试大于700ms，以秒为量级），注意这些goroutines</li></ul></li><li>建议编写自己的test script进行程序的测试，因为只跑少量的testcase无法检测出概率小的bug</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;后续实验对此部分代码进行了重构，因此代码不具备参考性，仅适用于本次实验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 2020 Lab1 MapReduce</title>
    <link href="https://penpenf28.github.io/2023/07/10/MIT6-824-2020-Lab1-MapReduce/"/>
    <id>https://penpenf28.github.io/2023/07/10/MIT6-824-2020-Lab1-MapReduce/</id>
    <published>2023-07-10T10:13:53.000Z</published>
    <updated>2023-10-10T06:36:39.997Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html%5D">Lab 1</a>实验要求并熟悉基础代码，了解Go中的RPC通信。<br>Lab环境的配置过程中可能会出现若干问题，参照<a href="%5Bhttps://juejin.cn/post/7018756637330685988%5D(https://juejin.cn/post/7018756637330685988)">此处</a>解决。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="实验说明">实验说明</h3><ul><li>完成分布式MapReduce系统设计，实现词频统计</li><li>Worker分别调用Map和Reduce Function来读取和处理文件</li><li>Master用来调度和处理失败的Worker</li><li>主要修改src/mr文件夹中的master.go rpc.go worker.go</li><li>Lab中是所有Map任务完成后才进行Reduce任务</li><li>Worker和Master之间利用RPC进行通信</li></ul><h3 id="设计概述">设计概述</h3><blockquote><p>大部分思路来自于<a href="https://github.com/yzongyue/6.824-golabs-2020">https://github.com/yzongyue/6.824-golabs-2020</a>，在此基础上进行修改，十分感谢！</p></blockquote><h4 id="结构说明">结构说明</h4><ul><li>调用mrmaster.go启动Master，监听是否有人向自身发送RPC请求。</li><li>调用mrworker.go启动Worker，首先询问Master是否已经分配了全部任务，如果分配完成了就不新建Worker，直接退出，如果未完成，则新建Worker分担任务。<ul><li>此处询问是否分配完成设计是由测试脚本引发的设计，crash.go中在master分配全部任务之后会继续新建Worker向master请求，如果不进行相关设计会warning，但是不影响正确结果</li></ul></li><li>Worker首先通过RPC通信向Master注册自身，再通过RPC通信向Master请求任务，执行任务，最后通过RPC向Master报告任务完成，此处共需要设计三种RPC请求回答格式。</li></ul><h4 id="架构图">架构图</h4><h5 id="master">master</h5><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/master.png" alt="master" title="master"></p><h5 id="worker">worker</h5><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/worker.png" alt="worker" title="worker"></p><h4 id="数据流图">数据流图</h4><p>以nMap = n，nReduce=3为例，其中中间文件的数量为nMap*nReduce=3n个。<br><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/dataflow.png" alt="dataflow" title="dataflow"></p><h3 id="具体实现">具体实现</h3><h4 id="Master">Master</h4><p>Master的作用就是统筹Worker，分配任务，因此需要为任务构建一个结构体，使用RPC在Master和Worker之间传输，定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskPhase <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MapPhase    TaskPhase = <span class="number">0</span></span><br><span class="line">ReducePhase TaskPhase = <span class="number">1</span></span><br><span class="line">WaitPhase   TaskPhase = <span class="number">2</span></span><br><span class="line">ExitPhase   TaskPhase = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">FileName <span class="type">string</span></span><br><span class="line">NMap     <span class="type">int</span></span><br><span class="line">NReduce  <span class="type">int</span></span><br><span class="line">ID       <span class="type">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NMap变量由文件数决定，由于在Map阶段需要生成中间文件mr-MapID-BucketID，此处的NMap用作后面Reduce阶段遍历相关中间文件。<br>Phase变量有4个取值，分别代表当前系统是在哪个任务阶段（可能TaskPhase会造成误解），其中Wait阶段是Worker向Master发出请求，但是Master现在并没有任务发送给他，Worker需要等待，Exit阶段表示当前需要退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// used in TaskStat</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TaskReady   TaskStatus = <span class="number">0</span></span><br><span class="line">TaskQueue   TaskStatus = <span class="number">1</span></span><br><span class="line">TaskRunning TaskStatus = <span class="number">2</span></span><br><span class="line">TaskDone    TaskStatus = <span class="number">3</span></span><br><span class="line">TaskError   TaskStatus = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskStat <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID  <span class="type">int</span></span><br><span class="line">Status    TaskStatus</span><br><span class="line">StartTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">files   []<span class="type">string</span></span><br><span class="line">NReduce <span class="type">int</span></span><br><span class="line"></span><br><span class="line">mu           sync.Mutex</span><br><span class="line">NowWorkers   <span class="type">int</span></span><br><span class="line">TotalWorkers <span class="type">int</span></span><br><span class="line">ExitWorkers  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">Tstate []TaskStat</span><br><span class="line">Phase  TaskPhase</span><br><span class="line"></span><br><span class="line">TaskCh <span class="keyword">chan</span> Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化过程中可以确定好files和NReduce，files是所需要处理的文件集合，NReduce是生成最后文件的数量，可以理解为桶的数量。<br>NowWorker为当前分配WorkerID的指针，每次有一个Worker发来一个注册RPC，为其分配一个WorkerID，然后NowWorker自增，TotalWorker自增。<br>TotalWorker为当前Master中存活的Worker，因为后续test脚本中有crash测试，因此当一个worker失联超过设置的时间后判定为crash，TotalWorker自减。<br>ExitWorker为当前Master中正常退出的Worker，当Worker发送退出RPC时（为了简化设计，将退出RPC和通知Master任务完成的RPC进行设计合并），ExitWorker自增。<br>如何判断当前任务全部完成，Master可以退出了( Done )？</p><ul><li>判断TotalWorkers和ExitWorkers是否相等即可。</li></ul><p>TState是Master中较为关键的成员，通过Init函数进行设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitMap() &#123;</span><br><span class="line">m.Phase = MapPhase</span><br><span class="line">m.Tstate = <span class="built_in">make</span>([]TaskStat, <span class="built_in">len</span>(m.files))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitReduce() &#123;</span><br><span class="line">m.Phase = ReducePhase</span><br><span class="line">m.Tstate = <span class="built_in">make</span>([]TaskStat, m.NReduce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TState的长度等于当前需要处理的Task的数量，TState[i]的含义就是第i个task当前的状态，包括分配给的WorkerID，状态以及开始执行的时间。TaskCh是一段有buffer的channel，用作Goroutines之间的数据传输，后续解释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitMap() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitReduce() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RPC通信，用于注册和退出Worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RegisterWorker(args *RegisterArgs, reply *RegisterReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> ExitWorker(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当一个worker申请一个Task时，register该Task的TaskState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RegisterTask(args *RequestArgs, task *Task) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过TaskID新建需要完成的Task并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> GetTask(NowTaskID <span class="type">int</span>) Task &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Schedule() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> TickSchedule() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RPC通信，用于Worker获取Task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> GetOneTask(args *RequestArgs, reply *RequestReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="comment">//RPC通信，用于Master接受Worker发送过来的信息，更新对应的TState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> ReportTask_m(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="comment">//RPC通信，用于Worker创建前询问Master是否完成全部的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> IsAllDone(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Master &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"></span><br><span class="line">m.mu = sync.Mutex&#123;&#125;</span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.files = files</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nReduce &gt; <span class="built_in">len</span>(files) &#123;</span><br><span class="line">m.TaskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, nReduce)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.TaskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="built_in">len</span>(files))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.InitMap()</span><br><span class="line"><span class="keyword">go</span> m.TickSchedule()</span><br><span class="line"></span><br><span class="line">m.server()</span><br><span class="line"><span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用MakeMaster新建一个Master，并构建一个有buffer的TaskChannel，用作存放需要发送给Worker的Task。</li><li>接着初始化Map，设置一下相关的参数</li><li>TickSchedule开始周期性调度全部任务，该函数主要实现是利用for循环，在不是ExitPhase的情况下周期性调用Schedule</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Schedule() &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.Phase == ExitPhase &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.Phase == WaitPhase &#123;</span><br><span class="line"><span class="keyword">if</span> m.ExitWorkers == m.TotalWorkers &#123;</span><br><span class="line">m.Phase = ExitPhase</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AllDone := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> m.Tstate &#123;</span><br><span class="line"><span class="keyword">switch</span> task.Status &#123;</span><br><span class="line"><span class="keyword">case</span> TaskReady:</span><br><span class="line">            AllDone = <span class="literal">false</span></span><br><span class="line">m.TaskCh &lt;- m.GetTask(idx)</span><br><span class="line">m.Tstate[idx].Status = TaskQueue</span><br><span class="line"><span class="keyword">case</span> TaskQueue:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">case</span> TaskRunning:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">            <span class="comment">// deal with crash</span></span><br><span class="line"><span class="keyword">case</span> TaskDone:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">case</span> TaskError:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> AllDone &#123;</span><br><span class="line"><span class="keyword">if</span> m.Phase == MapPhase &#123;</span><br><span class="line">m.InitReduce()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.Phase = WaitPhase</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">            <span class="comment">// fake task...</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Schedule的大体框架如上，首先Master在调度之前判断一下自身的状态，wait状态是Master已经调度完全部任务了，向所有还存活的Worker发送一个伪任务，告诉他们可以退出了，其余还存活的Worker一直在不停的接受任务，这时收到Master发送过来的fake task后，向Master发送已退出的消息然后退出，Master接收到全部退出消息后，将Phase改为ExitPhase然后退出。<br>中间的for循环遍历TaskState，将准备好的任务发送到TaskChannel，来让Worker接收。</p><h4 id="Worker">Worker</h4><p>首先定义worker结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">workerID <span class="type">int</span></span><br><span class="line">mapf     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue</span><br><span class="line">reducef  <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker的构建主要是通过Worker function</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">w := worker&#123;</span><br><span class="line">mapf:    mapf,</span><br><span class="line">reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := ReportArgs&#123;&#125;</span><br><span class="line">reply := ReportReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">call(<span class="string">&quot;Master.IsAllDone&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> reply.AllFinished &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;all done, no more client\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.Register()</span><br><span class="line">w.run()</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker %d exit normally\n&quot;</span>, w.workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断一下Master是否分配完了全部的工作，否则就进行worker的注册和执行，Register主要通过RPC通信来和Master通信获取可用的workerID，run用来执行构建好的worker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">task := w.RequestTask()</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker %d get task %d, TaskPhase==%d\n&quot;</span>, w.workerID, task.ID, task.Phase)</span><br><span class="line"><span class="keyword">if</span> task.Phase == ExitPhase &#123;</span><br><span class="line">w.Exit()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.Phase == WaitPhase &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">w.doTask(task)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以开多个窗口同时跑多个worker，下面的延时防止worker执行太快，</span></span><br><span class="line">        <span class="comment">// 其他worker来不及执行</span></span><br><span class="line"><span class="comment">// time.Sleep(3 * time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run函数是worker中需要重点关注的函数，内部使用一个for循环来不断请求Master获得空闲的Task，此处的RequestTask也是通过RPC通信进行数据的获取。</p><ul><li>如果当前task处于ExitPhase，则调用Exit向Master进行RPC通信，告诉Master此Worker已退出。</li><li>如果当前task处于WaitPhase，说明当前Master无任务分配，让Worker睡眠一段时间后重新请求。</li></ul><p>如果当前任务可执行，则调用doTask进行任务的执行，doTask流程如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doTask(task Task) &#123;</span><br><span class="line"><span class="keyword">switch</span> task.Phase &#123;</span><br><span class="line"><span class="keyword">case</span> MapPhase:</span><br><span class="line">w.doMap(task)</span><br><span class="line"><span class="keyword">case</span> ReducePhase:</span><br><span class="line">w.doReduce(task)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;wrong phase&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RPC设计">RPC设计</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisterArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RegisterReply <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Task_ *Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Done     <span class="type">bool</span></span><br><span class="line">TaskID   <span class="type">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReportReply <span class="keyword">struct</span> &#123;</span><br><span class="line">AllFinished <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Register RPC，不需要worker传递参数给master，只需要master把当前可用的workerID 回复给worker即可。<br>对于Request RPC，worker需要传递给master自己的workerID，让master可以更新自己对应的TState中的任务，明确该分配给了了哪个worker，并更新状态，master回复给worker对应的task即可。<br>对于Report RPC，合并了三种操作，一种是刚调用Worker时询问Master是否分配完了全部的任务，一种是完成一个Task后向Master汇报该任务已完成，最后一种是向Master汇报该worker已退出。</p><h4 id="doMap">doMap</h4><p>Master把收到的全部文件设置为一个个的Task，状态保存在TState中，每次每个worker调用doMap就从TaskCh中取出一个Task任务执行mapf（大概就是对一个具体的file做Map操作，返回的键值对仿照mrsequential.go暂时保存到kva中），遍历kva，利用ihash函数将kv.Key对应的Value哈希到对应的桶中（可以使用intermediate[]表示桶的集合，大小为nReduce）<br>最后遍历桶，将各个桶中的数据写入中间文件，中间文件的命名可以使用mr-mapID-bucketID，写入出错或者写入成功都需要向Master call RPC进行通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doMap(task Task) &#123;</span><br><span class="line"><span class="comment">// get filename and content</span></span><br><span class="line">kva := w.mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"></span><br><span class="line">intermediate := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">bucketID := ihash(kv.Key) % task.NReduce</span><br><span class="line">intermediate[bucketID] = <span class="built_in">append</span>(intermediate[bucketID], kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bucketID, kva := <span class="keyword">range</span> intermediate &#123;</span><br><span class="line">oname := Map2ReduceFileName(task.ID, bucketID)</span><br><span class="line">ofile, err := os.Create(oname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(ofile)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ofile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doReduce">doReduce</h4><p>一个具体的Reduce Task是将上面Map生成的中间全部文件mr-i-taskID( 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">\lt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> NMap )，集合并做reducef操作，保存到最终文件mr-out-taskID中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doReduce(task Task) &#123;</span><br><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span>; idx &lt; task.NMap; idx++ &#123;</span><br><span class="line">filename := Map2ReduceFileName(idx, task.ID)</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := maps[kv.Key]; !ok &#123;</span><br><span class="line">maps[kv.Key] = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">maps[kv.Key] = <span class="built_in">append</span>(maps[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> key, values := <span class="keyword">range</span> maps &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, fmt.Sprintf(<span class="string">&quot;%v %v\n&quot;</span>, key, w.reducef(key, values)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(MergeName(task.ID), []<span class="type">byte</span>(strings.Join(res, <span class="string">&quot;&quot;</span>)), <span class="number">0600</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTask_w(task, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/test.GIF" alt="test" title="test"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html%5D&quot;&gt;Lab 1&lt;/a&gt;实验要求并熟悉基础代码，了解Go中的RPC通信。&lt;br&gt;
Lab环境的配置过程中可能会出现若干问</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
