<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hongwen Xin&#39;s Blog</title>
  
  
  <link href="https://penpenf28.github.io/atom.xml" rel="self"/>
  
  <link href="https://penpenf28.github.io/"/>
  <updated>2023-10-16T12:59:19.444Z</updated>
  <id>https://penpenf28.github.io/</id>
  
  <author>
    <name>Hongwen Xin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图神经网络极简总结</title>
    <link href="https://penpenf28.github.io/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/"/>
    <id>https://penpenf28.github.io/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-16T12:41:42.000Z</published>
    <updated>2023-10-16T12:59:19.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文结构和内容主要参考自<a href="https://www.cnblogs.com/SivilTaram/">SivilTaram的博客</a>和<a href="https://chhzh123.github.io/blogs/2020-02-10-gnn/">chhzh123的博客</a>并加上自己的一些理解</p></blockquote><h1>图神经网络</h1><p>数据常常可以被分类为欧式数据和非欧式数据。<br>欧式数据通常是我们在日常生活中遇到的最常见的数据类型，例如图像、音频和文本数据，这些数据由简单的序列或网格组成，较为结构化。<br>非欧式数据不属于传统的固定维度向量空间。例如，社交网络、知识图谱、复杂的文件系统都是非欧式数据。这类数据的关键特点是它们之间的关系不能简单地通过欧氏距离来度量，是非结构化的。<br><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/1.png" alt="1" title="1"></p><p>非欧式数据促使了图神经网络（Graph Neural Network, GNN）的出现和发展，GNN中所处理的图一般情况下指的是图论中的图，由若干节点以及连接节点的边所构成的数据结构。</p><hr><p>输入：通常为一个Graph Network<br>输出：节点Label；新的Link；生成新图或者子图</p><p>对于图不同的任务</p><ul><li>节点层面</li><li>Edge(Link)层面 (推荐系统)</li><li>整图方面（分子分类），子图方面（导航）</li></ul><p>常见的任务</p><ul><li>节点分类</li><li>Link预测</li><li>图分类</li></ul><h2 id="原理">原理</h2><p>给定一组图数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>在图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>中都有一个关联的特征向量，初始化时，这些特征可以是节点的属性，标签或其他与节点相关的信息，将节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的特征表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">h_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>GNN的基本操作是通过消息传递(Message Passing)来更新节点表示，每个节点从其邻居接受信息，然后使用这些信息来更新自己的表示。<br>具体来说，每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">T_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>时刻接受从其邻居<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻产生的信息，并更新其特征表示为<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><msub><mi>T</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></msubsup><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mi>v</mi><msub><mi>T</mi><mi>i</mi></msub></msubsup><mo separator="true">,</mo><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><msub><mi>T</mi><mi>i</mi></msub></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h^{T_{i+1}}_v = Combine(h^{T_i}_v, Aggregate(h^{T_i}_{N(v)}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4384em;vertical-align:-0.5152em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">mbin</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9232em;"><span style="top:-2.3598em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5152em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><msub><mi>T</mi><mi>i</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">h^{T_i}_{N(v)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4384em;vertical-align:-0.5152em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9232em;"><span style="top:-2.3598em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5152em;"><span></span></span></span></span></span></span></span></span></span>是节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻的所有邻居特征表示</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Aggregate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span>是聚集函数，用于将所有邻居特征聚合为一个单一的向量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Combine</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">mbin</span><span class="mord mathnormal">e</span></span></span></span>是组合(or Update)函数，用于将聚合后的邻居特征与自身特征结合在一起</li><li>每一个时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>共享权重</li></ul><p>有了上面公式之后，可以通过迭代消息传递层(GNN Layer)来增加模型的深度，每个节点特征可以通过多跳邻居进行更新，在某种程度上GNN和RNN较为相似。</p><h1>图卷积</h1><p><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/2.png" alt="2" title="2"><br>图片来自<a href="https://www.cnblogs.com/SivilTaram/">SivilTaram的博客</a></p><ul><li>将图片中的每一个像素点视为一个节点可以表示为左图，一个普通的图结构可以表示为右图</li><li>左侧是一个传统卷积核，右侧是一个图卷积核</li><li>可以观察到以左图为代表的欧式空间中，邻居的节点数量都是固定的，但是在右图这种非欧式结构中，节点的邻居数量并不固定，因此传统的卷积核无法适用到图结构中</li></ul><p>如何解决邻居节点数量不固定的问题？</p><ul><li>将非欧式空间的图转换为欧式空间</li><li>找出方法使得卷积核可以从变长邻居节点中抽取特征</li></ul><h2 id="图卷积框架">图卷积框架</h2><p><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/3.png" alt="3" title="3"><br>图片来自<a href="https://www.cnblogs.com/SivilTaram/">SivilTaram的博客</a></p><ul><li>输入为一张Graph Network</li><li>在每层Convolution Layer中，对每个节点的邻居进行卷积操作(Aggregate)，使用卷积结果更新节点，再经过激活函数如Relu作为输出</li><li>以上述操作为一个基本单元，进行Layer的叠加</li><li>将最后的输出转换为需求任务进行处理(比如节点分类或者图分类)</li></ul><p>GCN对比GNN</p><ul><li>GCN与GNN的根本不同在于，GCN是多层堆叠，每一层的参数是不同的，而GNN是迭代求解，每一层的参数是共享的，GNN与RNN结构上比较相似。</li></ul><p>空域卷积和频域卷积是图卷积网络中两种主要的卷积方法，下面分别介绍这两种方法。</p><h2 id="空域卷积-Spatial-Convolution">空域卷积(Spatial Convolution)</h2><p>基本思想</p><ul><li>直接在图上进行卷积，模拟传统CNN中的卷积</li></ul><p>工作方式</p><ul><li>使用节点的邻居信息，例如节点特征的新值可以是自身特征和邻居特征的加权组合</li></ul><h3 id="消息传递模型-Message-Passing-Model">消息传递模型(Message Passing Model)</h3><p>这里的消息传递模型和前述GNN中的消息传递为同一内容，这一模型将空域卷积分解为两个过程：消息传递与状态更新，针对GCN重新改写GNN中的消息传递公式：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mi>v</mi><mi>l</mi></msubsup><mo separator="true">,</mo><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msubsup><mi>h</mi><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mi>l</mi></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h^{l+1}_v = Combine(h^{l}_v, Aggregate(h^{l}_{N(v)}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-0.497em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">mbin</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.378em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.497em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></p><ul><li>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>代表图卷积的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层，上式的物理意义是收到来自第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层每个节点的信息后，根据这些信息来更新自身节点第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>层的状态</li><li>在GNN中是根据级联的时间来更新状态，共享参数，在GCN中则是根据级联的层来更新状态，每一层有自己的参数</li></ul><h3 id="图采样与聚合-Graph-Sample-and-Aggregate">图采样与聚合(Graph Sample and Aggregate)</h3><p>在消息传递模型下，卷积操作的对象是整张图的每个节点，意味着需要将所有的节点放入内存或者显存中才能进行卷积操作，对于实际场景下的大规模图，这种方式显然是不可行的。<br>GraphSAGE(SAmple &amp;&amp; aggreGatE)提出的动机就是来解决这个问题，从名字就可以看出来GraphSAGE所执行的操作，先采样(Sample)再聚合(Aggregate)。<br><img src="/2023/10/16/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%81%E7%AE%80%E6%80%BB%E7%BB%93/4.png" alt="4" title="4"><br>流程</p><ul><li>在图中随机采样若干个结点，结点数为传统任务中的batch_size。对于每个结点，随机选择固定数目的邻居结点(这里邻居不一定是一阶邻居，也可以是二阶邻居)构成进行卷积操作的图</li><li>将邻居节点信息通过Aggregate函数聚集起来更新刚才采样的节点</li><li>计算采样点的Loss，如果是无监督任务，期望图上邻居节点编码相似，如果是监督任务，根据具体节点任务标签计算损失</li></ul><p>细化GraphSAGE状态更新公式</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msup><mi>W</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mi>A</mi><mi>g</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mi>v</mi></msub><mo separator="true">,</mo><msubsup><mi>h</mi><mi>u</mi><mi>l</mi></msubsup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>n</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_ {v}^ {l+1}  =  \sigma  (  W^ {l+1} \cdot  Aggregate(  h_ {v}  ,{  h_ {u}^ {l}  }),  \forall  u  \in  ne[v])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∀</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">])</span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">W^ {l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>层的权重矩阵</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>层的激活函数</li><li>从上可以看出GraphSAGE的设计重点放在了Aggregate函数上，它可以是不带参数的max, mean, 也可以是带参数的如LSTM等神经网络。核心的原则是它需要可以处理变长的数据。</li></ul><h3 id="直推式学习和归纳式学习">直推式学习和归纳式学习</h3><p>上一小节的GraphSAGE引入了一个新的概念-归纳式学习(inductive learning)，即通过采样与聚合中心节点的邻居信息来生成节点embedding，这是可以适用于不同graph inputs的（结点或边可以后面再持续插入）；而传统的GNN算法是直推式学习(transductive learning)，即在训练节点embedding时需加载所有节点信息。</p><h2 id="频域卷积-Spectral-Convolution">频域卷积(Spectral Convolution)</h2><p>又称谱域卷积，在频域中，图卷积的主要思想是在图的傅里叶空间（或更确切地说，是图拉普拉斯算子的特征空间）中进行卷积。<br>原公式解释起来比较复杂，可以阅读<a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html">博客</a>进行理解，这里只介绍由<a href="https://arxiv.org/abs/1609.02907">论文</a>化简后的频率卷积计算，一个基本的频域卷积操作可以写为<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mover accent="true"><mi>A</mi><mo>~</mo></mover><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><msup><mi mathvariant="bold">H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{H}^{(l+1)}=\sigma\left(\tilde{D}^{-\frac12}\tilde{A}\tilde{D}^{-\frac12}\mathbf{H}^{(l)}\mathbf{W}^{(l)}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">h^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span> 表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的节点特征</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的可训练权重</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover><mo>=</mo><mi>A</mi><mo>+</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\tilde{A} = A + I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> 是邻接矩阵加单位矩阵，单位矩阵是为了加入自循环，这样每个节点也会考虑自己的特征</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>D</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>的度矩阵，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mover accent="true"><mi>A</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\tilde{D}_{ii}=\sum_{j}\tilde{A}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0702em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.356em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 是非线性激活函数，如Relu</li></ul><p>该公式可以在频域中捕获图上每个节点与其邻居的关系，并利用这些关系来更新节点特征，这种操作也可以多次迭代，每次迭代都会更深入的整合图的信息。<br>在一般的GCN中实现的就是频域卷积，常见的2层GCN模型代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;data/Cora&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>, transform=NormalizeFeatures())</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCN</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim, hidden_dim, output_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(GCN, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(input_dim, hidden_dim)</span><br><span class="line">        self.conv2 = GCNConv(hidden_dim, output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, data</span>):</span><br><span class="line">        x, edge_index = data.x, data.edge_index</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一层 GCN</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二层 GCN</span></span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型和优化器</span></span><br><span class="line">model = GCN(input_dim=dataset.num_features, hidden_dim=<span class="number">16</span>, output_dim=dataset.num_classes)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model = model.to(device)</span><br><span class="line">data = dataset[<span class="number">0</span>].to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(data)</span><br><span class="line">    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    out = model(data)</span><br><span class="line">    pred = out.argmax(dim=<span class="number">1</span>)</span><br><span class="line">    correct = pred[data.test_mask].eq(data.y[data.test_mask]).<span class="built_in">sum</span>().item()</span><br><span class="line">    <span class="keyword">return</span> correct / data.test_mask.<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主训练循环</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        test_acc = test()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>其他常见模型</h1><h2 id="GAT-Graph-Attention-Network">GAT(Graph Attention Network)</h2><p>回忆NLP中的Encoder-decoder模型，由于Encoder需要将一整个句子的信息压缩到一个高维空间向量，再送入Decoder进行解码，这一个高维空间向量的负担将会非常大，因此研究者就考虑让机器学会判断句子中的不同部分的重要性，从而在解码时更加有针对性地获取特征，此即Attention的思想。<br>将Attention概念引入到Graph中</p><ul><li>对于每个节点v_i，GAT首先计算该节点与其邻居节点v_j之间的注意力权重，并作归一化得到alpha_ij</li><li>使用注意力权重将邻居节点的表示进行加权平均，以更新节点表示<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>i</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><msub><mi mathvariant="script">N</mi><mi>i</mi></msub></mrow></msub><msub><mi>α</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>W</mi><msubsup><mi>h</mi><mi>j</mi><mi>l</mi></msubsup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">h_i^{l+1}=\sigma\left(\sum_{j\in\mathcal{N}_i}\alpha_{ij}Wh_j^{l}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1661em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8892em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.14736em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1474em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></li></ul></li></ul><p>通过上述流程，每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>能够聚合来自其邻居节点的信息，而注意力机制允许每个节点对其邻居节点的贡献有所不同，从而提高了模型的表示能力。</p><h1>参考资料</h1><ul><li><a href="https://arxiv.org/ftp/arxiv/papers/1812/1812.08434.pdf">清华综述</a></li><li><a href="https://distill.pub/2021/gnn-intro/">gnn-intro</a></li><li><a href="https://distill.pub/2021/understanding-gnns/">understanding-gnns</a></li><li><a href="https://theaisummer.com/graph-convolutional-networks/?continueFlag=5f444a0790b0bff0c474b56279b5924f">introduction to graph convolutions from scratch</a></li><li><a href="https://chhzh123.github.io/blogs/2020-02-10-gnn/#gcn">chhzh123的博客</a></li><li><a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_1.html#%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0">SivilTaram的博客1</a></li><li><a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html#%E9%A2%91%E5%9F%9F%E5%8D%B7%E7%A7%AFspectral-convolution">SivilTaram的博客2</a></li><li><a href="https://chat.openai.com/chat">ChatGPT</a></li><li><a href="https://paperswithcode.com/datasets?mod=graphs&amp;page=1">数据集</a></li><li><a href="https://paperswithcode.com/methods/category/graph-models">常见模型的实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文结构和内容主要参考自&lt;a href=&quot;https://www.cnblogs.com/SivilTaram/&quot;&gt;SivilTaram的博客&lt;/a&gt;和&lt;a href=&quot;https://chhzh123.github.io/blogs/2020-0</summary>
      
    
    
    
    <category term="Deep Learning" scheme="https://penpenf28.github.io/categories/Deep-Learning/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
    <category term="Graph Neural Network" scheme="https://penpenf28.github.io/tags/Graph-Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>Transformer简单笔记</title>
    <link href="https://penpenf28.github.io/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://penpenf28.github.io/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-14T16:07:12.000Z</published>
    <updated>2023-10-16T02:35:22.762Z</updated>
    
    <content type="html"><![CDATA[<p>主要来自于<a href="https://www.bilibili.com/video/BV1hs4y1a7c9?p=1&amp;vd_source=c3ee641e50e4973352c9085f2fd7974e">李宏毅老师的视频</a>，在此之上进行了重点信息的总结。</p><h1>Self-attention</h1><p>对于神经网络的输入，可能是一个vector或者一组vector，例如输入是一句话，可以将每个词处理后作为一组vector输入到网络中。<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/1.png" alt="1" title="1"></p><ul><li>上图是简单版本Self-attention的使用</li><li>有几个vector输入就有几个vector输出</li><li>Self-attention的输出考虑到了整个sequence</li></ul><hr><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/2.png" alt="2" title="2"><br>self-attention要做的事情简单来说，输入一组vector，根据vector之间的相关联程度，计算并输出一组output vector。</p><hr><p><strong>Self-attention输出的计算流程(以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">b^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>为例)</strong></p><ul><li>第一步，计算输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">a^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>和其他向量相关程度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">ha</span></span></span></span><ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/3.png" alt="3" title="3"></li><li>如何计算任意两两vector之间的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">ha</span></span></span></span><ul><li>常用方法如下，一般采用Dot-product</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/4.png" alt="4" title="4"></li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/5.png" alt="5" title="5"></li><li>以计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msubsup><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">alpha&#x27;_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1467em;vertical-align:-0.3948em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>为例，首先拿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">W^q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span>矩阵和输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">a^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>相乘获得中间矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">q^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></li><li>再拿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">W^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>矩阵分别和其他输入向量相乘获得中间矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">k^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">q^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">k^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>进行Dot-product获得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">alpha_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></li><li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">alpha_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>通过Softmax获得最后的相关性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msubsup><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">alpha&#x27;_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1467em;vertical-align:-0.3948em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>输出</li><li>Note: 不是一定需要Softmax，可以替换其他方法</li></ul></li></ul></li><li>第二步，基于上面得到的attention scores来抽取sequence里面的重要信息<ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/6.png" alt="6" title="6"></li><li>将每个vector乘上wv矩阵得到中间矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">v^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li><li>使用先前计算的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msubsup><mi>a</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>i</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">alpha&#x27;_{1,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1467em;vertical-align:-0.3948em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">lp</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>乘上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">v^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>，最后累加得到最后的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">b^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></li><li>其余的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">b^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>计算方法类似</li></ul></li></ul><hr><p>从矩阵角度来进行操作<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/7.png" alt="7" title="7"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/8.png" alt="8" title="8"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/9.png" alt="9" title="9"></p><p>简化版<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/10.png" alt="10" title="10"></p><ul><li>只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">W^q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">W^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">W^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span>需要学习</li></ul><hr><p>Attention和Self-attention的<a href="https://luweikxy.gitbook.io/machine-learning-notes/self-attention-and-transformer#selfattention-ji-zhi">区别</a>？</p><ul><li><p>以Encoder-Decoder框架为例，输入Source和输出Target内容是不一样的，比如对于英-中机器翻译来说，Source是英文句子，Target是对应的翻译出的中文句子，Attention发生在Target的元素Query和Source中的所有元素之间。</p></li><li><p>Self-attention，指的不是Target和Source之间的Attention机制，而是Source内部元素之间或者Target内部元素之间发生的Attention机制，也可以理解为Target=Source这种特殊情况下的Attention。</p></li><li><p>两者具体计算过程是一样的，只是计算对象发生了变化。</p></li></ul><h1>Multi-head Self-attention</h1><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/11.png" alt="11" title="11"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/12.png" alt="12" title="12"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/13.png" alt="13" title="13"></p><p>为什么需要Multi-head Attention？</p><ul><li>可以让Attention有更丰富的层次。有多个QKV的话，可以分别从多个不同角度来看待Attention。这样的话，输入a，对于不同的multi-headed Attention，就会产生不同的b</li><li>从<a href="https://luweikxy.gitbook.io/machine-learning-notes/self-attention-and-transformer#selfattention-ji-zhi">直觉上理解</a>为什么需要multi-headed Attention<ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/multi.png" alt="multi" title="multi"></li><li>首先观察上面左图，每个单词对应八个attention，八个attention分别用蓝色到灰色表示，首先确定一个单词it，可以从左图中看到其他单词与it的相关性</li><li>提取出橙色和绿色的色块，可以看到单词it对应橙色色块最深的是animal，绿色色块最深的是tire，橙色的注意力主要表明it是个什么东西，从东西的角度说明它是一种动物，而不是苹果或者香蕉。如果我们从状态这个层面来看，it这个动物现在是在怎么样的一个状态，它的状态是tired，而不是兴奋。所以不同的Self-Attention Head是不同方面的理解。</li></ul></li></ul><h1>Positional Encoding</h1><p>通过前面的内容可以发现，Self-attention缺少了非常重要的位置信息。<br>处理方法</p><ul><li>为每一个位置设定一个位置vector ei，每一个不同位置都有自己的一个位置vector</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/14.png" alt="14" title="14"></li><li>ei如何设定？<ul><li>hand-crafted</li><li>learn from data</li><li>尚待研究</li></ul></li></ul><h1>Transformer</h1><p>transformer本质上是一个Sequence-to-sequence(Seq2seq) model，即输入一个sequence，输出一个sequence，输出长度由model自己决定。<br>应用场景</p><ul><li>语音识别</li><li>机器翻译</li><li>语音翻译</li><li>Chatbot</li></ul><h2 id="Seq2seq-Model">Seq2seq Model</h2><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/15.png" alt="15" title="15"></p><p>Seq2seq model主要有Encoder和Decoder构成。</p><h3 id="Encoder">Encoder</h3><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/16.png" alt="16" title="16"></p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/17.png" alt="17" title="17"><br>黄色为输出的中间vector<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/18.png" alt="18" title="18"></p><ul><li>左边为第一步，将Self-attention的结果做residual处理，再经过一层layerNormalization，将输出作为右边第二步的输入</li><li>右边为第二步，将输入经过一次FC layer的结果继续做一次residual处理，再经过一层layerNormalization，最后再输出</li></ul><blockquote><p>思考：为什么需要用layerNormalization？阅读<a href="https://arxiv.org/abs/2003.07845">论文</a></p></blockquote><p>总览<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/19.png" alt="19" title="19"></p><ul><li>上述为原始论文的结构，该变layerNormalization的位置可能会有更好的结果</li><li>这里Input Embedding输入的三个箭头可以看做计算的Q,K,V矩阵</li></ul><h3 id="Decoder">Decoder</h3><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/20.png" alt="20" title="20"><br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/21.png" alt="21" title="21"></p><ul><li>在Encoder计算完成后，输入作为Decode的参数</li><li>开始时，输入为一个BEGIN vector，Decoder计算出初始输出</li><li>后续Decoder将自己的输出又作为输入继续计算</li><li>直到Decoder输出end标志为止</li></ul><hr><p>总览<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/22.png" alt="22" title="22"></p><hr><p>什么是Masked Multi-head Attention？</p><ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/23.png" alt="23" title="23"></li><li>可以看到在原来的Self-attention中，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">b^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>需要考虑到全部的输入vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">a^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>，但是decoder只能接受来自于自己前面序列的信息，因此变为下面的形态</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/24.png" alt="24" title="24"></li><li>具体计算的变化(以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">b^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>为例)<ul><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/25.png" alt="25" title="25"></li><li>可以看到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">b^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的计算不再需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">a^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">a^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>的参与</li></ul></li></ul><hr><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/26.png" alt="26" title="26"><br>Cross attention如何运行？<br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/27.png" alt="27" title="27"><br>可以看到encoder输出的两个箭头分别表示K, V矩阵，与Masked Sell-attention输出的Q矩阵进行对应操作得到中间变量进行输出。</p><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/28.png" alt="28" title="28"><br>在原始网络中，Decoder有许多Block，Encoder最后的输出需要分别发送到这些Block中，但是也有许多的变体。</p><hr><p>Autoregressive(AT) VS Non-autoregressive(NAT)</p><ul><li>AT是根据输入每次只产生一个输出vector</li><li>NAT不是一次只产生一个vector，而是一次将整个句子进行输出</li><li><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/29.png" alt="29" title="29"></li><li>如何确定NAT的输出长度？<ul><li>使用另外一个predictor进行预测</li><li>输出一个非常长的sequence，忽略掉第一个END之后的内容</li></ul></li><li>NAT的优点<ul><li>可并行性</li><li>可以控制输出的长度</li></ul></li><li>NAT通常比AT表现差(Multi-modality问题)</li></ul><h2 id="Training">Training</h2><p><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/30.png" alt="30" title="30"><br><img src="/2023/10/15/Transformer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/31.png" alt="31" title="31"></p><ul><li>Decoder每一次的输出，需要和Ground truth计算一次cross entropy，相当于做分类问题，我们需要最小化所有cross entropy的总和</li><li>每次的输入为标准答案，而不是上一次decoder的输出(Teacher Forcing)</li><li>问题: 训练过程中学习的是正确答案，但是test过程中不一定保证每一次的输出都是正确答案，如果输出错误答案，会大大影响后续的计算，如何合理解决？(exposure bias)<ul><li>训练过程中给decoder的输入增加一些错误项(Scheduled sampling)</li></ul></li></ul><h2 id="Others">Others</h2><ul><li>Beam search</li><li>BLEU score</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要来自于&lt;a href=&quot;https://www.bilibili.com/video/BV1hs4y1a7c9?p=1&amp;amp;vd_source=c3ee641e50e4973352c9085f2fd7974e&quot;&gt;李宏毅老师的视频&lt;/a&gt;，在此之上进行了重点信息的总结</summary>
      
    
    
    
    <category term="Deep Learning" scheme="https://penpenf28.github.io/categories/Deep-Learning/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
    <category term="Transformer" scheme="https://penpenf28.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Git常见命令&amp;&amp;流程</title>
    <link href="https://penpenf28.github.io/2023/10/13/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%A8%8B/"/>
    <id>https://penpenf28.github.io/2023/10/13/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%A8%8B/</id>
    <published>2023-10-13T02:13:23.000Z</published>
    <updated>2023-10-14T16:52:50.514Z</updated>
    
    <content type="html"><![CDATA[<p>个人自用</p><ul><li>git clone 仓库</li><li>git checkout -b my-feature<ul><li>切换到需要修改的分支</li></ul></li><li>修改代码</li><li>git diff<ul><li>查看当前修改后的代码与原来my-feature中的代码有哪些区别</li></ul></li><li>git add xxx<ul><li>将代码添加到暂存区</li></ul></li><li>git commit -m “xxx”<ul><li>[Feature]: New module or features.</li><li>[Bugfix]: Fix something.</li><li>[Refactor]: Style check.</li></ul></li><li>git push origin my-feature<ul><li>将本地my-feature分支推送到remote的my-feature分支，如果没有则自动创建</li></ul></li></ul><hr><ul><li>push完成后，准备合并branch到main中（这个过程是pull request， PR）</li><li>squash and merge</li><li>删除remote（主仓库）中的my-feature</li><li>git branch -D my-feature（一般不删除）<ul><li>删除local branch</li></ul></li><li>git pull origin master<ul><li>拉去主仓库中的最新更新</li></ul></li><li>结束</li></ul><hr><ul><li>如果remote main代码有更新</li><li>git checkout main</li><li>git pull origin master<ul><li>把远端的main同步到local的main中</li></ul></li><li>git checkout my-feature</li><li>git rebase main<ul><li>把my-feature暂时丢弃，将最新的main进行更新，然后再把添加my-feature的修改</li><li>有可能出现rebase conflict，手动选择你想要的代码</li><li>然后git rebase --continue</li></ul></li><li>进行完rebase后，git push -f origin my-feature<ul><li>由于进行了rebase，需要加上-f，表示force，强行push</li></ul></li></ul><hr><p>创建自己的新仓库然后更新代码</p><ul><li>首先安装git，添加ssh，配置git信息</li><li>使用<ul><li>git remote add origin <a href="https://github.com/repo_name/proj_name.git">https://github.com/repo_name/proj_name.git</a> 来关联远程仓库</li><li>如果之前关联过的</li><li>git remote set-url origin <a href="https://github.com/repo_name/proj_name.git">https://github.com/repo_name/proj_name.git</a></li><li>使用上面的重新关联</li></ul></li><li>push代码可能会出现无权限错误，用下面的token法解决<a href="https://blog.csdn.net/yjw123456/article/details/119696726">https://blog.csdn.net/yjw123456/article/details/119696726</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人自用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git clone 仓库&lt;/li&gt;
&lt;li&gt;git checkout -b my-feature
&lt;ul&gt;
&lt;li&gt;切换到需要修改的分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改代码&lt;/li&gt;
&lt;li&gt;git diff
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="Git" scheme="https://penpenf28.github.io/categories/Git/"/>
    
    
    <category term="Note" scheme="https://penpenf28.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab2-Raft-Part-2C&amp;&amp;2D</title>
    <link href="https://penpenf28.github.io/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/"/>
    <id>https://penpenf28.github.io/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/</id>
    <published>2023-10-12T13:04:05.000Z</published>
    <updated>2023-10-12T13:23:38.892Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html">Lab 2</a>Part 2C &amp;&amp; 2D相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="Part-2C">Part 2C</h3><h4 id="2C实验说明">2C实验说明</h4><ul><li>在raft每次更新重要信息后，对这些信息进行持久化保存</li><li>Test中某个server crash掉后，重新启动可以通过先前保存的持久化数据进行恢复</li></ul><h4 id="设计概述">设计概述</h4><p>在Part 2B实现的较为完备的情况下，Part 2C是比较简单的，只需要根据提示完成persist(), readPersist()函数，并在Make初始化过程中调用readPersist，关键信息更新时调用persist即可。<br>架构图可继续参考<a href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/">前文</a>。</p><h4 id="实现">实现</h4><p>根据论文中提供的信息，我们需要对term, votedFor, log进行持久化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save Raft&#x27;s persistent state to stable storage,</span></span><br><span class="line"><span class="comment">// where it can later be retrieved after a crash and restart.</span></span><br><span class="line"><span class="comment">// see paper&#x27;s Figure 2 for a description of what should be persistent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.term)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore previously persisted state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"><span class="keyword">var</span> term <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> log []*LogEntry</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;term) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;log) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;readPersist error&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.term = term</span><br><span class="line">rf.votedFor = votedFor</span><br><span class="line">rf.log = log</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要server中这些变量发生变化，调用persist()保存信息即可，在这里的持久化并不是保存到disk上，而是通过persist()类保存在内存中，Test中仅仅crash server，并没有crash掉server 对应的persister，以此实现信息的持久化，实际的工程中不会这么去做。</p><h4 id="注意">注意</h4><ul><li>注意<a href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/">前文</a>中的Figure 8问题，如果没有考虑完全会在2C中报错</li></ul><h3 id="Part-2D">Part 2D</h3><h4 id="2D实验说明">2D实验说明</h4><ul><li>raft server随着运行时间越来越长，保存的日志会越来越多，为了节约空间会做compaction(压缩)操作</li><li>压缩过程是将某一个状态之前的日志条目压缩为snapshot</li><li>当某个server落后于leader，且leader中该server的nextIndex所指示的log entry已经被leader压缩了，需要使用leader中的snapshot来更新server</li></ul><h4 id="设计概述-2">设计概述</h4><h5 id="snapshot设计">snapshot设计</h5><p><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/snapshot.png" alt="snapshot" title="snapshot"></p><ul><li>snapshot需要保存的信息<ul><li>LastIncludedIndex: Snapshot最后一个log entry的index，这个字段并不是real index，real index = LastIncludedIndex + logIndex，参考下图<ul><li><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/realIndex.png" alt="realIndex" title="realIndex"></li></ul></li><li>LastIncludedTerm: Snapshot最后一个log entry的term</li><li>MachineState(Data): Snapshot中机器的快照数据</li></ul></li><li>需要实现的函数<ul><li>Snapshot()</li><li>RPC相关，sendInstallSnapshot(), InstallSnapshot()<ul><li>当leader发现某个server nextIndex已经被压缩在快照中，没法通过正常的AppendEntriesRPC进行同步，需要编写相关的RPC使得leader向集群发送对该server安装leader Snapshot的请求，并传递相关的参数</li></ul></li><li>CondInstallSnapshot(), 由集群调用，对目标server安装Snapshot</li></ul></li></ul><h5 id="架构图">架构图</h5><p><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/structure.png" alt="structure" title="structure"></p><h5 id="整体流程">整体流程</h5><ul><li>如果当前server中log数据量超过存储极限，触发Snapshot(m.CommandIndex, w.Bytes())，触发过程发生在config.go中<ul><li>传入参数为m.CommandIndex, w.Bytes()<ul><li>m.CommandIndex 表示一直压缩到logIndex == m.CommandIndex的log entry为止</li><li>w.Bytes() 为传入的snapshot</li></ul></li></ul></li><li>如果当前leader在向其他follower复制日志(Replicate)的过程中发现某follower缺失log，且该follower对应nextIndex的log entry已经被leader压缩进snapshot中了，这时需要leader需要调用sendInstallSnapshot(), InstallSnapshot()来对该follower实现snapshot拷贝，然后该follower在下一个周期再进行正常的Replicate操作<ul><li>简单来说</li><li>leader发现某follower nextIndex对应的log缺失</li><li>发送包括LastIncludedIndex，LastIncludedTerm，Data等信息作为args的InstallSnapshotRPC</li><li>对应的follower收到InstallSnapshotRPC，根据传输过来的参数执行CondInstallSnapshot()，进行snapshot的安装</li></ul></li></ul><h4 id="实现-2">实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>)</span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>遍历自身的log，通过index找到对应的log entry，丢弃该log之前的全部log，并保存自身重要信息和snapshot</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallsnapshotArgs, reply *InstallsnapshotReply)</span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>判断args.Term是否小于rf.term<ul><li>小于说明leader失去时效性，解锁直接返回即可</li></ul></li><li>根据args更新自身term和state等相关信息，解锁</li><li>单独开一个协程向rf.applyCh发送installSnapshot的相关参数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">Snapshot:      args.Data,</span><br><span class="line">SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">CommandValid:  <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>判断lastIncludedIndex和rf.commitIndex<ul><li>小于，说明已经有更新的snapshot了，直接返回false</li></ul></li><li>判断lastIncludedIndex与rf.LogTail().Index的关系<ul><li>大于等于，只保留第一个空的占位log entry</li><li>小于保留lastIncludedIndex之后的log entry</li></ul></li><li>更新第一个占位log entry( rf.log[0] )的Index=lastIncludedIndex，Term=lastIncludedTerm，Command=nil</li><li>更新rf.commitIndex = lastIncludedIndex，rf.lastApplied = lastIncludedIndex</li><li>SaveStateAndSnapshot</li><li>return true</li></ul></li></ul><h4 id="测试">测试</h4><p>编写脚本测试500次，全部通过。<br><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/test.png" alt="test" title="test"><br>整个lab 2单次test用时约为5min40s。<br><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/time.png" alt="time" title="time"></p><h4 id="注意-2">注意</h4><ul><li>Snapshot()中直接对rf.log = rf.log[index:]进行日志丢弃是不合理的 ，go的切片机制导致截取slice时，不会创建新的数组，只是简单的改变了引用的范围，前面的内容不会被gc进行回收，可以通过append方法创建新的数组，确保之前的底层数组会被回收</li></ul><h3 id="参考内容-致谢">参考内容 &amp;&amp; 致谢</h3><ul><li><a href="https://space.bilibili.com/61981458">戌米的论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-locking.txt">raft-locking.txt</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-structure.txt">raft-structure.txt</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li><li><a href="https://zhuanlan.zhihu.com/p/543989771">十一的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/463144886">谭新宇的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/369989974">多颗糖的知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html&quot;&gt;Lab 2&lt;/a&gt;Part 2C &amp;amp;&amp;amp; 2D相关实验要求并熟悉基础代码。&lt;br&gt;
本文只提供相关实现思路，</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab2-Raft-Part-2B</title>
    <link href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/"/>
    <id>https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/</id>
    <published>2023-10-10T07:00:45.000Z</published>
    <updated>2023-10-12T13:24:48.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从本次lab改用了2021版本的实验，后续的内容更加丰富，并对lab 2a的代码进行了重构，放弃了leader candidate follower明确划分的模式</p></blockquote><p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html">Lab 2</a>Part 2B相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="2B实验说明">2B实验说明</h3><ul><li>实现leader和follower之间的log entries的插入和更新</li><li>保证leader和follower之间的log一致</li></ul><h3 id="Test分析">Test分析</h3><p>在test构建系统的过程中调用了Make函数，其中applyCh是raft向系统传送msg的通道，用来更新cfg中的各个raft中的logs信息，应用指令(apply)可以看做向applyCh中写入信息。<br>后续的test通过检查cfg中的log是否一致来判断编写的程序是否正确。</p><ul><li>cfg.nCommitted(index)返回两个参数，1多少个server认为编号为index的log entry被commited了，2被commited的命令</li><li>cfg.ones()在十秒内遍历全部的server，找到leader并Start（启动一个命令），返回该命令的log index，当前的term和是否是leader，然后检查在2s之内这个命令是否被成功提交给大多数server</li><li>rf.Start()的作用是启动新日志写入</li><li>cfg.crash1(i)直接kill掉对应的server</li><li>cfg.disconnect(i)将第i个server从集群系统中断开连接，但是server本身并没有被kill掉</li><li>在leader接收到超过半数的follower commit了对应的log，leader自身开始apply 对应的log，leader apply后通过心跳再提示follower apply对应的log，log一致性检查在cfg.applier中</li></ul><h3 id="设计概述">设计概述</h3><h4 id="架构图">架构图</h4><p><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/structure.png" alt="structure" title="structure"></p><h4 id="结构说明">结构说明</h4><ul><li>通过Make在初始化时创建四个后台协程（其实是3+n个，DoReplicate的数量取决于集群中server的数量）<ul><li>DoElection负责选举</li><li>DoHeartbeat负责心跳</li><li>DoApply负责向集群apply日志</li><li>DpReplicate负责leader与follower之间的日志同步</li></ul></li><li>日志同步的主要流程<ul><li>leader收到客户端指令后(Start)，将指令作为一个新条目（entry）追加到日志中<ul><li>一条LogEntry有三个参数：cmd-指令，term-指令的任期号，index-日志号。</li></ul></li><li>leader通过AppendEntries RPC并行的发送日志到follower，当有超过半数的follower回复后(commit)，leader就可以在本地执行该指令(apply)并把结果返回给客户端。</li><li>注意区别commit和apply，commit是指确定日志已经复制到半数节点，而apply是日志应用到状态机，因此可以理解为applyIndex&lt;=commitIndex</li></ul></li></ul><h4 id="分析">分析</h4><p>整个过程中follower可能会和leader无法保持一致如下图所示</p><ul><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/situation.png" alt="situation" title="situation"></li><li>三类原因以及解决方式<ul><li>follower由于某些延误没有给leader响应，leader会不断重发追加条目请求（AppendEntries RPC），哪怕leader已经回复了客户端（日志已经apply）</li><li>follower崩溃后恢复，这时Raft追加条目的一致性检查<ul><li>一致性检查：leader在每一个发往follower的追加条目RPC中，放入前一个日志条目的索引位置（prevLogIndex）和任期号（prevLogTerm），如果follower在他的日志中找不到前一个日志，follower会拒绝此日志，leader会重新再发送前一个日志，这样逐渐向前定位到follower第一个缺失的日志</li></ul></li><li>leader宕机，崩溃的leader可能复制了日志到部分follower，而新选择的leader可能不具备这些日志，这样导致部分follower中的日志和新leader的日志不相同<ul><li>Raft在这种情况下，leader会强制follower复制他的日志来解决不一致的问题</li><li>两者冲突的日志会被新的leader日志覆盖</li></ul></li></ul></li><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/RPC1.png" alt="RPC1" title="RPC1"></li><li>如果leaderCommit&gt;commitIndex，则commitIndex=min(leaderCommit, index of last new entry)</li></ul><p>安全性相关问题</p><ul><li>leader宕机：选举限制<ul><li>一个follower落后leader若干日志，但是没有遗漏整个任期</li><li>下次选举中，仍然有可能当选leader，当选新leader后永远无法补上之前缺失的那部分日志，造成状态机之间的不一致</li><li>增加一个限制，确保被选出来的leader一定包含之前各任期内所有被提交的日志条目</li><li>通过RequestVote RPC后俩参数<ul><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/RPC2.png" alt="RPC2" title="RPC2"></li><li>如果投票者自己的日志比candidate还新，他会拒绝掉该投票请求</li></ul></li><li>通过比较两份日志中最后一条日志条目的索引和任期号来定义谁的日志比较新</li><li>任期号不同，大的新</li><li>任期号相同，日志长的新</li></ul></li><li>leader宕机：新leader是否提交之前任期内的日志条目<ul><li>一旦当前任期内某个日志条目已经存储到过半服务器节点上，leader就知道当前日志可以被提交了</li><li>follower的提交如何被触发？raft中的提交为单点提交<ul><li>通过AppendEntries RPC中的leaderCommit 参数，表示leader提交到那个日志了，从而自己也可以应用提交到这个日志</li></ul></li><li>raft永远不会通过计算副本数目的方式来提交之前任期内的日志条目，只有自己任期内的日志才能通过计算副本数目来提交，因为可以确认自己当前的任期号是最大的</li></ul></li><li>follower和candidate宕机<ul><li>如果这俩宕机，后续发送给他们的RPC都会失败</li><li>raft通过无限的重试来处理这种失败，如果崩溃的机器重启，那么这些RPC就会成功完成</li></ul></li></ul><p>Test中的Figure 8问题<br>解释可以参考<a href="https://zhuanlan.zhihu.com/p/369989974">https://zhuanlan.zhihu.com/p/369989974</a><br>解决方式</p><ul><li>leader只能够提交自己任期内的log entry，禁止提交非自己任期内的log entry</li></ul><h3 id="实现">实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</span><br></pre></td></tr></table></figure><ul><li>Success = false的情况<ul><li>args.Term &lt; rf.term</li><li>log不匹配</li></ul></li><li>流程<ul><li>获取锁</li><li>检查args.Term和rf.Term<ul><li>如果args.Term &lt; rf.term则失败返回，反之则更新心跳，Term和state</li></ul></li><li>更新term为args.Term，更新state为Follower</li><li>进行日志匹配判定，不匹配则失败返回冲突的index，匹配则进行log合并，持久化</li><li>判定是否需要更新commitIndex<ul><li>如果需要更新则使用min(args.LeaderCommit, rf.LogTail().Index)更新，防止日志回滚</li><li>广播apply命令</li></ul></li><li>success = true</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</span><br></pre></td></tr></table></figure><ul><li>success = false 的情况<ul><li>args.Term &lt; rf.term</li><li>投过票了</li><li>args中的日志旧</li></ul></li><li>流程<ul><li>获取锁</li><li>检查args.Term和rf.Term<ul><li>如果args.Term &lt; rf.term则失败返回</li></ul></li><li>更新term为args.Term，更新state为Follower</li><li>如果检查条件为可以投票（  (没有投过票||投票给同一个人) &amp;&amp; args的日志新  ）<ul><li>更新心跳，更新rf.voteFor，更新success，持久化</li></ul></li><li>不可以投票则success=false返回</li></ul></li><li>如何确定args中log新于rf中log<ul><li>判断args log尾部entry的Term和rf log尾部entry的Term<ul><li>大于则新</li><li>等于则判断尾部的entry Index，大于等于则新</li><li>其余为旧</li></ul></li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> DoElection()</span><br></pre></td></tr></table></figure><p>在Make阶段创建的后台协程，只要rf没有被kill掉就一直运行<br>流程</p><ul><li>获取锁</li><li>判断当前是否是leader，如果是则释放锁continue</li><li>判断接受心跳时间是否超过ElectionTimeout，如果没有，则解锁进行下一次循环</li><li>超时，遍历其他server投票请求投票RPC进行选举<ul><li>选举成功（收到成功的回复数 &gt; num of server / 2），更新自身状态为leader，初始化自身nextIndex和matchIndex，并BroadcastHeartbeat广播一次心跳</li><li>完成上述操作后继续Election</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> BroadcastHeartbeat()</span><br></pre></td></tr></table></figure><p>广播心跳</p><ul><li>使用go协程向其他server 进行Replicate操作（复制日志）</li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Replicate(server <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>复制日志，主要是获取相关参数，传入Sync进行<br>流程</p><ul><li>获取锁</li><li>判断当前状态是否是leader，只有leader才可以进行Replicate操作</li><li>获取当前rf.nextIndex[server]，将位于nextIndex到rf.LogTail之间的logEntry作为参数Entries构建AppendEntriesArgs</li><li>解锁后进行Sync操作</li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Sync(server <span class="type">int</span>, args *AppendEntriesArgs) </span><br></pre></td></tr></table></figure><p>同步操作，通过sendAppendEntries来实现leader和follower之间的日志同步<br>流程</p><ul><li>向server发送sendAppendEntries并获得reply AppendEntriesReply</li><li>获取锁</li><li>判断rf.term 是否等于 args.Term，不相等说明leader已经不是leader，解锁并返回</li><li>判断rf.term和reply.Term，若reply.Term &gt; rf.term，说明leader也已经过期，重设rf的term和state</li><li>reply.Success == true<ul><li>len(args.Entries) == 0，说明是发送的是单纯心跳，不用做任何处理直接返回</li><li>获取logTailIndex := LogTail(args.Entries).Index，以此更新nextIndex和matchIndex</li><li>遍历从rf.commitIndex到logTailIndex，找到最大的超过半数节点match的Index，以此Index更新rf.commitIndex，因为只有在大多数节点都复制了日志后，且日志的任期和leader的任期一致，才能提交日志（test中的figure 8）</li><li>当rf.commitIndex &gt; rf.lastApplied时，进行applyCond.Broadcast()，提醒DoApply协程需要进行apply操作了</li></ul></li><li>reply.Success == false<ul><li>更新rf.nextIndex 和 rf.matchIndex</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> DoApply(applyCh <span class="keyword">chan</span> ApplyMsg)</span><br></pre></td></tr></table></figure><p>后台协程，用来apply log日志，通过条件变量rf.applyCond来实现协程的唤醒<br>流程</p><ul><li>获取rf.applyCond.L.Lock() （在go中，条件变量调用wait方法时必须要持有锁L.Lock()）</li><li>for循环，如果rf kill了则退出并解除相关锁<ul><li>判断当前是否需要apply （rf.lastApplied &lt; rf.commitIndex可以认为需要apply）</li><li>如果不需要则调用wait方法休眠</li><li>需要apply，则获取需要apply的log即rf.GetLogAtIndex(rf.lastApplied)，以该log的信息为参数传入到applyCh</li></ul></li></ul><h3 id="测试">测试</h3><p>编写脚本测试500次，全部通过。<br><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/test.png" alt="test" title="test"></p><h3 id="注意">注意</h3><ul><li>尽量不要简单的将log entry在rf.log中的位置直接作为index，推荐将index单独编入entry结构体中，不然后续的lab 2C 2D会非常痛苦，同理不推荐直接根据entry在log中的位置进行各种操作，可以编写根据logIndex获取对应log entry的函数来进行处理</li><li>需要仔细理解Figure 8的含义，注意在更新commitIndex时日志回滚的问题</li></ul><h3 id="参考内容-致谢">参考内容 &amp;&amp; 致谢</h3><ul><li><a href="https://space.bilibili.com/61981458">戌米的论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-locking.txt">raft-locking.txt</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-structure.txt">raft-structure.txt</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li><li><a href="https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/">Sworduo’s Blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/543989771">十一的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/463144886">谭新宇的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/369989974">多颗糖的知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从本次lab改用了2021版本的实验，后续的内容更加丰富，并对lab 2a的代码进行了重构，放弃了leader candidate follower明确划分的模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 2023 Spring Proj1 Buffer Pool</title>
    <link href="https://penpenf28.github.io/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/"/>
    <id>https://penpenf28.github.io/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/</id>
    <published>2023-08-27T10:18:26.000Z</published>
    <updated>2023-10-10T06:36:37.717Z</updated>
    
    <content type="html"><![CDATA[<h1>实验说明</h1><ul><li>实验主页<a href="https://15445.courses.cs.cmu.edu/spring2023/project1/">https://15445.courses.cs.cmu.edu/spring2023/project1/</a></li><li>本次实验主要完成buffer pool（缓存池）<ul><li>缓存池是用来在主存和磁盘之间移动物理页（physical page）的工具</li><li>该部分对于数据库管理系统（DBMS）的其他部分来说透明，举例来说，DBMS要求使用一个独有的page_id，buffer pool则帮DBMS获取这个page，不需要知道这个page一开始是否在主存中或者是从disk中取到主存再返回给DBMS的</li></ul></li></ul><h1>Task #1 - LRU-K Replacement Policy</h1><p>Task分析<br>需要使用LRU-K策略来实现frame的换入和换出。<br>普通的LRU策略是当replacer的缓存池的大小满了（这里是curr_size == replacer_size）后需要将其中最长时间没有访问的给替换出去。<br>LRU-K相对于LRU缓解了缓存污染的问题。</p><blockquote><p>LRU缓存污染：偶发性的，周期性的批量操作会导致LRU cache的命中率急剧下降，这时缓存中的数据大部分都不是热点数据<br>如何确定K？K增大，命中率会更高，但是适应性差（清楚一个缓存需要大量的数据访问，一般选择LRU-2，LRU == LRU-1）</p></blockquote><p>LRU-K Replacer在本次Task中的实现如下</p><ul><li>维护一个unordered_map&lt;frame_id_t, std::shared_ptr<LRUKNode>&gt; node_store_，用来记录全部的节点</LRUKNode></li><li>维护两个list<ul><li>std::list&lt;std::shared_ptr<LRUKNode>&gt; history_list_; 用来存放访问的节点，但是访问次数小于K次，list的排列顺序按照FIFO的规则，list尾部表示最新访问的数据，头部表示最旧访问的数据</LRUKNode></li><li>std::list&lt;std::shared_ptr<LRUKNode>&gt; cache_list_; 真正需要缓存的节点，访问次数大于等于K次，list的排列顺序遵守LRU-K的规则，参照Node元素中timestamps的头部元素进行排列，按照从小到大的规则，list尾部表示头部元素最大的(最新的)</LRUKNode></li></ul></li><li><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/node_store.png" alt="node_store" title="node_store"></li><li>history_list_.size + cache_list_.size = curr_size</li><li>LRUNode表示一个frame在LRUKReplacer中的状态<ul><li>成员变量：frame_id，size k_（最多纪录前k_个访问时间），访问次数ref_count，是否可以evict，timestamps（数组，前k个访问时间）</li><li>同时每次访问frame时（RecordAccess），ref_count都需要自增</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRUKNode</span>() &#123;</span><br><span class="line">    k_ = <span class="number">0</span>;</span><br><span class="line">    fid_ = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = -1;</span></span><br><span class="line">    is_evictable_ = <span class="literal">true</span>;</span><br><span class="line">    ref_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUKNode</span>(<span class="type">size_t</span> k, <span class="type">frame_id_t</span> fid, <span class="type">size_t</span> access_time, <span class="type">bool</span> is_evictable, <span class="type">size_t</span> ref_count)</span><br><span class="line">: <span class="built_in">k_</span>(k), <span class="built_in">fid_</span>(fid), <span class="built_in">is_evictable_</span>(is_evictable), <span class="built_in">ref_count_</span>(ref_count) &#123;</span><br><span class="line">    timestamps_.<span class="built_in">push_back</span>(access_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUKNode</span>(<span class="type">const</span> LRUKNode &amp;other) &#123;</span><br><span class="line">    k_ = other.k_;</span><br><span class="line">    fid_ = other.fid_;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = other.last_seen_timestamp_;</span></span><br><span class="line">    timestamps_ = other.timestamps_;</span><br><span class="line">    is_evictable_ = other.is_evictable_;</span><br><span class="line">    ref_count_ = other.ref_count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetFrameId</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">frame_id_t</span> </span>&#123; <span class="keyword">return</span> fid_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetRefCount</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> ref_count_; &#125;</span><br><span class="line"><span class="comment">// auto GetLastSeenTimestamp() const -&gt; size_t &#123; return last_seen_timestamp_; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetFirstTimestamp</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> timestamps_.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IsEvictable</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> is_evictable_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IncRefCount</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123; ref_count_++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetTimestamp</span><span class="params">(<span class="type">size_t</span> timestamp)</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = timestamp;</span></span><br><span class="line">    timestamps_.<span class="built_in">push_back</span>(timestamp);</span><br><span class="line">    <span class="keyword">auto</span> first_timestamp = timestamps_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span> (timestamps_.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">        timestamps_.<span class="built_in">erase</span>(timestamps_.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first_timestamp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetFrameId</span><span class="params">(<span class="type">frame_id_t</span> fid)</span> -&gt; <span class="type">void</span> </span>&#123; fid_ = fid; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetK</span><span class="params">(<span class="type">size_t</span> k)</span> -&gt; <span class="type">void</span> </span>&#123; k_ = k; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetEvictable</span><span class="params">(<span class="type">bool</span> is_evictable)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> is_same = is_evictable_ == is_evictable;</span><br><span class="line">    is_evictable_ = is_evictable;</span><br><span class="line">    <span class="keyword">return</span> is_same;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line"><span class="comment">// Remove maybe_unused if you start using them. Feel free to change the member variables as you want.</span></span><br><span class="line"></span><br><span class="line">[[maybe_unused]] <span class="type">size_t</span> k_;</span><br><span class="line">[[maybe_unused]] <span class="type">frame_id_t</span> fid_;</span><br><span class="line"><span class="comment">// [[maybe_unused]] size_t last_seen_timestamp_;</span></span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; timestamps_;</span><br><span class="line">[[maybe_unused]] <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> ref_count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRU-K的原理</p><ul><li>对一个frame访问时(RecordAceess)先搜索全部的节点node_store_<ul><li>如果存在，需要记录当前的current_timestamp，即插入到该LRUK节点的timestamp数组中，如果数组size&gt;k_，则pop掉最前面的元素，这时数组的头部元素就是前第k次访问时间。并将该节点的ref_count++</li><li>如果不存在，则新建一个LRUKNode，记录到node_store和history中（同时指向这个新建的LRUKNode）<ul><li>新加入的节点需要考虑当前需要全部元素的个数，如果curr_size == replacer_size，需要Evict掉一个节点<ul><li>Evict逻辑比较简单（只evict一个节点），分别从头到尾遍历history和cache（顺序一定是先history再cache），如果某个节点is_evictable，就把它从对应的list和node_store中erase掉</li></ul></li><li>新节点直接push_back到history尾部即可（history遵循FIFO规则），注意⚠️需要考虑k = = 1的情况，即新节点ref_count = = 1，在移入history之后又要立即移动到cache</li></ul></li></ul></li><li>如果当前节点ref_count==k，说明该节点现在在history中，达到了k次的访问次数，需要从histroy移动到cache中了<ul><li>因为是将history中的node移动到cache中，不涉及整体size大小的变化，也就不需要Evict cache</li><li>将该frame_id对应的node从history中erase</li><li>从cache_list的链表头开始遍历，比较链表节点中timestamps的头部元素和待插入的节点的timestamps的头部元素（前第k次访问时间），找到第一个比待插入节点大的链表节点（比待插入新），插入到该节点之前</li><li>通过这种操作，保证了cache_list遵循了LRU-K规则，cache最先淘汰的永远是链表头部节点</li></ul></li><li>如果当前节点ref_count&gt;k，说明该节点在访问之前就在cache中了，需要根据该节点的timestamps更新该节点在cache_list中的位置，更新规则同ref_count==k的插入规则</li></ul><p>关键点</p><ul><li>LRUNode对应每一个frame对应的node<ul><li>比较关键的是其中的timestamps_数组，用来存放每次访问的时间，数组大小最大为k，当访问数refcount&gt;=k时，把这个node从history移动到cache中真正缓存下来</li></ul></li><li>history中按照FIFO替换，cache中按照LRU-K替换</li><li>注意k==1的情况</li><li>当ref_count==k时不需要考虑size的变化，因为是history和cache之间的交互，不影响整体的size</li></ul><h1>Task #2 - Buffer Pool Manager</h1><p>Task分析<br>Task1中的replacer只是用来记录frame的使用情况，并不做具体的写入写出操作，Task2的buffer pool则需要完成具体的page的写入写出。<br>一个frame可以理解为一个实际的物理存储空间块，page表示的是逻辑上的存储，在DBMS的一整个生命周期中，page可以对应多个frame（同一时间一个page只能对应一个frame），映射关系通过NewPage构建。</p><p>Task2没有添加额外的成员变量，但是增加了一个成员函数FindFrame，各函数实现逻辑如下</p><ul><li>构造函数<ul><li>初始化时直接根据pool_size_，初始化Page* pages即缓存池</li><li>page_table_存放是的page_id到frame_id的映射</li><li>free_list_存放的是未使用的frame_id（0&lt;=id&lt;pool size），即未使用的实际上的物理frame</li></ul></li><li>增加了一个辅助函数FindFrame<ul><li>输入参数为frame_id_t *frame_id</li><li>先搜索free_list_，如果有空余的frame，那么给frame_id赋值并返回</li><li>如果没有空的frame，用replacer的Evict替换掉其中的一个frame，并将替换的frame的id保存到frame_id中，再从pages取出frame_id对应的page，如果该page dirty，则写入到disk中，然后将该page_id和frame_id的映射从page_table中清除</li></ul></li><li>NewPage<ul><li>找到一个可用的frame_id，使用该frame_id从pages中取出一页，对该页分配page_id，添加table映射，设置pin_count和replacer对于该frame的相关参数</li></ul></li><li>FetchPage<ul><li>从buffer pool中取出page_id对应的page</li><li>首先搜索page_id到frame_id的映射，保证当前page_id对应一个实际的物理frame<ul><li>如果有，则取出该frame_id对应的page，并设置pin_count和replacer</li><li>如果没有，则FindFrame，找到一个合适的物理frame，从磁盘上将该page_id的数据读取到对应的page中</li></ul></li></ul></li><li>UnpinPage<ul><li>输入为page_id和该page是否dirty</li><li>作用是解除page_id对应page的一次引用</li><li>首先是搜索该page_id是否有分配对应的物理frame，如果没有，返回false</li><li>如果有对应的frame，查看该page的pin_count<ul><li>如果小于等于0，说明已经没有数据在引用这个frame，直接返回false</li><li>如果大于0，则pin_count–，把dirty写入到page的is_dirty参数，如果解除这次引用后pin_count==0，还需要对replacer SetEvictable</li></ul></li></ul></li><li>FlushPage<ul><li>输入为page_id</li><li>将page_id对应的page写入到disk中，并更新dirty位</li><li>首先判断page_id是否合法</li><li>在page_table中搜索该page_id，判断是否分配frame<ul><li>如果没有分配，return false</li><li>如有分配，将frame_id对应的page写入到disk，并设置dirty位</li></ul></li></ul></li><li>FlushAllPages<ul><li>输入为空</li><li>遍历page_table，将全部的page都写入到disk中即可</li></ul></li><li>DeletePage<ul><li>输入为page_id</li><li>删除page_id对应的实际的page</li><li>首先遍历table，确定是否有分配实际的frame<ul><li>无，返回true</li><li>有，判断pin_count是否大于0，如果大于0，说明仍有数据引用这块page，因此不能删除，返回false</li></ul></li><li>确定这块page可以删除后<ul><li>分别在page_table清除映射，replacer清除frame，free_list_添加frame，Deallocate该page_id，Reset该page的memory，重置pin_count和dirty位，最后将该page_id设置为INVALID，return true</li></ul></li></ul></li></ul><h1>Task #3 - Read/Write Page Guards</h1><p>Task分析<br>在Task2的条件下，使用DBMS忘记调用UnpinPage可能会导致该page永远不会被Evict掉，会造成page在内存和磁盘之间来回的交换，大大影响系统性能，Task要求实现PageGuard相关成员来完成Page的使用安全性保证。<br>阅读代码后分析任务，主要是完成类的move的自定义构造函数和自定义操作符，类的Drop函数，类的析构函数，前两个Task实现清楚的话，Task3难度属于简单。</p><p>各函数实现细节如下<br>page_guard</p><ul><li>move构造函数<ul><li>将本类中的成员指向传入的右值</li><li>右值置空</li></ul></li><li>move=操作符<ul><li>如果本类和传入的右值地址相同直接返回</li><li>否则Drop掉本类当前的page</li><li>将本类中的成员指向传入的右值</li><li>右值置空</li></ul></li><li>Drop<ul><li>用来取消对当前page的引用</li><li>首先判断当前page是否为空，为空直接返回</li><li>UnpinPage，并置空当前的pageguard</li></ul></li><li>析构函数<ul><li>直接Drop</li></ul></li><li>Read和Write pageguard<ul><li>如果page存在，进行上述实现时需要释放lock</li></ul></li></ul><p>buffer_manager</p><ul><li>Fetch_R/W_Page时，如果page不空，需要上锁</li></ul><h1>Test</h1><ul><li>跑测试之前需要把DISABLE都删除<br><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/grade1.png" alt="grade1" title="grade1"></li></ul><p>leader board rank<br><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/grade2.png" alt="grade2" title="grade2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实验主页&lt;a href=&quot;https://15445.courses.cs.cmu.edu/spring2023/project1/&quot;&gt;https://15445.courses.cs.cmu.edu/spring2023/proje</summary>
      
    
    
    
    <category term="Database" scheme="https://penpenf28.github.io/categories/Database/"/>
    
    
    <category term="CMU15-445" scheme="https://penpenf28.github.io/tags/CMU15-445/"/>
    
    <category term="Database" scheme="https://penpenf28.github.io/tags/Database/"/>
    
    <category term="C++" scheme="https://penpenf28.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 2023 Spring Proj0 C++ Primer</title>
    <link href="https://penpenf28.github.io/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/"/>
    <id>https://penpenf28.github.io/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/</id>
    <published>2023-08-24T16:32:23.000Z</published>
    <updated>2023-10-10T06:36:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1>实验说明</h1><ul><li>实验主页<a href="https://15445.courses.cs.cmu.edu/spring2023/project0/">https://15445.courses.cs.cmu.edu/spring2023/project0/</a></li><li>本次Proj主要完成copy-on-write trie前缀树</li><li>C++17</li></ul><p><img src="/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/cover.png" alt="structure" title="structure"></p><h1>Task #1 - Copy-On-Write Trie</h1><p>Task 1要求完成一个copy-on-write前缀树，需要学习一下相关C++17的语法以及智能指针的使用，学习完成后此任务难度不高。</p><h3 id="Get">Get</h3><p>Get函数主要是根据给定的key来查找是否有对应的value并返回，此部分不涉及copy-on-write。</p><ul><li>设置一个std::shared_ptr<const trienode> node = 根节点</const></li><li>遍历key的每一个字符c，如果可以从node的children中找到对应的child，那么令node = next_node，否则返回nullptr</li><li>遍历至最后一个节点，判断是否是value节点，使用dynamic_cast&lt;const TrieNodeWithValue<T> *&gt;进行强制的类型转换获取value并返回<ul><li>dynamic_cast 只适用于指针和引用类型，不能用于普通对象</li><li>dynamic_cast 在转换时，源类型必须至少含有一个虚函数，以确保运行时类型信息的存在</li><li>dynamic_cast 的转换只能在具有多态关系的类层次结构中进行</li></ul></T></li></ul><h3 id="Put">Put</h3><p>Put函数主要是将对应的key和value插入到前缀树中，在向下遍历的过程中，遇到已有的节点需要Clone一份新的节点。</p><ul><li>需要三个新的变量new_root和前后指针parent和child<ul><li>std::shared_ptr<TrieNode> new_root = this-&gt;root_ ? this-&gt;root_-&gt;Clone() : std::make_shared<TrieNode>(); 因为是从根节点开始向下遍历，如果根节点存在的话也需要Clone一份，不存在的话就新建。</TrieNode></TrieNode></li><li>这里向下遍历用到了前后指针的技巧parent和child，初始parent指向nullptr，child指向new_root</li></ul></li><li>通过遍历key的字符c向下遍历整个前缀树，如果当前parent的对应的孩子节点不为空，就需要copy(Clone)后赋值给child，并更新parent的children，然后令parent=child并继续下一轮迭代</li><li>遍历到最终字符时使用std::make_shared&lt;TrieNodeWithValue<T>&gt;(child-&gt;children_,std::make_shared<T>(std::move(value)));给最终的child赋值<ul><li>该代码作用是创建一个TrieNodeWithValue类型的指针，括号内是初始化TrieNodeWithValue的构造函数的参数列表，其中需要传入child-&gt;children_因为当前节点可能不是叶子节点，需要把它的孩子节点拷贝进来</li></ul></T></T></li><li>将最后更新的child节点更新到parent的children中，返回new_root构建的Trie即可(return Trie(new_root))</li></ul><h3 id="Remove">Remove</h3><p>Remove操作也需要用到copy-on-write思想，不能在原来的树上直接进行操作，考虑到如果当前节点是叶子节点，删除后他的parent的children为空，这时parent也需要删除，继续向上迭代，这种方式很容易联想到使用stack来回溯解决。</p><ul><li>初始化和Put中相同的三个变量，多加一个stack&lt;std::pair&lt;std::shared_ptr<TrieNode>, char&gt;&gt; stk，用来保存访问过的node，便于回溯</TrieNode></li><li>遍历key的字符c，遍历的过程中copy-on-write，并将遍历过的node加入到stack中<ul><li>如果找到空节点，说明要删除的节点根本不存在，直接return nullptr</li></ul></li><li>找到了需要删除的节点<ul><li>如果该节点没有孩子，直接将该节点置空</li><li>如果该节点有孩子，通过child = make_shared<TrieNode>(nxt-&gt;children_)删除掉value</TrieNode></li></ul></li><li>开始回溯<ul><li>不断的获取栈顶元素parent，如果child==nullptr，erase掉parent的children中的对应元素，如果此时parent为空，则也将parent置空，令child=parent</li><li>重复上述过程，直到stack空为止</li></ul></li></ul><h1>Task #2 - Concurrent Key-Value Store</h1><p>Task 2需要学习一下C++中mutex的使用，难度属于简单，lab设置为多个读者和一个写者。</p><h3 id="Get-2">Get</h3><ul><li>首先lock root并获取当前的root，随即释放掉lock，不要直接在持有锁的情况下遍历前缀树来获取value，这样会非常影响性能</li><li>用刚才获取的root调用Get方法并返回即可，</li></ul><h3 id="Put-2">Put</h3><ul><li>写者在Put过程中需要一直持有write_lock避免其他线程对临界区的访问</li><li>获取root的方式和Get相同，然后对root调用Put方法即可</li></ul><h3 id="Remove-2">Remove</h3><ul><li>流程和Put相同，只是调用的方法不同</li></ul><h1>Task #3 - Debugging</h1><p>配置vscode debug文件完成，具体参照<a href="https://www.youtube.com/watch?v=G9gnSGKYIg4">https://www.youtube.com/watch?v=G9gnSGKYIg4</a>。</p><ul><li>build项目，make trie_debug_test -j$(nproc)</li><li>将trie_debug_test配置到vscode的debug文件中</li><li>F5断点观察结果即可</li></ul><p>个人配置文件如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Use IntelliSense to learn about possible attributes.</span><br><span class="line">    // Hover to view descriptions of existing attributes.</span><br><span class="line">    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Debug&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/lab/build/test/trie_debug_test&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中program参数配置你想要debug的程序</li></ul><h1>Task #4 - SQL String Functions</h1><p>实现两个简单的Upper和Lower函数</p><ul><li>首先需要在string_expression.h中实现这两个函数<ul><li>根据expr_type_来选择哪一个函数，然后对函数进行实现</li></ul></li><li>然后在plan_func_call.cpp中对函数进行注册<ul><li>使用func_name返回对应实现的函数</li></ul></li></ul><h1>Test</h1><p><img src="/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/test.png" alt="test" title="test"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实验主页&lt;a href=&quot;https://15445.courses.cs.cmu.edu/spring2023/project0/&quot;&gt;https://15445.courses.cs.cmu.edu/spring2023/proje</summary>
      
    
    
    
    <category term="Database" scheme="https://penpenf28.github.io/categories/Database/"/>
    
    
    <category term="CMU15-445" scheme="https://penpenf28.github.io/tags/CMU15-445/"/>
    
    <category term="Database" scheme="https://penpenf28.github.io/tags/Database/"/>
    
    <category term="C++" scheme="https://penpenf28.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 2020 Lab2 Raft Part 2A</title>
    <link href="https://penpenf28.github.io/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/"/>
    <id>https://penpenf28.github.io/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/</id>
    <published>2023-07-21T12:25:54.000Z</published>
    <updated>2023-10-10T06:56:00.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后续实验对此部分代码进行了重构，因此代码不具备参考性，仅适用于本次实验</p></blockquote><p>阅读本文前请先仔细阅读<a href="%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-raft.html%5D">Lab 2</a>Part 2A相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="2A实验说明">2A实验说明</h3><ul><li>2A部分需要完成Raft系统中的leader election和heartbeats</li><li>保证系统中最多只有一个leader，如有特殊情况可以发生leader的取代</li><li>相关RPC的调用可以阅读labrpc文件夹中的代码</li></ul><h3 id="Test分析">Test分析</h3><p>代码编写完成后通过go test进行测试，可以理解为C艹中的单元测试，这里通过make_config构建起整个系统cfg。</p><ul><li>cfg中包括有多个raft对象，每个raft对象对应有自己的ClientEnd数组peers，表示自己与其他raft的连接，可以理解为传输数据的通道（通过RPC）</li><li>网络中各个raft初始化完成后通过connect进行raft之间的连接（对应RPC通信）</li><li>每个raft有三种state对应论文中的leader，candidate，follower</li><li>以计算机网络的视角来看，cfg.net对应网络层，ClientEnd对应传输层，raft对应应用层</li><li>整体Test系统构建流程<ul><li>make_config构建系统<ul><li>初始化若干个raft对象</li><li>将若干raft对象进行连接</li></ul></li><li>插入检查，宕机，sleep等操作</li><li>end</li></ul></li><li>第一个测试TestInitialElection2A首先是初始化整个系统，设置了3个raft对象，不进行fail操作，中间sleep一段时间检查你的系统是否稳定（即没有发生宕机的情况下你的leader是否可以稳定的一直发送心跳）</li><li>第二个测试TestReElection2A会在中间加入节点的disconnect，后续重新connect，考验设计系统的鲁棒性</li></ul><h3 id="设计概述">设计概述</h3><blockquote><p>实验大部分思路来自于<a href="https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/">https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/</a> and <a href="https://zhuanlan.zhihu.com/p/543989771">https://zhuanlan.zhihu.com/p/543989771</a>，在此基础上进行修改，十分感谢！</p></blockquote><h4 id="结构说明">结构说明</h4><ul><li>每个raft通过Make函数来构建起单个的raft系统<ul><li>在Make中对raft中的参数进行初始化</li><li>实验要求Make立即返回，因此整个系统的运行应该放在一个goroutine中，这里设计了Schedule函数进行调度</li></ul></li><li>利用Schedule函数进行状态的变换（ follower&lt;-&gt;candidate&lt;-&gt;leader ）<ul><li>followerTick()<ul><li>follower在2a中考虑三种情况<ul><li>收到来自leader的心跳，继续follower状态</li><li>自己给其他candiadte投票，继续follower状态</li><li>超时，既没有收到心跳，也没有给别人投票，自己变为candidate状态</li></ul></li></ul></li><li>candidateTick()<ul><li>candidate需要考虑四种情况<ul><li>收到来自leader的心跳，切换到follower状态</li><li>自己给其他candiadte投票，切换到follower状态</li><li>自己赢得选举，切换到leader状态</li><li>选举超时，继续下一轮选举，保持candidate状态</li></ul></li></ul></li><li>leaderTick()<ul><li>leader需要考虑四种情况<ul><li>收到来自leader的心跳，切换到follower状态</li><li>自己给其他candiadte投票，切换到follower状态</li><li>收到的心跳reply中有大于自己term（任期），切换到follower状态</li><li>心跳计时到期，保持leader状态，开始下一轮心跳发送</li></ul></li></ul></li></ul></li><li>RPC相关（对应操作用颜色标注，红色表示心跳RPC，绿色表示投票RPC）<ul><li>心跳RPC  AppendEntries<ul><li>根据args更新自身raft对象中的参数并返回reply</li></ul></li><li>投票RPC  RequestVote<ul><li>根据args更新自身raft对象中的参数并返回reply</li></ul></li></ul></li></ul><h4 id="架构图">架构图</h4><p><img src="/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/structure.png" alt="structure" title="structure"></p><h3 id="具体实现">具体实现</h3><h4 id="Definition">Definition</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower  = <span class="number">0</span></span><br><span class="line">Candidate = <span class="number">1</span></span><br><span class="line">Leader    = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// heart_beat</span></span><br><span class="line"><span class="keyword">type</span> AppendEntryArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span></span><br><span class="line">LeaderId     <span class="type">int</span></span><br><span class="line">PrevLogIndex <span class="type">int</span></span><br><span class="line">PrevLogTerm  <span class="type">int</span></span><br><span class="line">Entries      []LogEntry</span><br><span class="line">LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AppendEntryReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="type">int</span></span><br><span class="line">Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">ItemId <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的LogEntry在2A中暂时不用，其余定义按照paper编写即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    state <span class="type">int</span> <span class="comment">//当前的状态</span></span><br><span class="line">    electionTimeout *time.Timer <span class="comment">//选举时间定时器</span></span><br><span class="line"></span><br><span class="line">    currentTerm <span class="type">int</span>        <span class="comment">//当前的任期号</span></span><br><span class="line">    voteFor     <span class="type">int</span>        <span class="comment">//当前获得选票的候选人id</span></span><br><span class="line">    logEntries  []LogEntry <span class="comment">//日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</span></span><br><span class="line"></span><br><span class="line">    appendCh <span class="keyword">chan</span> *AppendEntryArgs <span class="comment">//leader发送的心跳</span></span><br><span class="line">    voteCh   <span class="keyword">chan</span> *RequestVoteArgs <span class="comment">//candidate发送的投票</span></span><br><span class="line">    l2fCh    <span class="keyword">chan</span> <span class="type">bool</span>             <span class="comment">//leader心跳收到比自己大的term，变为follower</span></span><br><span class="line"></span><br><span class="line">    heartBeatTimeOut <span class="type">int</span> <span class="comment">//1秒10次心跳</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>appendCh表示自己成功接收到来自于leader的心跳，在心跳RPC中处理</li><li>voteCh表示自己成功给某个candidate投票，在投票RPC中处理</li><li>l2fCh表示leader收到心跳回复中有比自己大的term</li><li>通过electionTimeout来控制选举超时的时间（定义为450-550ms）</li><li>heartBeatTimeOut设置为100ms</li></ul><h4 id="Schedule">Schedule</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Schedule() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">switch</span> rf.state &#123;</span><br><span class="line">        <span class="keyword">case</span> Leader:</span><br><span class="line">            rf.leaderTick()</span><br><span class="line">        <span class="keyword">case</span> Candidate:</span><br><span class="line">            rf.candidateTick()</span><br><span class="line">        <span class="keyword">case</span> Follower:</span><br><span class="line">            rf.followerTick()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据rf当前的状态执行对应的Tick即可。</li></ul><h4 id="AppendEntries-Heart-beat-RPC">AppendEntries(Heart_beat) RPC</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heart_beat from leader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntryArgs, reply *AppendEntryReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.voteFor = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    reply.Success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(args *AppendEntryArgs)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> rf.appendCh &lt;- args:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            &lt;-rf.appendCh</span><br><span class="line">            rf.appendCh &lt;- args</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收来自于leader的heart_beat args，如果leader的任期比自己小，则赋值reply后直接返回，不向appendCh中发送数据，表示自己没有接收到心跳，自己自动通过timeOut转变为candidate</li><li>leader任期大于等于自己，则更新自己的相关成员，向appendCh中发送数据表示接受到心跳</li><li>接收心跳后根据appendCh进行状态的转换（在follower，candidate，leader中处理）</li></ul><h4 id="Request-vote-RPC">Request_vote RPC</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rf.voteFor != <span class="number">-1</span> &amp;&amp; rf.voteFor != args.CandidateId &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//票还没投过，可以投</span></span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">    rf.voteFor = args.CandidateId</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">    <span class="comment">//same as heartbeat...</span></span><br><span class="line">    &#125;(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果请求投票的candidate的任期比自己小，则不给他投票</li><li>如果任期比自己大，给他投票</li><li>如果之前投过票了就不能再投票</li><li>投票之后向voteCh发送数据表示自己已经投过票了，根据该信息转换自己当前的状态（在follower，candidate，leader中处理）</li></ul><h4 id="Follower">Follower</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerTick() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rf.resetTimeout()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> args := &lt;-rf.appendCh:</span><br><span class="line">            <span class="comment">//收到了来自于leader的心跳，继续follower</span></span><br><span class="line">        <span class="keyword">case</span> args := &lt;-rf.voteCh:</span><br><span class="line">            <span class="comment">//自己投票给了其他candidate，继续follower</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.electionTimeout.C:</span><br><span class="line">            <span class="comment">//超时没收到心跳，变为candidate</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据channel中的信息进行自身成员的更新和状态转换即可。</li></ul><h4 id="Candidate">Candidate</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> candidateTick() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.voteFor = rf.me</span><br><span class="line">    rf.currentTerm++</span><br><span class="line">    currentTerm := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    args := &amp;RequestVoteArgs&#123;</span><br><span class="line">        Term:        currentTerm,</span><br><span class="line">        CandidateId: rf.me,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    voteCnt := <span class="number">1</span></span><br><span class="line">    voteNote := <span class="literal">false</span></span><br><span class="line">    voteWin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">    voteLock := sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选举超时统计</span></span><br><span class="line">    rf.resetTimeout()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> ok := rf.sendRequestVote(i, args, reply); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">                    voteLock.Lock()</span><br><span class="line">                    voteCnt++</span><br><span class="line">                    <span class="keyword">if</span> !voteNote &amp;&amp; voteCnt &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                        voteNote = <span class="literal">true</span></span><br><span class="line">                        voteLock.Unlock()</span><br><span class="line">                        voteWin &lt;- <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        voteLock.Unlock()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换状态，简单的修改state即可</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.appendCh:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.voteCh:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-voteWin:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.electionTimeout.C:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进行candidateTick，首先根据论文所述，进入candidate状态先将自身的currentTerm+1，然后向其余的节点发送请求投票的RPC，收集到超过一半的选票后变为leader</li><li>如果在此期间收到了心跳或者自己给其他candidate投票，则关闭其给其他节点发送的请求投票的RPC并将状态变为follower</li><li>如果选举超时，那么开启新一轮选举</li><li>注意需要将rf.currentTerm提前保存下来，保证发送给其他节点的Term是开始时的Term，否则直接调用rf.currentTerm可能导致发送给其他节点的Term并不相等。</li></ul><h4 id="Leader">Leader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderTick() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    currentTerm := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            args := &amp;AppendEntryArgs&#123;</span><br><span class="line">                Term:     currentTerm,</span><br><span class="line">                LeaderId: rf.me,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, currentT <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                reply := &amp;AppendEntryReply&#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> ok := rf.sendAppendVote(i, args, reply); ok &#123;</span><br><span class="line">                    rf.mu.Lock()</span><br><span class="line">                    <span class="keyword">if</span> rf.currentTerm != currentT &#123;</span><br><span class="line">                        rf.mu.Unlock()</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    rf.mu.Unlock()</span><br><span class="line">                    <span class="keyword">if</span> reply.Success &#123;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rf.mu.Lock()</span><br><span class="line">                        <span class="keyword">if</span> reply.Term &gt; currentT &#123;</span><br><span class="line">                            rf.currentTerm = reply.Term</span><br><span class="line">                            rf.mu.Unlock()</span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                            <span class="keyword">case</span> rf.l2fCh &lt;- <span class="literal">true</span>:</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                &lt;-rf.l2fCh</span><br><span class="line">                                rf.l2fCh &lt;- <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            rf.mu.Unlock()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i, currentTerm)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Duration(rf.heartBeatTimeOut) * time.Millisecond):</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.appendCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.voteCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.l2fCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意leader在执行的过程中用一个for循环包裹，heart_beat每隔一段时间就进行发送，在本文中采用的是time.After，实验手册中建议直接使用time.Sleep</li><li>leader在每次for循环中向其余的节点发送心跳RPC，并根据reply判断是否放弃leader身份</li><li>如果计时器结束，说明一切正常，继续下一轮的心跳发送</li><li>如果收到了其他节点的心跳，说明其他节点成为了leader，自己需要放弃leader身份</li><li>如果给其他节点投票，说明其他节点的Term比自己新，自己需要放弃leader身份</li><li>如果其他节点心跳的reply中Term比自己新，自己需要放弃leader身份</li></ul><h3 id="测试">测试</h3><p>编写脚本测试500次，全部通过。<br><img src="/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/test.png" alt="test" title="test"></p><h3 id="注意">注意</h3><ul><li>实验过程中可以利用util中的DPrintf打印相关信息，方便debug</li><li>重点在于分析清楚各个goroutines的生命周期</li><li>不要忘记实现GetState()和Kill()，不在Kill中对节点处理的话可能会导致断连的节点依旧打印信息</li><li>使用go test -race检测代码中潜在的race问题</li><li>可能造成bug的原因<ul><li>第一个test报错warning: term changed even though there were no failures原因是系统会通过checkTerms来检查当前的Term（任期号），在两次checkTerms中加入sleep，这期间你的系统是保持稳定的，即选举成功后没有发生任何crash或disconnect，leader一直持续的向其他节点发送心跳，因此两次checkTerms的Term应该不变，报错的原因就是你的两次Term发生了变化，说明系统不稳定，即使没有bug但是leader还是在更换</li><li>第二个test中断连一个leader后又把他重新加入网络，可能会导致两个leader</li><li>注意goroutines传入参数的设置，避免直接使用外部数据，通过参数传递使用你需要的数据，直接使用外部数据，数据可能会发生变化</li><li>在sendRPC返回ok的过程中可能会失败（disconnect），这类的RPC返回的非常慢（经过测试大于700ms，以秒为量级），注意这些goroutines</li></ul></li><li>建议编写自己的test script进行程序的测试，因为只跑少量的testcase无法检测出概率小的bug</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;后续实验对此部分代码进行了重构，因此代码不具备参考性，仅适用于本次实验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 2020 Lab1 MapReduce</title>
    <link href="https://penpenf28.github.io/2023/07/10/MIT6-824-2020-Lab1-MapReduce/"/>
    <id>https://penpenf28.github.io/2023/07/10/MIT6-824-2020-Lab1-MapReduce/</id>
    <published>2023-07-10T10:13:53.000Z</published>
    <updated>2023-10-10T06:36:39.997Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html%5D">Lab 1</a>实验要求并熟悉基础代码，了解Go中的RPC通信。<br>Lab环境的配置过程中可能会出现若干问题，参照<a href="%5Bhttps://juejin.cn/post/7018756637330685988%5D(https://juejin.cn/post/7018756637330685988)">此处</a>解决。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="实验说明">实验说明</h3><ul><li>完成分布式MapReduce系统设计，实现词频统计</li><li>Worker分别调用Map和Reduce Function来读取和处理文件</li><li>Master用来调度和处理失败的Worker</li><li>主要修改src/mr文件夹中的master.go rpc.go worker.go</li><li>Lab中是所有Map任务完成后才进行Reduce任务</li><li>Worker和Master之间利用RPC进行通信</li></ul><h3 id="设计概述">设计概述</h3><blockquote><p>大部分思路来自于<a href="https://github.com/yzongyue/6.824-golabs-2020">https://github.com/yzongyue/6.824-golabs-2020</a>，在此基础上进行修改，十分感谢！</p></blockquote><h4 id="结构说明">结构说明</h4><ul><li>调用mrmaster.go启动Master，监听是否有人向自身发送RPC请求。</li><li>调用mrworker.go启动Worker，首先询问Master是否已经分配了全部任务，如果分配完成了就不新建Worker，直接退出，如果未完成，则新建Worker分担任务。<ul><li>此处询问是否分配完成设计是由测试脚本引发的设计，crash.go中在master分配全部任务之后会继续新建Worker向master请求，如果不进行相关设计会warning，但是不影响正确结果</li></ul></li><li>Worker首先通过RPC通信向Master注册自身，再通过RPC通信向Master请求任务，执行任务，最后通过RPC向Master报告任务完成，此处共需要设计三种RPC请求回答格式。</li></ul><h4 id="架构图">架构图</h4><h5 id="master">master</h5><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/master.png" alt="master" title="master"></p><h5 id="worker">worker</h5><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/worker.png" alt="worker" title="worker"></p><h4 id="数据流图">数据流图</h4><p>以nMap = n，nReduce=3为例，其中中间文件的数量为nMap*nReduce=3n个。<br><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/dataflow.png" alt="dataflow" title="dataflow"></p><h3 id="具体实现">具体实现</h3><h4 id="Master">Master</h4><p>Master的作用就是统筹Worker，分配任务，因此需要为任务构建一个结构体，使用RPC在Master和Worker之间传输，定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskPhase <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MapPhase    TaskPhase = <span class="number">0</span></span><br><span class="line">ReducePhase TaskPhase = <span class="number">1</span></span><br><span class="line">WaitPhase   TaskPhase = <span class="number">2</span></span><br><span class="line">ExitPhase   TaskPhase = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">FileName <span class="type">string</span></span><br><span class="line">NMap     <span class="type">int</span></span><br><span class="line">NReduce  <span class="type">int</span></span><br><span class="line">ID       <span class="type">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NMap变量由文件数决定，由于在Map阶段需要生成中间文件mr-MapID-BucketID，此处的NMap用作后面Reduce阶段遍历相关中间文件。<br>Phase变量有4个取值，分别代表当前系统是在哪个任务阶段（可能TaskPhase会造成误解），其中Wait阶段是Worker向Master发出请求，但是Master现在并没有任务发送给他，Worker需要等待，Exit阶段表示当前需要退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// used in TaskStat</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TaskReady   TaskStatus = <span class="number">0</span></span><br><span class="line">TaskQueue   TaskStatus = <span class="number">1</span></span><br><span class="line">TaskRunning TaskStatus = <span class="number">2</span></span><br><span class="line">TaskDone    TaskStatus = <span class="number">3</span></span><br><span class="line">TaskError   TaskStatus = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskStat <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID  <span class="type">int</span></span><br><span class="line">Status    TaskStatus</span><br><span class="line">StartTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">files   []<span class="type">string</span></span><br><span class="line">NReduce <span class="type">int</span></span><br><span class="line"></span><br><span class="line">mu           sync.Mutex</span><br><span class="line">NowWorkers   <span class="type">int</span></span><br><span class="line">TotalWorkers <span class="type">int</span></span><br><span class="line">ExitWorkers  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">Tstate []TaskStat</span><br><span class="line">Phase  TaskPhase</span><br><span class="line"></span><br><span class="line">TaskCh <span class="keyword">chan</span> Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化过程中可以确定好files和NReduce，files是所需要处理的文件集合，NReduce是生成最后文件的数量，可以理解为桶的数量。<br>NowWorker为当前分配WorkerID的指针，每次有一个Worker发来一个注册RPC，为其分配一个WorkerID，然后NowWorker自增，TotalWorker自增。<br>TotalWorker为当前Master中存活的Worker，因为后续test脚本中有crash测试，因此当一个worker失联超过设置的时间后判定为crash，TotalWorker自减。<br>ExitWorker为当前Master中正常退出的Worker，当Worker发送退出RPC时（为了简化设计，将退出RPC和通知Master任务完成的RPC进行设计合并），ExitWorker自增。<br>如何判断当前任务全部完成，Master可以退出了( Done )？</p><ul><li>判断TotalWorkers和ExitWorkers是否相等即可。</li></ul><p>TState是Master中较为关键的成员，通过Init函数进行设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitMap() &#123;</span><br><span class="line">m.Phase = MapPhase</span><br><span class="line">m.Tstate = <span class="built_in">make</span>([]TaskStat, <span class="built_in">len</span>(m.files))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitReduce() &#123;</span><br><span class="line">m.Phase = ReducePhase</span><br><span class="line">m.Tstate = <span class="built_in">make</span>([]TaskStat, m.NReduce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TState的长度等于当前需要处理的Task的数量，TState[i]的含义就是第i个task当前的状态，包括分配给的WorkerID，状态以及开始执行的时间。TaskCh是一段有buffer的channel，用作Goroutines之间的数据传输，后续解释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitMap() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitReduce() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RPC通信，用于注册和退出Worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RegisterWorker(args *RegisterArgs, reply *RegisterReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> ExitWorker(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当一个worker申请一个Task时，register该Task的TaskState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RegisterTask(args *RequestArgs, task *Task) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过TaskID新建需要完成的Task并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> GetTask(NowTaskID <span class="type">int</span>) Task &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Schedule() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> TickSchedule() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RPC通信，用于Worker获取Task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> GetOneTask(args *RequestArgs, reply *RequestReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="comment">//RPC通信，用于Master接受Worker发送过来的信息，更新对应的TState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> ReportTask_m(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="comment">//RPC通信，用于Worker创建前询问Master是否完成全部的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> IsAllDone(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Master &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"></span><br><span class="line">m.mu = sync.Mutex&#123;&#125;</span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.files = files</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nReduce &gt; <span class="built_in">len</span>(files) &#123;</span><br><span class="line">m.TaskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, nReduce)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.TaskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="built_in">len</span>(files))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.InitMap()</span><br><span class="line"><span class="keyword">go</span> m.TickSchedule()</span><br><span class="line"></span><br><span class="line">m.server()</span><br><span class="line"><span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用MakeMaster新建一个Master，并构建一个有buffer的TaskChannel，用作存放需要发送给Worker的Task。</li><li>接着初始化Map，设置一下相关的参数</li><li>TickSchedule开始周期性调度全部任务，该函数主要实现是利用for循环，在不是ExitPhase的情况下周期性调用Schedule</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Schedule() &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.Phase == ExitPhase &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.Phase == WaitPhase &#123;</span><br><span class="line"><span class="keyword">if</span> m.ExitWorkers == m.TotalWorkers &#123;</span><br><span class="line">m.Phase = ExitPhase</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AllDone := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> m.Tstate &#123;</span><br><span class="line"><span class="keyword">switch</span> task.Status &#123;</span><br><span class="line"><span class="keyword">case</span> TaskReady:</span><br><span class="line">            AllDone = <span class="literal">false</span></span><br><span class="line">m.TaskCh &lt;- m.GetTask(idx)</span><br><span class="line">m.Tstate[idx].Status = TaskQueue</span><br><span class="line"><span class="keyword">case</span> TaskQueue:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">case</span> TaskRunning:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">            <span class="comment">// deal with crash</span></span><br><span class="line"><span class="keyword">case</span> TaskDone:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">case</span> TaskError:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> AllDone &#123;</span><br><span class="line"><span class="keyword">if</span> m.Phase == MapPhase &#123;</span><br><span class="line">m.InitReduce()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.Phase = WaitPhase</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">            <span class="comment">// fake task...</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Schedule的大体框架如上，首先Master在调度之前判断一下自身的状态，wait状态是Master已经调度完全部任务了，向所有还存活的Worker发送一个伪任务，告诉他们可以退出了，其余还存活的Worker一直在不停的接受任务，这时收到Master发送过来的fake task后，向Master发送已退出的消息然后退出，Master接收到全部退出消息后，将Phase改为ExitPhase然后退出。<br>中间的for循环遍历TaskState，将准备好的任务发送到TaskChannel，来让Worker接收。</p><h4 id="Worker">Worker</h4><p>首先定义worker结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">workerID <span class="type">int</span></span><br><span class="line">mapf     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue</span><br><span class="line">reducef  <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker的构建主要是通过Worker function</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">w := worker&#123;</span><br><span class="line">mapf:    mapf,</span><br><span class="line">reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := ReportArgs&#123;&#125;</span><br><span class="line">reply := ReportReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">call(<span class="string">&quot;Master.IsAllDone&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> reply.AllFinished &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;all done, no more client\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.Register()</span><br><span class="line">w.run()</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker %d exit normally\n&quot;</span>, w.workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断一下Master是否分配完了全部的工作，否则就进行worker的注册和执行，Register主要通过RPC通信来和Master通信获取可用的workerID，run用来执行构建好的worker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">task := w.RequestTask()</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker %d get task %d, TaskPhase==%d\n&quot;</span>, w.workerID, task.ID, task.Phase)</span><br><span class="line"><span class="keyword">if</span> task.Phase == ExitPhase &#123;</span><br><span class="line">w.Exit()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.Phase == WaitPhase &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">w.doTask(task)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以开多个窗口同时跑多个worker，下面的延时防止worker执行太快，</span></span><br><span class="line">        <span class="comment">// 其他worker来不及执行</span></span><br><span class="line"><span class="comment">// time.Sleep(3 * time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run函数是worker中需要重点关注的函数，内部使用一个for循环来不断请求Master获得空闲的Task，此处的RequestTask也是通过RPC通信进行数据的获取。</p><ul><li>如果当前task处于ExitPhase，则调用Exit向Master进行RPC通信，告诉Master此Worker已退出。</li><li>如果当前task处于WaitPhase，说明当前Master无任务分配，让Worker睡眠一段时间后重新请求。</li></ul><p>如果当前任务可执行，则调用doTask进行任务的执行，doTask流程如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doTask(task Task) &#123;</span><br><span class="line"><span class="keyword">switch</span> task.Phase &#123;</span><br><span class="line"><span class="keyword">case</span> MapPhase:</span><br><span class="line">w.doMap(task)</span><br><span class="line"><span class="keyword">case</span> ReducePhase:</span><br><span class="line">w.doReduce(task)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;wrong phase&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RPC设计">RPC设计</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisterArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RegisterReply <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Task_ *Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Done     <span class="type">bool</span></span><br><span class="line">TaskID   <span class="type">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReportReply <span class="keyword">struct</span> &#123;</span><br><span class="line">AllFinished <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Register RPC，不需要worker传递参数给master，只需要master把当前可用的workerID 回复给worker即可。<br>对于Request RPC，worker需要传递给master自己的workerID，让master可以更新自己对应的TState中的任务，明确该分配给了了哪个worker，并更新状态，master回复给worker对应的task即可。<br>对于Report RPC，合并了三种操作，一种是刚调用Worker时询问Master是否分配完了全部的任务，一种是完成一个Task后向Master汇报该任务已完成，最后一种是向Master汇报该worker已退出。</p><h4 id="doMap">doMap</h4><p>Master把收到的全部文件设置为一个个的Task，状态保存在TState中，每次每个worker调用doMap就从TaskCh中取出一个Task任务执行mapf（大概就是对一个具体的file做Map操作，返回的键值对仿照mrsequential.go暂时保存到kva中），遍历kva，利用ihash函数将kv.Key对应的Value哈希到对应的桶中（可以使用intermediate[]表示桶的集合，大小为nReduce）<br>最后遍历桶，将各个桶中的数据写入中间文件，中间文件的命名可以使用mr-mapID-bucketID，写入出错或者写入成功都需要向Master call RPC进行通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doMap(task Task) &#123;</span><br><span class="line"><span class="comment">// get filename and content</span></span><br><span class="line">kva := w.mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"></span><br><span class="line">intermediate := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">bucketID := ihash(kv.Key) % task.NReduce</span><br><span class="line">intermediate[bucketID] = <span class="built_in">append</span>(intermediate[bucketID], kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bucketID, kva := <span class="keyword">range</span> intermediate &#123;</span><br><span class="line">oname := Map2ReduceFileName(task.ID, bucketID)</span><br><span class="line">ofile, err := os.Create(oname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(ofile)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ofile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doReduce">doReduce</h4><p>一个具体的Reduce Task是将上面Map生成的中间全部文件mr-i-taskID( 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">\lt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> NMap )，集合并做reducef操作，保存到最终文件mr-out-taskID中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doReduce(task Task) &#123;</span><br><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span>; idx &lt; task.NMap; idx++ &#123;</span><br><span class="line">filename := Map2ReduceFileName(idx, task.ID)</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := maps[kv.Key]; !ok &#123;</span><br><span class="line">maps[kv.Key] = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">maps[kv.Key] = <span class="built_in">append</span>(maps[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> key, values := <span class="keyword">range</span> maps &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, fmt.Sprintf(<span class="string">&quot;%v %v\n&quot;</span>, key, w.reducef(key, values)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(MergeName(task.ID), []<span class="type">byte</span>(strings.Join(res, <span class="string">&quot;&quot;</span>)), <span class="number">0600</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTask_w(task, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/test.GIF" alt="test" title="test"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html%5D&quot;&gt;Lab 1&lt;/a&gt;实验要求并熟悉基础代码，了解Go中的RPC通信。&lt;br&gt;
Lab环境的配置过程中可能会出现若干问</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
