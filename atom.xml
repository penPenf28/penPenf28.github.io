<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hongwen Xin&#39;s Blog</title>
  
  
  <link href="https://penpenf28.github.io/atom.xml" rel="self"/>
  
  <link href="https://penpenf28.github.io/"/>
  <updated>2023-10-13T02:15:46.781Z</updated>
  <id>https://penpenf28.github.io/</id>
  
  <author>
    <name>Hongwen Xin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git常见命令&amp;&amp;流程</title>
    <link href="https://penpenf28.github.io/2023/10/13/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%A8%8B/"/>
    <id>https://penpenf28.github.io/2023/10/13/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%A8%8B/</id>
    <published>2023-10-13T02:13:23.000Z</published>
    <updated>2023-10-13T02:15:46.781Z</updated>
    
    <content type="html"><![CDATA[<p>个人自用</p><ul><li>git clone 仓库</li><li>git checkout -b my-feature<ul><li>切换到需要修改的分支</li></ul></li><li>修改代码</li><li>git diff<ul><li>查看当前修改后的代码与原来my-feature中的代码有哪些区别</li></ul></li><li>git add xxx<ul><li>将代码添加到暂存区</li></ul></li><li>git commit -m “xxx”<ul><li>[Feature]: New module or features.</li><li>[Bugfix]: Fix something.</li><li>[Refactor]: Style check.</li></ul></li><li>git push origin my-feature<ul><li>将本地my-feature分支推送到remote的my-feature分支，如果没有则自动创建</li></ul></li></ul><hr><ul><li>push完成后，准备合并branch到main中（这个过程是pull request， PR）</li><li>squash and merge</li><li>删除remote（主仓库）中的my-feature</li><li>git branch -D my-feature（一般不删除）<ul><li>删除local branch</li></ul></li><li>git pull origin master<ul><li>拉去主仓库中的最新更新</li></ul></li><li>结束</li></ul><hr><ul><li>如果remote main代码有更新</li><li>git checkout main</li><li>git pull origin master<ul><li>把远端的main同步到local的main中</li></ul></li><li>git checkout my-feature</li><li>git rebase main<ul><li>把my-feature暂时丢弃，将最新的main进行更新，然后再把添加my-feature的修改</li><li>有可能出现rebase conflict，手动选择你想要的代码</li><li>然后git rebase --continue</li></ul></li><li>进行完rebase后，git push -f origin my-feature<ul><li>由于进行了rebase，需要加上-f，表示force，强行push</li></ul></li></ul><hr><p>创建自己的新仓库然后更新代码</p><ul><li>首先安装git，添加ssh，配置git信息</li><li>使用<ul><li>git remote add origin <a href="https://github.com/repo_name/proj_name.git">https://github.com/repo_name/proj_name.git</a> 来关联远程仓库</li><li>如果之前关联过的</li><li>git remote set-url origin <a href="https://github.com/repo_name/proj_name.git">https://github.com/repo_name/proj_name.git</a></li><li>使用上面的重新关联</li></ul></li><li>push代码可能会出现无权限错误，用下面的token法解决<a href="https://blog.csdn.net/yjw123456/article/details/119696726">https://blog.csdn.net/yjw123456/article/details/119696726</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人自用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git clone 仓库&lt;/li&gt;
&lt;li&gt;git checkout -b my-feature
&lt;ul&gt;
&lt;li&gt;切换到需要修改的分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改代码&lt;/li&gt;
&lt;li&gt;git diff
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="Note" scheme="https://penpenf28.github.io/categories/Note/"/>
    
    
    <category term="Git" scheme="https://penpenf28.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab2-Raft-Part-2C&amp;&amp;2D</title>
    <link href="https://penpenf28.github.io/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/"/>
    <id>https://penpenf28.github.io/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/</id>
    <published>2023-10-12T13:04:05.000Z</published>
    <updated>2023-10-12T13:23:38.892Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html">Lab 2</a>Part 2C &amp;&amp; 2D相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="Part-2C">Part 2C</h3><h4 id="2C实验说明">2C实验说明</h4><ul><li>在raft每次更新重要信息后，对这些信息进行持久化保存</li><li>Test中某个server crash掉后，重新启动可以通过先前保存的持久化数据进行恢复</li></ul><h4 id="设计概述">设计概述</h4><p>在Part 2B实现的较为完备的情况下，Part 2C是比较简单的，只需要根据提示完成persist(), readPersist()函数，并在Make初始化过程中调用readPersist，关键信息更新时调用persist即可。<br>架构图可继续参考<a href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/">前文</a>。</p><h4 id="实现">实现</h4><p>根据论文中提供的信息，我们需要对term, votedFor, log进行持久化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save Raft&#x27;s persistent state to stable storage,</span></span><br><span class="line"><span class="comment">// where it can later be retrieved after a crash and restart.</span></span><br><span class="line"><span class="comment">// see paper&#x27;s Figure 2 for a description of what should be persistent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.term)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore previously persisted state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"><span class="keyword">var</span> term <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> log []*LogEntry</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;term) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;log) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;readPersist error&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.term = term</span><br><span class="line">rf.votedFor = votedFor</span><br><span class="line">rf.log = log</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要server中这些变量发生变化，调用persist()保存信息即可，在这里的持久化并不是保存到disk上，而是通过persist()类保存在内存中，Test中仅仅crash server，并没有crash掉server 对应的persister，以此实现信息的持久化，实际的工程中不会这么去做。</p><h4 id="注意">注意</h4><ul><li>注意<a href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/">前文</a>中的Figure 8问题，如果没有考虑完全会在2C中报错</li></ul><h3 id="Part-2D">Part 2D</h3><h4 id="2D实验说明">2D实验说明</h4><ul><li>raft server随着运行时间越来越长，保存的日志会越来越多，为了节约空间会做compaction(压缩)操作</li><li>压缩过程是将某一个状态之前的日志条目压缩为snapshot</li><li>当某个server落后于leader，且leader中该server的nextIndex所指示的log entry已经被leader压缩了，需要使用leader中的snapshot来更新server</li></ul><h4 id="设计概述-2">设计概述</h4><h5 id="snapshot设计">snapshot设计</h5><p><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/snapshot.png" alt="snapshot" title="snapshot"></p><ul><li>snapshot需要保存的信息<ul><li>LastIncludedIndex: Snapshot最后一个log entry的index，这个字段并不是real index，real index = LastIncludedIndex + logIndex，参考下图<ul><li><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/realIndex.png" alt="realIndex" title="realIndex"></li></ul></li><li>LastIncludedTerm: Snapshot最后一个log entry的term</li><li>MachineState(Data): Snapshot中机器的快照数据</li></ul></li><li>需要实现的函数<ul><li>Snapshot()</li><li>RPC相关，sendInstallSnapshot(), InstallSnapshot()<ul><li>当leader发现某个server nextIndex已经被压缩在快照中，没法通过正常的AppendEntriesRPC进行同步，需要编写相关的RPC使得leader向集群发送对该server安装leader Snapshot的请求，并传递相关的参数</li></ul></li><li>CondInstallSnapshot(), 由集群调用，对目标server安装Snapshot</li></ul></li></ul><h5 id="架构图">架构图</h5><p><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/structure.png" alt="structure" title="structure"></p><h5 id="整体流程">整体流程</h5><ul><li>如果当前server中log数据量超过存储极限，触发Snapshot(m.CommandIndex, w.Bytes())，触发过程发生在config.go中<ul><li>传入参数为m.CommandIndex, w.Bytes()<ul><li>m.CommandIndex 表示一直压缩到logIndex == m.CommandIndex的log entry为止</li><li>w.Bytes() 为传入的snapshot</li></ul></li></ul></li><li>如果当前leader在向其他follower复制日志(Replicate)的过程中发现某follower缺失log，且该follower对应nextIndex的log entry已经被leader压缩进snapshot中了，这时需要leader需要调用sendInstallSnapshot(), InstallSnapshot()来对该follower实现snapshot拷贝，然后该follower在下一个周期再进行正常的Replicate操作<ul><li>简单来说</li><li>leader发现某follower nextIndex对应的log缺失</li><li>发送包括LastIncludedIndex，LastIncludedTerm，Data等信息作为args的InstallSnapshotRPC</li><li>对应的follower收到InstallSnapshotRPC，根据传输过来的参数执行CondInstallSnapshot()，进行snapshot的安装</li></ul></li></ul><h4 id="实现-2">实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>)</span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>遍历自身的log，通过index找到对应的log entry，丢弃该log之前的全部log，并保存自身重要信息和snapshot</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallsnapshotArgs, reply *InstallsnapshotReply)</span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>判断args.Term是否小于rf.term<ul><li>小于说明leader失去时效性，解锁直接返回即可</li></ul></li><li>根据args更新自身term和state等相关信息，解锁</li><li>单独开一个协程向rf.applyCh发送installSnapshot的相关参数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.applyCh &lt;- ApplyMsg&#123;</span><br><span class="line">SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">Snapshot:      args.Data,</span><br><span class="line">SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">CommandValid:  <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CondInstallSnapshot(lastIncludedTerm <span class="type">int</span>, lastIncludedIndex <span class="type">int</span>, snapshot []<span class="type">byte</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure><ul><li>流程<ul><li>获取锁</li><li>判断lastIncludedIndex和rf.commitIndex<ul><li>小于，说明已经有更新的snapshot了，直接返回false</li></ul></li><li>判断lastIncludedIndex与rf.LogTail().Index的关系<ul><li>大于等于，只保留第一个空的占位log entry</li><li>小于保留lastIncludedIndex之后的log entry</li></ul></li><li>更新第一个占位log entry( rf.log[0] )的Index=lastIncludedIndex，Term=lastIncludedTerm，Command=nil</li><li>更新rf.commitIndex = lastIncludedIndex，rf.lastApplied = lastIncludedIndex</li><li>SaveStateAndSnapshot</li><li>return true</li></ul></li></ul><h4 id="测试">测试</h4><p>编写脚本测试500次，全部通过。<br><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/test.png" alt="test" title="test"><br>整个lab 2单次test用时约为5min40s。<br><img src="/2023/10/12/MIT6-824-2021-Lab2-Raft-Part-2C-2D/time.png" alt="time" title="time"></p><h4 id="注意-2">注意</h4><ul><li>Snapshot()中直接对rf.log = rf.log[index:]进行日志丢弃是不合理的 ，go的切片机制导致截取slice时，不会创建新的数组，只是简单的改变了引用的范围，前面的内容不会被gc进行回收，可以通过append方法创建新的数组，确保之前的底层数组会被回收</li></ul><h3 id="参考内容-致谢">参考内容 &amp;&amp; 致谢</h3><ul><li><a href="https://space.bilibili.com/61981458">戌米的论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-locking.txt">raft-locking.txt</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-structure.txt">raft-structure.txt</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li><li><a href="https://zhuanlan.zhihu.com/p/543989771">十一的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/463144886">谭新宇的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/369989974">多颗糖的知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html&quot;&gt;Lab 2&lt;/a&gt;Part 2C &amp;amp;&amp;amp; 2D相关实验要求并熟悉基础代码。&lt;br&gt;
本文只提供相关实现思路，</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6-824-2021-Lab2-Raft-Part-2B</title>
    <link href="https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/"/>
    <id>https://penpenf28.github.io/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/</id>
    <published>2023-10-10T07:00:45.000Z</published>
    <updated>2023-10-12T13:24:48.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从本次lab改用了2021版本的实验，后续的内容更加丰富，并对lab 2a的代码进行了重构，放弃了leader candidate follower明确划分的模式</p></blockquote><p>阅读本文前请先仔细阅读<a href="http://nil.csail.mit.edu/6.824/2021/labs/lab-raft.html">Lab 2</a>Part 2B相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="2B实验说明">2B实验说明</h3><ul><li>实现leader和follower之间的log entries的插入和更新</li><li>保证leader和follower之间的log一致</li></ul><h3 id="Test分析">Test分析</h3><p>在test构建系统的过程中调用了Make函数，其中applyCh是raft向系统传送msg的通道，用来更新cfg中的各个raft中的logs信息，应用指令(apply)可以看做向applyCh中写入信息。<br>后续的test通过检查cfg中的log是否一致来判断编写的程序是否正确。</p><ul><li>cfg.nCommitted(index)返回两个参数，1多少个server认为编号为index的log entry被commited了，2被commited的命令</li><li>cfg.ones()在十秒内遍历全部的server，找到leader并Start（启动一个命令），返回该命令的log index，当前的term和是否是leader，然后检查在2s之内这个命令是否被成功提交给大多数server</li><li>rf.Start()的作用是启动新日志写入</li><li>cfg.crash1(i)直接kill掉对应的server</li><li>cfg.disconnect(i)将第i个server从集群系统中断开连接，但是server本身并没有被kill掉</li><li>在leader接收到超过半数的follower commit了对应的log，leader自身开始apply 对应的log，leader apply后通过心跳再提示follower apply对应的log，log一致性检查在cfg.applier中</li></ul><h3 id="设计概述">设计概述</h3><h4 id="架构图">架构图</h4><p><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/structure.png" alt="structure" title="structure"></p><h4 id="结构说明">结构说明</h4><ul><li>通过Make在初始化时创建四个后台协程（其实是3+n个，DoReplicate的数量取决于集群中server的数量）<ul><li>DoElection负责选举</li><li>DoHeartbeat负责心跳</li><li>DoApply负责向集群apply日志</li><li>DpReplicate负责leader与follower之间的日志同步</li></ul></li><li>日志同步的主要流程<ul><li>leader收到客户端指令后(Start)，将指令作为一个新条目（entry）追加到日志中<ul><li>一条LogEntry有三个参数：cmd-指令，term-指令的任期号，index-日志号。</li></ul></li><li>leader通过AppendEntries RPC并行的发送日志到follower，当有超过半数的follower回复后(commit)，leader就可以在本地执行该指令(apply)并把结果返回给客户端。</li><li>注意区别commit和apply，commit是指确定日志已经复制到半数节点，而apply是日志应用到状态机，因此可以理解为applyIndex&lt;=commitIndex</li></ul></li></ul><h4 id="分析">分析</h4><p>整个过程中follower可能会和leader无法保持一致如下图所示</p><ul><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/situation.png" alt="situation" title="situation"></li><li>三类原因以及解决方式<ul><li>follower由于某些延误没有给leader响应，leader会不断重发追加条目请求（AppendEntries RPC），哪怕leader已经回复了客户端（日志已经apply）</li><li>follower崩溃后恢复，这时Raft追加条目的一致性检查<ul><li>一致性检查：leader在每一个发往follower的追加条目RPC中，放入前一个日志条目的索引位置（prevLogIndex）和任期号（prevLogTerm），如果follower在他的日志中找不到前一个日志，follower会拒绝此日志，leader会重新再发送前一个日志，这样逐渐向前定位到follower第一个缺失的日志</li></ul></li><li>leader宕机，崩溃的leader可能复制了日志到部分follower，而新选择的leader可能不具备这些日志，这样导致部分follower中的日志和新leader的日志不相同<ul><li>Raft在这种情况下，leader会强制follower复制他的日志来解决不一致的问题</li><li>两者冲突的日志会被新的leader日志覆盖</li></ul></li></ul></li><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/RPC1.png" alt="RPC1" title="RPC1"></li><li>如果leaderCommit&gt;commitIndex，则commitIndex=min(leaderCommit, index of last new entry)</li></ul><p>安全性相关问题</p><ul><li>leader宕机：选举限制<ul><li>一个follower落后leader若干日志，但是没有遗漏整个任期</li><li>下次选举中，仍然有可能当选leader，当选新leader后永远无法补上之前缺失的那部分日志，造成状态机之间的不一致</li><li>增加一个限制，确保被选出来的leader一定包含之前各任期内所有被提交的日志条目</li><li>通过RequestVote RPC后俩参数<ul><li><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/RPC2.png" alt="RPC2" title="RPC2"></li><li>如果投票者自己的日志比candidate还新，他会拒绝掉该投票请求</li></ul></li><li>通过比较两份日志中最后一条日志条目的索引和任期号来定义谁的日志比较新</li><li>任期号不同，大的新</li><li>任期号相同，日志长的新</li></ul></li><li>leader宕机：新leader是否提交之前任期内的日志条目<ul><li>一旦当前任期内某个日志条目已经存储到过半服务器节点上，leader就知道当前日志可以被提交了</li><li>follower的提交如何被触发？raft中的提交为单点提交<ul><li>通过AppendEntries RPC中的leaderCommit 参数，表示leader提交到那个日志了，从而自己也可以应用提交到这个日志</li></ul></li><li>raft永远不会通过计算副本数目的方式来提交之前任期内的日志条目，只有自己任期内的日志才能通过计算副本数目来提交，因为可以确认自己当前的任期号是最大的</li></ul></li><li>follower和candidate宕机<ul><li>如果这俩宕机，后续发送给他们的RPC都会失败</li><li>raft通过无限的重试来处理这种失败，如果崩溃的机器重启，那么这些RPC就会成功完成</li></ul></li></ul><p>Test中的Figure 8问题<br>解释可以参考<a href="https://zhuanlan.zhihu.com/p/369989974">https://zhuanlan.zhihu.com/p/369989974</a><br>解决方式</p><ul><li>leader只能够提交自己任期内的log entry，禁止提交非自己任期内的log entry</li></ul><h3 id="实现">实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</span><br></pre></td></tr></table></figure><ul><li>Success = false的情况<ul><li>args.Term &lt; rf.term</li><li>log不匹配</li></ul></li><li>流程<ul><li>获取锁</li><li>检查args.Term和rf.Term<ul><li>如果args.Term &lt; rf.term则失败返回，反之则更新心跳，Term和state</li></ul></li><li>更新term为args.Term，更新state为Follower</li><li>进行日志匹配判定，不匹配则失败返回冲突的index，匹配则进行log合并，持久化</li><li>判定是否需要更新commitIndex<ul><li>如果需要更新则使用min(args.LeaderCommit, rf.LogTail().Index)更新，防止日志回滚</li><li>广播apply命令</li></ul></li><li>success = true</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</span><br></pre></td></tr></table></figure><ul><li>success = false 的情况<ul><li>args.Term &lt; rf.term</li><li>投过票了</li><li>args中的日志旧</li></ul></li><li>流程<ul><li>获取锁</li><li>检查args.Term和rf.Term<ul><li>如果args.Term &lt; rf.term则失败返回</li></ul></li><li>更新term为args.Term，更新state为Follower</li><li>如果检查条件为可以投票（  (没有投过票||投票给同一个人) &amp;&amp; args的日志新  ）<ul><li>更新心跳，更新rf.voteFor，更新success，持久化</li></ul></li><li>不可以投票则success=false返回</li></ul></li><li>如何确定args中log新于rf中log<ul><li>判断args log尾部entry的Term和rf log尾部entry的Term<ul><li>大于则新</li><li>等于则判断尾部的entry Index，大于等于则新</li><li>其余为旧</li></ul></li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> DoElection()</span><br></pre></td></tr></table></figure><p>在Make阶段创建的后台协程，只要rf没有被kill掉就一直运行<br>流程</p><ul><li>获取锁</li><li>判断当前是否是leader，如果是则释放锁continue</li><li>判断接受心跳时间是否超过ElectionTimeout，如果没有，则解锁进行下一次循环</li><li>超时，遍历其他server投票请求投票RPC进行选举<ul><li>选举成功（收到成功的回复数 &gt; num of server / 2），更新自身状态为leader，初始化自身nextIndex和matchIndex，并BroadcastHeartbeat广播一次心跳</li><li>完成上述操作后继续Election</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> BroadcastHeartbeat()</span><br></pre></td></tr></table></figure><p>广播心跳</p><ul><li>使用go协程向其他server 进行Replicate操作（复制日志）</li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Replicate(server <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>复制日志，主要是获取相关参数，传入Sync进行<br>流程</p><ul><li>获取锁</li><li>判断当前状态是否是leader，只有leader才可以进行Replicate操作</li><li>获取当前rf.nextIndex[server]，将位于nextIndex到rf.LogTail之间的logEntry作为参数Entries构建AppendEntriesArgs</li><li>解锁后进行Sync操作</li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Sync(server <span class="type">int</span>, args *AppendEntriesArgs) </span><br></pre></td></tr></table></figure><p>同步操作，通过sendAppendEntries来实现leader和follower之间的日志同步<br>流程</p><ul><li>向server发送sendAppendEntries并获得reply AppendEntriesReply</li><li>获取锁</li><li>判断rf.term 是否等于 args.Term，不相等说明leader已经不是leader，解锁并返回</li><li>判断rf.term和reply.Term，若reply.Term &gt; rf.term，说明leader也已经过期，重设rf的term和state</li><li>reply.Success == true<ul><li>len(args.Entries) == 0，说明是发送的是单纯心跳，不用做任何处理直接返回</li><li>获取logTailIndex := LogTail(args.Entries).Index，以此更新nextIndex和matchIndex</li><li>遍历从rf.commitIndex到logTailIndex，找到最大的超过半数节点match的Index，以此Index更新rf.commitIndex，因为只有在大多数节点都复制了日志后，且日志的任期和leader的任期一致，才能提交日志（test中的figure 8）</li><li>当rf.commitIndex &gt; rf.lastApplied时，进行applyCond.Broadcast()，提醒DoApply协程需要进行apply操作了</li></ul></li><li>reply.Success == false<ul><li>更新rf.nextIndex 和 rf.matchIndex</li></ul></li></ul><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> DoApply(applyCh <span class="keyword">chan</span> ApplyMsg)</span><br></pre></td></tr></table></figure><p>后台协程，用来apply log日志，通过条件变量rf.applyCond来实现协程的唤醒<br>流程</p><ul><li>获取rf.applyCond.L.Lock() （在go中，条件变量调用wait方法时必须要持有锁L.Lock()）</li><li>for循环，如果rf kill了则退出并解除相关锁<ul><li>判断当前是否需要apply （rf.lastApplied &lt; rf.commitIndex可以认为需要apply）</li><li>如果不需要则调用wait方法休眠</li><li>需要apply，则获取需要apply的log即rf.GetLogAtIndex(rf.lastApplied)，以该log的信息为参数传入到applyCh</li></ul></li></ul><h3 id="测试">测试</h3><p>编写脚本测试500次，全部通过。<br><img src="/2023/10/10/MIT6-824-2021-Lab2-Raft-Part-2B/test.png" alt="test" title="test"></p><h3 id="注意">注意</h3><ul><li>尽量不要简单的将log entry在rf.log中的位置直接作为index，推荐将index单独编入entry结构体中，不然后续的lab 2C 2D会非常痛苦，同理不推荐直接根据entry在log中的位置进行各种操作，可以编写根据logIndex获取对应log entry的函数来进行处理</li><li>需要仔细理解Figure 8的含义，注意在更新commitIndex时日志回滚的问题</li></ul><h3 id="参考内容-致谢">参考内容 &amp;&amp; 致谢</h3><ul><li><a href="https://space.bilibili.com/61981458">戌米的论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-locking.txt">raft-locking.txt</a></li><li><a href="http://nil.csail.mit.edu/6.824/2021/labs/raft-structure.txt">raft-structure.txt</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li><li><a href="https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/">Sworduo’s Blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/543989771">十一的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/463144886">谭新宇的知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/369989974">多颗糖的知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从本次lab改用了2021版本的实验，后续的内容更加丰富，并对lab 2a的代码进行了重构，放弃了leader candidate follower明确划分的模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 2023 Spring Proj1 Buffer Pool</title>
    <link href="https://penpenf28.github.io/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/"/>
    <id>https://penpenf28.github.io/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/</id>
    <published>2023-08-27T10:18:26.000Z</published>
    <updated>2023-10-10T06:36:37.717Z</updated>
    
    <content type="html"><![CDATA[<h1>实验说明</h1><ul><li>实验主页<a href="https://15445.courses.cs.cmu.edu/spring2023/project1/">https://15445.courses.cs.cmu.edu/spring2023/project1/</a></li><li>本次实验主要完成buffer pool（缓存池）<ul><li>缓存池是用来在主存和磁盘之间移动物理页（physical page）的工具</li><li>该部分对于数据库管理系统（DBMS）的其他部分来说透明，举例来说，DBMS要求使用一个独有的page_id，buffer pool则帮DBMS获取这个page，不需要知道这个page一开始是否在主存中或者是从disk中取到主存再返回给DBMS的</li></ul></li></ul><h1>Task #1 - LRU-K Replacement Policy</h1><p>Task分析<br>需要使用LRU-K策略来实现frame的换入和换出。<br>普通的LRU策略是当replacer的缓存池的大小满了（这里是curr_size == replacer_size）后需要将其中最长时间没有访问的给替换出去。<br>LRU-K相对于LRU缓解了缓存污染的问题。</p><blockquote><p>LRU缓存污染：偶发性的，周期性的批量操作会导致LRU cache的命中率急剧下降，这时缓存中的数据大部分都不是热点数据<br>如何确定K？K增大，命中率会更高，但是适应性差（清楚一个缓存需要大量的数据访问，一般选择LRU-2，LRU == LRU-1）</p></blockquote><p>LRU-K Replacer在本次Task中的实现如下</p><ul><li>维护一个unordered_map&lt;frame_id_t, std::shared_ptr<LRUKNode>&gt; node_store_，用来记录全部的节点</LRUKNode></li><li>维护两个list<ul><li>std::list&lt;std::shared_ptr<LRUKNode>&gt; history_list_; 用来存放访问的节点，但是访问次数小于K次，list的排列顺序按照FIFO的规则，list尾部表示最新访问的数据，头部表示最旧访问的数据</LRUKNode></li><li>std::list&lt;std::shared_ptr<LRUKNode>&gt; cache_list_; 真正需要缓存的节点，访问次数大于等于K次，list的排列顺序遵守LRU-K的规则，参照Node元素中timestamps的头部元素进行排列，按照从小到大的规则，list尾部表示头部元素最大的(最新的)</LRUKNode></li></ul></li><li><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/node_store.png" alt="node_store" title="node_store"></li><li>history_list_.size + cache_list_.size = curr_size</li><li>LRUNode表示一个frame在LRUKReplacer中的状态<ul><li>成员变量：frame_id，size k_（最多纪录前k_个访问时间），访问次数ref_count，是否可以evict，timestamps（数组，前k个访问时间）</li><li>同时每次访问frame时（RecordAccess），ref_count都需要自增</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRUKNode</span>() &#123;</span><br><span class="line">    k_ = <span class="number">0</span>;</span><br><span class="line">    fid_ = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = -1;</span></span><br><span class="line">    is_evictable_ = <span class="literal">true</span>;</span><br><span class="line">    ref_count_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUKNode</span>(<span class="type">size_t</span> k, <span class="type">frame_id_t</span> fid, <span class="type">size_t</span> access_time, <span class="type">bool</span> is_evictable, <span class="type">size_t</span> ref_count)</span><br><span class="line">: <span class="built_in">k_</span>(k), <span class="built_in">fid_</span>(fid), <span class="built_in">is_evictable_</span>(is_evictable), <span class="built_in">ref_count_</span>(ref_count) &#123;</span><br><span class="line">    timestamps_.<span class="built_in">push_back</span>(access_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUKNode</span>(<span class="type">const</span> LRUKNode &amp;other) &#123;</span><br><span class="line">    k_ = other.k_;</span><br><span class="line">    fid_ = other.fid_;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = other.last_seen_timestamp_;</span></span><br><span class="line">    timestamps_ = other.timestamps_;</span><br><span class="line">    is_evictable_ = other.is_evictable_;</span><br><span class="line">    ref_count_ = other.ref_count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetFrameId</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">frame_id_t</span> </span>&#123; <span class="keyword">return</span> fid_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetRefCount</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> ref_count_; &#125;</span><br><span class="line"><span class="comment">// auto GetLastSeenTimestamp() const -&gt; size_t &#123; return last_seen_timestamp_; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetFirstTimestamp</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> timestamps_.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IsEvictable</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> is_evictable_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IncRefCount</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123; ref_count_++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetTimestamp</span><span class="params">(<span class="type">size_t</span> timestamp)</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line">    <span class="comment">// last_seen_timestamp_ = timestamp;</span></span><br><span class="line">    timestamps_.<span class="built_in">push_back</span>(timestamp);</span><br><span class="line">    <span class="keyword">auto</span> first_timestamp = timestamps_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span> (timestamps_.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">        timestamps_.<span class="built_in">erase</span>(timestamps_.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first_timestamp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetFrameId</span><span class="params">(<span class="type">frame_id_t</span> fid)</span> -&gt; <span class="type">void</span> </span>&#123; fid_ = fid; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetK</span><span class="params">(<span class="type">size_t</span> k)</span> -&gt; <span class="type">void</span> </span>&#123; k_ = k; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SetEvictable</span><span class="params">(<span class="type">bool</span> is_evictable)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> is_same = is_evictable_ == is_evictable;</span><br><span class="line">    is_evictable_ = is_evictable;</span><br><span class="line">    <span class="keyword">return</span> is_same;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line"><span class="comment">// Remove maybe_unused if you start using them. Feel free to change the member variables as you want.</span></span><br><span class="line"></span><br><span class="line">[[maybe_unused]] <span class="type">size_t</span> k_;</span><br><span class="line">[[maybe_unused]] <span class="type">frame_id_t</span> fid_;</span><br><span class="line"><span class="comment">// [[maybe_unused]] size_t last_seen_timestamp_;</span></span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; timestamps_;</span><br><span class="line">[[maybe_unused]] <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> ref_count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRU-K的原理</p><ul><li>对一个frame访问时(RecordAceess)先搜索全部的节点node_store_<ul><li>如果存在，需要记录当前的current_timestamp，即插入到该LRUK节点的timestamp数组中，如果数组size&gt;k_，则pop掉最前面的元素，这时数组的头部元素就是前第k次访问时间。并将该节点的ref_count++</li><li>如果不存在，则新建一个LRUKNode，记录到node_store和history中（同时指向这个新建的LRUKNode）<ul><li>新加入的节点需要考虑当前需要全部元素的个数，如果curr_size == replacer_size，需要Evict掉一个节点<ul><li>Evict逻辑比较简单（只evict一个节点），分别从头到尾遍历history和cache（顺序一定是先history再cache），如果某个节点is_evictable，就把它从对应的list和node_store中erase掉</li></ul></li><li>新节点直接push_back到history尾部即可（history遵循FIFO规则），注意⚠️需要考虑k = = 1的情况，即新节点ref_count = = 1，在移入history之后又要立即移动到cache</li></ul></li></ul></li><li>如果当前节点ref_count==k，说明该节点现在在history中，达到了k次的访问次数，需要从histroy移动到cache中了<ul><li>因为是将history中的node移动到cache中，不涉及整体size大小的变化，也就不需要Evict cache</li><li>将该frame_id对应的node从history中erase</li><li>从cache_list的链表头开始遍历，比较链表节点中timestamps的头部元素和待插入的节点的timestamps的头部元素（前第k次访问时间），找到第一个比待插入节点大的链表节点（比待插入新），插入到该节点之前</li><li>通过这种操作，保证了cache_list遵循了LRU-K规则，cache最先淘汰的永远是链表头部节点</li></ul></li><li>如果当前节点ref_count&gt;k，说明该节点在访问之前就在cache中了，需要根据该节点的timestamps更新该节点在cache_list中的位置，更新规则同ref_count==k的插入规则</li></ul><p>关键点</p><ul><li>LRUNode对应每一个frame对应的node<ul><li>比较关键的是其中的timestamps_数组，用来存放每次访问的时间，数组大小最大为k，当访问数refcount&gt;=k时，把这个node从history移动到cache中真正缓存下来</li></ul></li><li>history中按照FIFO替换，cache中按照LRU-K替换</li><li>注意k==1的情况</li><li>当ref_count==k时不需要考虑size的变化，因为是history和cache之间的交互，不影响整体的size</li></ul><h1>Task #2 - Buffer Pool Manager</h1><p>Task分析<br>Task1中的replacer只是用来记录frame的使用情况，并不做具体的写入写出操作，Task2的buffer pool则需要完成具体的page的写入写出。<br>一个frame可以理解为一个实际的物理存储空间块，page表示的是逻辑上的存储，在DBMS的一整个生命周期中，page可以对应多个frame（同一时间一个page只能对应一个frame），映射关系通过NewPage构建。</p><p>Task2没有添加额外的成员变量，但是增加了一个成员函数FindFrame，各函数实现逻辑如下</p><ul><li>构造函数<ul><li>初始化时直接根据pool_size_，初始化Page* pages即缓存池</li><li>page_table_存放是的page_id到frame_id的映射</li><li>free_list_存放的是未使用的frame_id（0&lt;=id&lt;pool size），即未使用的实际上的物理frame</li></ul></li><li>增加了一个辅助函数FindFrame<ul><li>输入参数为frame_id_t *frame_id</li><li>先搜索free_list_，如果有空余的frame，那么给frame_id赋值并返回</li><li>如果没有空的frame，用replacer的Evict替换掉其中的一个frame，并将替换的frame的id保存到frame_id中，再从pages取出frame_id对应的page，如果该page dirty，则写入到disk中，然后将该page_id和frame_id的映射从page_table中清除</li></ul></li><li>NewPage<ul><li>找到一个可用的frame_id，使用该frame_id从pages中取出一页，对该页分配page_id，添加table映射，设置pin_count和replacer对于该frame的相关参数</li></ul></li><li>FetchPage<ul><li>从buffer pool中取出page_id对应的page</li><li>首先搜索page_id到frame_id的映射，保证当前page_id对应一个实际的物理frame<ul><li>如果有，则取出该frame_id对应的page，并设置pin_count和replacer</li><li>如果没有，则FindFrame，找到一个合适的物理frame，从磁盘上将该page_id的数据读取到对应的page中</li></ul></li></ul></li><li>UnpinPage<ul><li>输入为page_id和该page是否dirty</li><li>作用是解除page_id对应page的一次引用</li><li>首先是搜索该page_id是否有分配对应的物理frame，如果没有，返回false</li><li>如果有对应的frame，查看该page的pin_count<ul><li>如果小于等于0，说明已经没有数据在引用这个frame，直接返回false</li><li>如果大于0，则pin_count–，把dirty写入到page的is_dirty参数，如果解除这次引用后pin_count==0，还需要对replacer SetEvictable</li></ul></li></ul></li><li>FlushPage<ul><li>输入为page_id</li><li>将page_id对应的page写入到disk中，并更新dirty位</li><li>首先判断page_id是否合法</li><li>在page_table中搜索该page_id，判断是否分配frame<ul><li>如果没有分配，return false</li><li>如有分配，将frame_id对应的page写入到disk，并设置dirty位</li></ul></li></ul></li><li>FlushAllPages<ul><li>输入为空</li><li>遍历page_table，将全部的page都写入到disk中即可</li></ul></li><li>DeletePage<ul><li>输入为page_id</li><li>删除page_id对应的实际的page</li><li>首先遍历table，确定是否有分配实际的frame<ul><li>无，返回true</li><li>有，判断pin_count是否大于0，如果大于0，说明仍有数据引用这块page，因此不能删除，返回false</li></ul></li><li>确定这块page可以删除后<ul><li>分别在page_table清除映射，replacer清除frame，free_list_添加frame，Deallocate该page_id，Reset该page的memory，重置pin_count和dirty位，最后将该page_id设置为INVALID，return true</li></ul></li></ul></li></ul><h1>Task #3 - Read/Write Page Guards</h1><p>Task分析<br>在Task2的条件下，使用DBMS忘记调用UnpinPage可能会导致该page永远不会被Evict掉，会造成page在内存和磁盘之间来回的交换，大大影响系统性能，Task要求实现PageGuard相关成员来完成Page的使用安全性保证。<br>阅读代码后分析任务，主要是完成类的move的自定义构造函数和自定义操作符，类的Drop函数，类的析构函数，前两个Task实现清楚的话，Task3难度属于简单。</p><p>各函数实现细节如下<br>page_guard</p><ul><li>move构造函数<ul><li>将本类中的成员指向传入的右值</li><li>右值置空</li></ul></li><li>move=操作符<ul><li>如果本类和传入的右值地址相同直接返回</li><li>否则Drop掉本类当前的page</li><li>将本类中的成员指向传入的右值</li><li>右值置空</li></ul></li><li>Drop<ul><li>用来取消对当前page的引用</li><li>首先判断当前page是否为空，为空直接返回</li><li>UnpinPage，并置空当前的pageguard</li></ul></li><li>析构函数<ul><li>直接Drop</li></ul></li><li>Read和Write pageguard<ul><li>如果page存在，进行上述实现时需要释放lock</li></ul></li></ul><p>buffer_manager</p><ul><li>Fetch_R/W_Page时，如果page不空，需要上锁</li></ul><h1>Test</h1><ul><li>跑测试之前需要把DISABLE都删除<br><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/grade1.png" alt="grade1" title="grade1"></li></ul><p>leader board rank<br><img src="/2023/08/27/CMU15-445-2023-Spring-Proj1-Buffer-Pool/grade2.png" alt="grade2" title="grade2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实验主页&lt;a href=&quot;https://15445.courses.cs.cmu.edu/spring2023/project1/&quot;&gt;https://15445.courses.cs.cmu.edu/spring2023/proje</summary>
      
    
    
    
    <category term="Database" scheme="https://penpenf28.github.io/categories/Database/"/>
    
    
    <category term="CMU15-445" scheme="https://penpenf28.github.io/tags/CMU15-445/"/>
    
    <category term="Database" scheme="https://penpenf28.github.io/tags/Database/"/>
    
    <category term="C++" scheme="https://penpenf28.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 2023 Spring Proj0 C++ Primer</title>
    <link href="https://penpenf28.github.io/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/"/>
    <id>https://penpenf28.github.io/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/</id>
    <published>2023-08-24T16:32:23.000Z</published>
    <updated>2023-10-10T06:36:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1>实验说明</h1><ul><li>实验主页<a href="https://15445.courses.cs.cmu.edu/spring2023/project0/">https://15445.courses.cs.cmu.edu/spring2023/project0/</a></li><li>本次Proj主要完成copy-on-write trie前缀树</li><li>C++17</li></ul><p><img src="/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/cover.png" alt="structure" title="structure"></p><h1>Task #1 - Copy-On-Write Trie</h1><p>Task 1要求完成一个copy-on-write前缀树，需要学习一下相关C++17的语法以及智能指针的使用，学习完成后此任务难度不高。</p><h3 id="Get">Get</h3><p>Get函数主要是根据给定的key来查找是否有对应的value并返回，此部分不涉及copy-on-write。</p><ul><li>设置一个std::shared_ptr<const trienode> node = 根节点</const></li><li>遍历key的每一个字符c，如果可以从node的children中找到对应的child，那么令node = next_node，否则返回nullptr</li><li>遍历至最后一个节点，判断是否是value节点，使用dynamic_cast&lt;const TrieNodeWithValue<T> *&gt;进行强制的类型转换获取value并返回<ul><li>dynamic_cast 只适用于指针和引用类型，不能用于普通对象</li><li>dynamic_cast 在转换时，源类型必须至少含有一个虚函数，以确保运行时类型信息的存在</li><li>dynamic_cast 的转换只能在具有多态关系的类层次结构中进行</li></ul></T></li></ul><h3 id="Put">Put</h3><p>Put函数主要是将对应的key和value插入到前缀树中，在向下遍历的过程中，遇到已有的节点需要Clone一份新的节点。</p><ul><li>需要三个新的变量new_root和前后指针parent和child<ul><li>std::shared_ptr<TrieNode> new_root = this-&gt;root_ ? this-&gt;root_-&gt;Clone() : std::make_shared<TrieNode>(); 因为是从根节点开始向下遍历，如果根节点存在的话也需要Clone一份，不存在的话就新建。</TrieNode></TrieNode></li><li>这里向下遍历用到了前后指针的技巧parent和child，初始parent指向nullptr，child指向new_root</li></ul></li><li>通过遍历key的字符c向下遍历整个前缀树，如果当前parent的对应的孩子节点不为空，就需要copy(Clone)后赋值给child，并更新parent的children，然后令parent=child并继续下一轮迭代</li><li>遍历到最终字符时使用std::make_shared&lt;TrieNodeWithValue<T>&gt;(child-&gt;children_,std::make_shared<T>(std::move(value)));给最终的child赋值<ul><li>该代码作用是创建一个TrieNodeWithValue类型的指针，括号内是初始化TrieNodeWithValue的构造函数的参数列表，其中需要传入child-&gt;children_因为当前节点可能不是叶子节点，需要把它的孩子节点拷贝进来</li></ul></T></T></li><li>将最后更新的child节点更新到parent的children中，返回new_root构建的Trie即可(return Trie(new_root))</li></ul><h3 id="Remove">Remove</h3><p>Remove操作也需要用到copy-on-write思想，不能在原来的树上直接进行操作，考虑到如果当前节点是叶子节点，删除后他的parent的children为空，这时parent也需要删除，继续向上迭代，这种方式很容易联想到使用stack来回溯解决。</p><ul><li>初始化和Put中相同的三个变量，多加一个stack&lt;std::pair&lt;std::shared_ptr<TrieNode>, char&gt;&gt; stk，用来保存访问过的node，便于回溯</TrieNode></li><li>遍历key的字符c，遍历的过程中copy-on-write，并将遍历过的node加入到stack中<ul><li>如果找到空节点，说明要删除的节点根本不存在，直接return nullptr</li></ul></li><li>找到了需要删除的节点<ul><li>如果该节点没有孩子，直接将该节点置空</li><li>如果该节点有孩子，通过child = make_shared<TrieNode>(nxt-&gt;children_)删除掉value</TrieNode></li></ul></li><li>开始回溯<ul><li>不断的获取栈顶元素parent，如果child==nullptr，erase掉parent的children中的对应元素，如果此时parent为空，则也将parent置空，令child=parent</li><li>重复上述过程，直到stack空为止</li></ul></li></ul><h1>Task #2 - Concurrent Key-Value Store</h1><p>Task 2需要学习一下C++中mutex的使用，难度属于简单，lab设置为多个读者和一个写者。</p><h3 id="Get-2">Get</h3><ul><li>首先lock root并获取当前的root，随即释放掉lock，不要直接在持有锁的情况下遍历前缀树来获取value，这样会非常影响性能</li><li>用刚才获取的root调用Get方法并返回即可，</li></ul><h3 id="Put-2">Put</h3><ul><li>写者在Put过程中需要一直持有write_lock避免其他线程对临界区的访问</li><li>获取root的方式和Get相同，然后对root调用Put方法即可</li></ul><h3 id="Remove-2">Remove</h3><ul><li>流程和Put相同，只是调用的方法不同</li></ul><h1>Task #3 - Debugging</h1><p>配置vscode debug文件完成，具体参照<a href="https://www.youtube.com/watch?v=G9gnSGKYIg4">https://www.youtube.com/watch?v=G9gnSGKYIg4</a>。</p><ul><li>build项目，make trie_debug_test -j$(nproc)</li><li>将trie_debug_test配置到vscode的debug文件中</li><li>F5断点观察结果即可</li></ul><p>个人配置文件如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Use IntelliSense to learn about possible attributes.</span><br><span class="line">    // Hover to view descriptions of existing attributes.</span><br><span class="line">    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Debug&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/lab/build/test/trie_debug_test&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中program参数配置你想要debug的程序</li></ul><h1>Task #4 - SQL String Functions</h1><p>实现两个简单的Upper和Lower函数</p><ul><li>首先需要在string_expression.h中实现这两个函数<ul><li>根据expr_type_来选择哪一个函数，然后对函数进行实现</li></ul></li><li>然后在plan_func_call.cpp中对函数进行注册<ul><li>使用func_name返回对应实现的函数</li></ul></li></ul><h1>Test</h1><p><img src="/2023/08/25/CMU15-445-2023-Spring-Proj0-C-Primer/test.png" alt="test" title="test"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;实验主页&lt;a href=&quot;https://15445.courses.cs.cmu.edu/spring2023/project0/&quot;&gt;https://15445.courses.cs.cmu.edu/spring2023/proje</summary>
      
    
    
    
    <category term="Database" scheme="https://penpenf28.github.io/categories/Database/"/>
    
    
    <category term="CMU15-445" scheme="https://penpenf28.github.io/tags/CMU15-445/"/>
    
    <category term="Database" scheme="https://penpenf28.github.io/tags/Database/"/>
    
    <category term="C++" scheme="https://penpenf28.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 2020 Lab2 Raft Part 2A</title>
    <link href="https://penpenf28.github.io/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/"/>
    <id>https://penpenf28.github.io/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/</id>
    <published>2023-07-21T12:25:54.000Z</published>
    <updated>2023-10-10T06:56:00.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后续实验对此部分代码进行了重构，因此代码不具备参考性，仅适用于本次实验</p></blockquote><p>阅读本文前请先仔细阅读<a href="%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-raft.html%5D">Lab 2</a>Part 2A相关实验要求并熟悉基础代码。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="2A实验说明">2A实验说明</h3><ul><li>2A部分需要完成Raft系统中的leader election和heartbeats</li><li>保证系统中最多只有一个leader，如有特殊情况可以发生leader的取代</li><li>相关RPC的调用可以阅读labrpc文件夹中的代码</li></ul><h3 id="Test分析">Test分析</h3><p>代码编写完成后通过go test进行测试，可以理解为C艹中的单元测试，这里通过make_config构建起整个系统cfg。</p><ul><li>cfg中包括有多个raft对象，每个raft对象对应有自己的ClientEnd数组peers，表示自己与其他raft的连接，可以理解为传输数据的通道（通过RPC）</li><li>网络中各个raft初始化完成后通过connect进行raft之间的连接（对应RPC通信）</li><li>每个raft有三种state对应论文中的leader，candidate，follower</li><li>以计算机网络的视角来看，cfg.net对应网络层，ClientEnd对应传输层，raft对应应用层</li><li>整体Test系统构建流程<ul><li>make_config构建系统<ul><li>初始化若干个raft对象</li><li>将若干raft对象进行连接</li></ul></li><li>插入检查，宕机，sleep等操作</li><li>end</li></ul></li><li>第一个测试TestInitialElection2A首先是初始化整个系统，设置了3个raft对象，不进行fail操作，中间sleep一段时间检查你的系统是否稳定（即没有发生宕机的情况下你的leader是否可以稳定的一直发送心跳）</li><li>第二个测试TestReElection2A会在中间加入节点的disconnect，后续重新connect，考验设计系统的鲁棒性</li></ul><h3 id="设计概述">设计概述</h3><blockquote><p>实验大部分思路来自于<a href="https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/">https://sworduo.github.io/2019/06/04/MIT6-824-lab2-raft/</a> and <a href="https://zhuanlan.zhihu.com/p/543989771">https://zhuanlan.zhihu.com/p/543989771</a>，在此基础上进行修改，十分感谢！</p></blockquote><h4 id="结构说明">结构说明</h4><ul><li>每个raft通过Make函数来构建起单个的raft系统<ul><li>在Make中对raft中的参数进行初始化</li><li>实验要求Make立即返回，因此整个系统的运行应该放在一个goroutine中，这里设计了Schedule函数进行调度</li></ul></li><li>利用Schedule函数进行状态的变换（ follower&lt;-&gt;candidate&lt;-&gt;leader ）<ul><li>followerTick()<ul><li>follower在2a中考虑三种情况<ul><li>收到来自leader的心跳，继续follower状态</li><li>自己给其他candiadte投票，继续follower状态</li><li>超时，既没有收到心跳，也没有给别人投票，自己变为candidate状态</li></ul></li></ul></li><li>candidateTick()<ul><li>candidate需要考虑四种情况<ul><li>收到来自leader的心跳，切换到follower状态</li><li>自己给其他candiadte投票，切换到follower状态</li><li>自己赢得选举，切换到leader状态</li><li>选举超时，继续下一轮选举，保持candidate状态</li></ul></li></ul></li><li>leaderTick()<ul><li>leader需要考虑四种情况<ul><li>收到来自leader的心跳，切换到follower状态</li><li>自己给其他candiadte投票，切换到follower状态</li><li>收到的心跳reply中有大于自己term（任期），切换到follower状态</li><li>心跳计时到期，保持leader状态，开始下一轮心跳发送</li></ul></li></ul></li></ul></li><li>RPC相关（对应操作用颜色标注，红色表示心跳RPC，绿色表示投票RPC）<ul><li>心跳RPC  AppendEntries<ul><li>根据args更新自身raft对象中的参数并返回reply</li></ul></li><li>投票RPC  RequestVote<ul><li>根据args更新自身raft对象中的参数并返回reply</li></ul></li></ul></li></ul><h4 id="架构图">架构图</h4><p><img src="/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/structure.png" alt="structure" title="structure"></p><h3 id="具体实现">具体实现</h3><h4 id="Definition">Definition</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower  = <span class="number">0</span></span><br><span class="line">Candidate = <span class="number">1</span></span><br><span class="line">Leader    = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// heart_beat</span></span><br><span class="line"><span class="keyword">type</span> AppendEntryArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span></span><br><span class="line">LeaderId     <span class="type">int</span></span><br><span class="line">PrevLogIndex <span class="type">int</span></span><br><span class="line">PrevLogTerm  <span class="type">int</span></span><br><span class="line">Entries      []LogEntry</span><br><span class="line">LeaderCommit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AppendEntryReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term    <span class="type">int</span></span><br><span class="line">Success <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">ItemId <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的LogEntry在2A中暂时不用，其余定义按照paper编写即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    state <span class="type">int</span> <span class="comment">//当前的状态</span></span><br><span class="line">    electionTimeout *time.Timer <span class="comment">//选举时间定时器</span></span><br><span class="line"></span><br><span class="line">    currentTerm <span class="type">int</span>        <span class="comment">//当前的任期号</span></span><br><span class="line">    voteFor     <span class="type">int</span>        <span class="comment">//当前获得选票的候选人id</span></span><br><span class="line">    logEntries  []LogEntry <span class="comment">//日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</span></span><br><span class="line"></span><br><span class="line">    appendCh <span class="keyword">chan</span> *AppendEntryArgs <span class="comment">//leader发送的心跳</span></span><br><span class="line">    voteCh   <span class="keyword">chan</span> *RequestVoteArgs <span class="comment">//candidate发送的投票</span></span><br><span class="line">    l2fCh    <span class="keyword">chan</span> <span class="type">bool</span>             <span class="comment">//leader心跳收到比自己大的term，变为follower</span></span><br><span class="line"></span><br><span class="line">    heartBeatTimeOut <span class="type">int</span> <span class="comment">//1秒10次心跳</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>appendCh表示自己成功接收到来自于leader的心跳，在心跳RPC中处理</li><li>voteCh表示自己成功给某个candidate投票，在投票RPC中处理</li><li>l2fCh表示leader收到心跳回复中有比自己大的term</li><li>通过electionTimeout来控制选举超时的时间（定义为450-550ms）</li><li>heartBeatTimeOut设置为100ms</li></ul><h4 id="Schedule">Schedule</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Schedule() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">switch</span> rf.state &#123;</span><br><span class="line">        <span class="keyword">case</span> Leader:</span><br><span class="line">            rf.leaderTick()</span><br><span class="line">        <span class="keyword">case</span> Candidate:</span><br><span class="line">            rf.candidateTick()</span><br><span class="line">        <span class="keyword">case</span> Follower:</span><br><span class="line">            rf.followerTick()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据rf当前的状态执行对应的Tick即可。</li></ul><h4 id="AppendEntries-Heart-beat-RPC">AppendEntries(Heart_beat) RPC</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heart_beat from leader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntryArgs, reply *AppendEntryReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">        reply.Term = rf.currentTerm</span><br><span class="line">        reply.Success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">        rf.currentTerm = args.Term</span><br><span class="line">        rf.voteFor = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    reply.Success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(args *AppendEntryArgs)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> rf.appendCh &lt;- args:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            &lt;-rf.appendCh</span><br><span class="line">            rf.appendCh &lt;- args</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收来自于leader的heart_beat args，如果leader的任期比自己小，则赋值reply后直接返回，不向appendCh中发送数据，表示自己没有接收到心跳，自己自动通过timeOut转变为candidate</li><li>leader任期大于等于自己，则更新自己的相关成员，向appendCh中发送数据表示接受到心跳</li><li>接收心跳后根据appendCh进行状态的转换（在follower，candidate，leader中处理）</li></ul><h4 id="Request-vote-RPC">Request_vote RPC</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rf.voteFor != <span class="number">-1</span> &amp;&amp; rf.voteFor != args.CandidateId &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//票还没投过，可以投</span></span><br><span class="line">    reply.Term = rf.currentTerm</span><br><span class="line">    reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">    rf.voteFor = args.CandidateId</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(args *RequestVoteArgs)</span></span> &#123;</span><br><span class="line">    <span class="comment">//same as heartbeat...</span></span><br><span class="line">    &#125;(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果请求投票的candidate的任期比自己小，则不给他投票</li><li>如果任期比自己大，给他投票</li><li>如果之前投过票了就不能再投票</li><li>投票之后向voteCh发送数据表示自己已经投过票了，根据该信息转换自己当前的状态（在follower，candidate，leader中处理）</li></ul><h4 id="Follower">Follower</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> followerTick() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rf.resetTimeout()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> args := &lt;-rf.appendCh:</span><br><span class="line">            <span class="comment">//收到了来自于leader的心跳，继续follower</span></span><br><span class="line">        <span class="keyword">case</span> args := &lt;-rf.voteCh:</span><br><span class="line">            <span class="comment">//自己投票给了其他candidate，继续follower</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.electionTimeout.C:</span><br><span class="line">            <span class="comment">//超时没收到心跳，变为candidate</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据channel中的信息进行自身成员的更新和状态转换即可。</li></ul><h4 id="Candidate">Candidate</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> candidateTick() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.voteFor = rf.me</span><br><span class="line">    rf.currentTerm++</span><br><span class="line">    currentTerm := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    args := &amp;RequestVoteArgs&#123;</span><br><span class="line">        Term:        currentTerm,</span><br><span class="line">        CandidateId: rf.me,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    voteCnt := <span class="number">1</span></span><br><span class="line">    voteNote := <span class="literal">false</span></span><br><span class="line">    voteWin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">    voteLock := sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选举超时统计</span></span><br><span class="line">    rf.resetTimeout()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> ok := rf.sendRequestVote(i, args, reply); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">                    voteLock.Lock()</span><br><span class="line">                    voteCnt++</span><br><span class="line">                    <span class="keyword">if</span> !voteNote &amp;&amp; voteCnt &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                        voteNote = <span class="literal">true</span></span><br><span class="line">                        voteLock.Unlock()</span><br><span class="line">                        voteWin &lt;- <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        voteLock.Unlock()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换状态，简单的修改state即可</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.appendCh:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.voteCh:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-voteWin:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-rf.electionTimeout.C:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进行candidateTick，首先根据论文所述，进入candidate状态先将自身的currentTerm+1，然后向其余的节点发送请求投票的RPC，收集到超过一半的选票后变为leader</li><li>如果在此期间收到了心跳或者自己给其他candidate投票，则关闭其给其他节点发送的请求投票的RPC并将状态变为follower</li><li>如果选举超时，那么开启新一轮选举</li><li>注意需要将rf.currentTerm提前保存下来，保证发送给其他节点的Term是开始时的Term，否则直接调用rf.currentTerm可能导致发送给其他节点的Term并不相等。</li></ul><h4 id="Leader">Leader</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> leaderTick() &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    currentTerm := rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            args := &amp;AppendEntryArgs&#123;</span><br><span class="line">                Term:     currentTerm,</span><br><span class="line">                LeaderId: rf.me,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, currentT <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                reply := &amp;AppendEntryReply&#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> ok := rf.sendAppendVote(i, args, reply); ok &#123;</span><br><span class="line">                    rf.mu.Lock()</span><br><span class="line">                    <span class="keyword">if</span> rf.currentTerm != currentT &#123;</span><br><span class="line">                        rf.mu.Unlock()</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    rf.mu.Unlock()</span><br><span class="line">                    <span class="keyword">if</span> reply.Success &#123;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rf.mu.Lock()</span><br><span class="line">                        <span class="keyword">if</span> reply.Term &gt; currentT &#123;</span><br><span class="line">                            rf.currentTerm = reply.Term</span><br><span class="line">                            rf.mu.Unlock()</span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                            <span class="keyword">case</span> rf.l2fCh &lt;- <span class="literal">true</span>:</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                &lt;-rf.l2fCh</span><br><span class="line">                                rf.l2fCh &lt;- <span class="literal">true</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            rf.mu.Unlock()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i, currentTerm)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Duration(rf.heartBeatTimeOut) * time.Millisecond):</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.appendCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.voteCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.l2fCh:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意leader在执行的过程中用一个for循环包裹，heart_beat每隔一段时间就进行发送，在本文中采用的是time.After，实验手册中建议直接使用time.Sleep</li><li>leader在每次for循环中向其余的节点发送心跳RPC，并根据reply判断是否放弃leader身份</li><li>如果计时器结束，说明一切正常，继续下一轮的心跳发送</li><li>如果收到了其他节点的心跳，说明其他节点成为了leader，自己需要放弃leader身份</li><li>如果给其他节点投票，说明其他节点的Term比自己新，自己需要放弃leader身份</li><li>如果其他节点心跳的reply中Term比自己新，自己需要放弃leader身份</li></ul><h3 id="测试">测试</h3><p>编写脚本测试500次，全部通过。<br><img src="/2023/07/21/MIT6-824-2020-Lab2-Raft-Part-2A/test.png" alt="test" title="test"></p><h3 id="注意">注意</h3><ul><li>实验过程中可以利用util中的DPrintf打印相关信息，方便debug</li><li>重点在于分析清楚各个goroutines的生命周期</li><li>不要忘记实现GetState()和Kill()，不在Kill中对节点处理的话可能会导致断连的节点依旧打印信息</li><li>使用go test -race检测代码中潜在的race问题</li><li>可能造成bug的原因<ul><li>第一个test报错warning: term changed even though there were no failures原因是系统会通过checkTerms来检查当前的Term（任期号），在两次checkTerms中加入sleep，这期间你的系统是保持稳定的，即选举成功后没有发生任何crash或disconnect，leader一直持续的向其他节点发送心跳，因此两次checkTerms的Term应该不变，报错的原因就是你的两次Term发生了变化，说明系统不稳定，即使没有bug但是leader还是在更换</li><li>第二个test中断连一个leader后又把他重新加入网络，可能会导致两个leader</li><li>注意goroutines传入参数的设置，避免直接使用外部数据，通过参数传递使用你需要的数据，直接使用外部数据，数据可能会发生变化</li><li>在sendRPC返回ok的过程中可能会失败（disconnect），这类的RPC返回的非常慢（经过测试大于700ms，以秒为量级），注意这些goroutines</li></ul></li><li>建议编写自己的test script进行程序的测试，因为只跑少量的testcase无法检测出概率小的bug</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;后续实验对此部分代码进行了重构，因此代码不具备参考性，仅适用于本次实验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 2020 Lab1 MapReduce</title>
    <link href="https://penpenf28.github.io/2023/07/10/MIT6-824-2020-Lab1-MapReduce/"/>
    <id>https://penpenf28.github.io/2023/07/10/MIT6-824-2020-Lab1-MapReduce/</id>
    <published>2023-07-10T10:13:53.000Z</published>
    <updated>2023-10-10T06:36:39.997Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前请先仔细阅读<a href="%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html%5D">Lab 1</a>实验要求并熟悉基础代码，了解Go中的RPC通信。<br>Lab环境的配置过程中可能会出现若干问题，参照<a href="%5Bhttps://juejin.cn/post/7018756637330685988%5D(https://juejin.cn/post/7018756637330685988)">此处</a>解决。<br>本文只提供相关实现思路，希望可以读者由此获得灵感。</p><h3 id="实验说明">实验说明</h3><ul><li>完成分布式MapReduce系统设计，实现词频统计</li><li>Worker分别调用Map和Reduce Function来读取和处理文件</li><li>Master用来调度和处理失败的Worker</li><li>主要修改src/mr文件夹中的master.go rpc.go worker.go</li><li>Lab中是所有Map任务完成后才进行Reduce任务</li><li>Worker和Master之间利用RPC进行通信</li></ul><h3 id="设计概述">设计概述</h3><blockquote><p>大部分思路来自于<a href="https://github.com/yzongyue/6.824-golabs-2020">https://github.com/yzongyue/6.824-golabs-2020</a>，在此基础上进行修改，十分感谢！</p></blockquote><h4 id="结构说明">结构说明</h4><ul><li>调用mrmaster.go启动Master，监听是否有人向自身发送RPC请求。</li><li>调用mrworker.go启动Worker，首先询问Master是否已经分配了全部任务，如果分配完成了就不新建Worker，直接退出，如果未完成，则新建Worker分担任务。<ul><li>此处询问是否分配完成设计是由测试脚本引发的设计，crash.go中在master分配全部任务之后会继续新建Worker向master请求，如果不进行相关设计会warning，但是不影响正确结果</li></ul></li><li>Worker首先通过RPC通信向Master注册自身，再通过RPC通信向Master请求任务，执行任务，最后通过RPC向Master报告任务完成，此处共需要设计三种RPC请求回答格式。</li></ul><h4 id="架构图">架构图</h4><h5 id="master">master</h5><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/master.png" alt="master" title="master"></p><h5 id="worker">worker</h5><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/worker.png" alt="worker" title="worker"></p><h4 id="数据流图">数据流图</h4><p>以nMap = n，nReduce=3为例，其中中间文件的数量为nMap*nReduce=3n个。<br><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/dataflow.png" alt="dataflow" title="dataflow"></p><h3 id="具体实现">具体实现</h3><h4 id="Master">Master</h4><p>Master的作用就是统筹Worker，分配任务，因此需要为任务构建一个结构体，使用RPC在Master和Worker之间传输，定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskPhase <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MapPhase    TaskPhase = <span class="number">0</span></span><br><span class="line">ReducePhase TaskPhase = <span class="number">1</span></span><br><span class="line">WaitPhase   TaskPhase = <span class="number">2</span></span><br><span class="line">ExitPhase   TaskPhase = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">FileName <span class="type">string</span></span><br><span class="line">NMap     <span class="type">int</span></span><br><span class="line">NReduce  <span class="type">int</span></span><br><span class="line">ID       <span class="type">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NMap变量由文件数决定，由于在Map阶段需要生成中间文件mr-MapID-BucketID，此处的NMap用作后面Reduce阶段遍历相关中间文件。<br>Phase变量有4个取值，分别代表当前系统是在哪个任务阶段（可能TaskPhase会造成误解），其中Wait阶段是Worker向Master发出请求，但是Master现在并没有任务发送给他，Worker需要等待，Exit阶段表示当前需要退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// used in TaskStat</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TaskReady   TaskStatus = <span class="number">0</span></span><br><span class="line">TaskQueue   TaskStatus = <span class="number">1</span></span><br><span class="line">TaskRunning TaskStatus = <span class="number">2</span></span><br><span class="line">TaskDone    TaskStatus = <span class="number">3</span></span><br><span class="line">TaskError   TaskStatus = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskStat <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID  <span class="type">int</span></span><br><span class="line">Status    TaskStatus</span><br><span class="line">StartTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">files   []<span class="type">string</span></span><br><span class="line">NReduce <span class="type">int</span></span><br><span class="line"></span><br><span class="line">mu           sync.Mutex</span><br><span class="line">NowWorkers   <span class="type">int</span></span><br><span class="line">TotalWorkers <span class="type">int</span></span><br><span class="line">ExitWorkers  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">Tstate []TaskStat</span><br><span class="line">Phase  TaskPhase</span><br><span class="line"></span><br><span class="line">TaskCh <span class="keyword">chan</span> Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化过程中可以确定好files和NReduce，files是所需要处理的文件集合，NReduce是生成最后文件的数量，可以理解为桶的数量。<br>NowWorker为当前分配WorkerID的指针，每次有一个Worker发来一个注册RPC，为其分配一个WorkerID，然后NowWorker自增，TotalWorker自增。<br>TotalWorker为当前Master中存活的Worker，因为后续test脚本中有crash测试，因此当一个worker失联超过设置的时间后判定为crash，TotalWorker自减。<br>ExitWorker为当前Master中正常退出的Worker，当Worker发送退出RPC时（为了简化设计，将退出RPC和通知Master任务完成的RPC进行设计合并），ExitWorker自增。<br>如何判断当前任务全部完成，Master可以退出了( Done )？</p><ul><li>判断TotalWorkers和ExitWorkers是否相等即可。</li></ul><p>TState是Master中较为关键的成员，通过Init函数进行设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitMap() &#123;</span><br><span class="line">m.Phase = MapPhase</span><br><span class="line">m.Tstate = <span class="built_in">make</span>([]TaskStat, <span class="built_in">len</span>(m.files))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitReduce() &#123;</span><br><span class="line">m.Phase = ReducePhase</span><br><span class="line">m.Tstate = <span class="built_in">make</span>([]TaskStat, m.NReduce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TState的长度等于当前需要处理的Task的数量，TState[i]的含义就是第i个task当前的状态，包括分配给的WorkerID，状态以及开始执行的时间。TaskCh是一段有buffer的channel，用作Goroutines之间的数据传输，后续解释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitMap() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> InitReduce() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RPC通信，用于注册和退出Worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RegisterWorker(args *RegisterArgs, reply *RegisterReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> ExitWorker(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当一个worker申请一个Task时，register该Task的TaskState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> RegisterTask(args *RequestArgs, task *Task) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过TaskID新建需要完成的Task并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> GetTask(NowTaskID <span class="type">int</span>) Task &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Schedule() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> TickSchedule() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RPC通信，用于Worker获取Task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> GetOneTask(args *RequestArgs, reply *RequestReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="comment">//RPC通信，用于Master接受Worker发送过来的信息，更新对应的TState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> ReportTask_m(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="comment">//RPC通信，用于Worker创建前询问Master是否完成全部的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> IsAllDone(args *ReportArgs, reply *ReportReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Master &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"></span><br><span class="line">m.mu = sync.Mutex&#123;&#125;</span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.files = files</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nReduce &gt; <span class="built_in">len</span>(files) &#123;</span><br><span class="line">m.TaskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, nReduce)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.TaskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="built_in">len</span>(files))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.InitMap()</span><br><span class="line"><span class="keyword">go</span> m.TickSchedule()</span><br><span class="line"></span><br><span class="line">m.server()</span><br><span class="line"><span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用MakeMaster新建一个Master，并构建一个有buffer的TaskChannel，用作存放需要发送给Worker的Task。</li><li>接着初始化Map，设置一下相关的参数</li><li>TickSchedule开始周期性调度全部任务，该函数主要实现是利用for循环，在不是ExitPhase的情况下周期性调用Schedule</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Schedule() &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.Phase == ExitPhase &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.Phase == WaitPhase &#123;</span><br><span class="line"><span class="keyword">if</span> m.ExitWorkers == m.TotalWorkers &#123;</span><br><span class="line">m.Phase = ExitPhase</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AllDone := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> m.Tstate &#123;</span><br><span class="line"><span class="keyword">switch</span> task.Status &#123;</span><br><span class="line"><span class="keyword">case</span> TaskReady:</span><br><span class="line">            AllDone = <span class="literal">false</span></span><br><span class="line">m.TaskCh &lt;- m.GetTask(idx)</span><br><span class="line">m.Tstate[idx].Status = TaskQueue</span><br><span class="line"><span class="keyword">case</span> TaskQueue:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">case</span> TaskRunning:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">            <span class="comment">// deal with crash</span></span><br><span class="line"><span class="keyword">case</span> TaskDone:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">case</span> TaskError:</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> AllDone &#123;</span><br><span class="line"><span class="keyword">if</span> m.Phase == MapPhase &#123;</span><br><span class="line">m.InitReduce()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.Phase = WaitPhase</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">            <span class="comment">// fake task...</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Schedule的大体框架如上，首先Master在调度之前判断一下自身的状态，wait状态是Master已经调度完全部任务了，向所有还存活的Worker发送一个伪任务，告诉他们可以退出了，其余还存活的Worker一直在不停的接受任务，这时收到Master发送过来的fake task后，向Master发送已退出的消息然后退出，Master接收到全部退出消息后，将Phase改为ExitPhase然后退出。<br>中间的for循环遍历TaskState，将准备好的任务发送到TaskChannel，来让Worker接收。</p><h4 id="Worker">Worker</h4><p>首先定义worker结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">workerID <span class="type">int</span></span><br><span class="line">mapf     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue</span><br><span class="line">reducef  <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker的构建主要是通过Worker function</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">w := worker&#123;</span><br><span class="line">mapf:    mapf,</span><br><span class="line">reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := ReportArgs&#123;&#125;</span><br><span class="line">reply := ReportReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">call(<span class="string">&quot;Master.IsAllDone&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> reply.AllFinished &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;all done, no more client\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.Register()</span><br><span class="line">w.run()</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker %d exit normally\n&quot;</span>, w.workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断一下Master是否分配完了全部的工作，否则就进行worker的注册和执行，Register主要通过RPC通信来和Master通信获取可用的workerID，run用来执行构建好的worker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> run() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">task := w.RequestTask()</span><br><span class="line">fmt.Printf(<span class="string">&quot;worker %d get task %d, TaskPhase==%d\n&quot;</span>, w.workerID, task.ID, task.Phase)</span><br><span class="line"><span class="keyword">if</span> task.Phase == ExitPhase &#123;</span><br><span class="line">w.Exit()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> task.Phase == WaitPhase &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">w.doTask(task)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以开多个窗口同时跑多个worker，下面的延时防止worker执行太快，</span></span><br><span class="line">        <span class="comment">// 其他worker来不及执行</span></span><br><span class="line"><span class="comment">// time.Sleep(3 * time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run函数是worker中需要重点关注的函数，内部使用一个for循环来不断请求Master获得空闲的Task，此处的RequestTask也是通过RPC通信进行数据的获取。</p><ul><li>如果当前task处于ExitPhase，则调用Exit向Master进行RPC通信，告诉Master此Worker已退出。</li><li>如果当前task处于WaitPhase，说明当前Master无任务分配，让Worker睡眠一段时间后重新请求。</li></ul><p>如果当前任务可执行，则调用doTask进行任务的执行，doTask流程如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doTask(task Task) &#123;</span><br><span class="line"><span class="keyword">switch</span> task.Phase &#123;</span><br><span class="line"><span class="keyword">case</span> MapPhase:</span><br><span class="line">w.doMap(task)</span><br><span class="line"><span class="keyword">case</span> ReducePhase:</span><br><span class="line">w.doReduce(task)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;wrong phase&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RPC设计">RPC设计</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisterArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RegisterReply <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Task_ *Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Done     <span class="type">bool</span></span><br><span class="line">TaskID   <span class="type">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">WorkerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReportReply <span class="keyword">struct</span> &#123;</span><br><span class="line">AllFinished <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Register RPC，不需要worker传递参数给master，只需要master把当前可用的workerID 回复给worker即可。<br>对于Request RPC，worker需要传递给master自己的workerID，让master可以更新自己对应的TState中的任务，明确该分配给了了哪个worker，并更新状态，master回复给worker对应的task即可。<br>对于Report RPC，合并了三种操作，一种是刚调用Worker时询问Master是否分配完了全部的任务，一种是完成一个Task后向Master汇报该任务已完成，最后一种是向Master汇报该worker已退出。</p><h4 id="doMap">doMap</h4><p>Master把收到的全部文件设置为一个个的Task，状态保存在TState中，每次每个worker调用doMap就从TaskCh中取出一个Task任务执行mapf（大概就是对一个具体的file做Map操作，返回的键值对仿照mrsequential.go暂时保存到kva中），遍历kva，利用ihash函数将kv.Key对应的Value哈希到对应的桶中（可以使用intermediate[]表示桶的集合，大小为nReduce）<br>最后遍历桶，将各个桶中的数据写入中间文件，中间文件的命名可以使用mr-mapID-bucketID，写入出错或者写入成功都需要向Master call RPC进行通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doMap(task Task) &#123;</span><br><span class="line"><span class="comment">// get filename and content</span></span><br><span class="line">kva := w.mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"></span><br><span class="line">intermediate := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">bucketID := ihash(kv.Key) % task.NReduce</span><br><span class="line">intermediate[bucketID] = <span class="built_in">append</span>(intermediate[bucketID], kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bucketID, kva := <span class="keyword">range</span> intermediate &#123;</span><br><span class="line">oname := Map2ReduceFileName(task.ID, bucketID)</span><br><span class="line">ofile, err := os.Create(oname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(ofile)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ofile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doReduce">doReduce</h4><p>一个具体的Reduce Task是将上面Map生成的中间全部文件mr-i-taskID( 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">\lt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> NMap )，集合并做reducef操作，保存到最终文件mr-out-taskID中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> doReduce(task Task) &#123;</span><br><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span>; idx &lt; task.NMap; idx++ &#123;</span><br><span class="line">filename := Map2ReduceFileName(idx, task.ID)</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := maps[kv.Key]; !ok &#123;</span><br><span class="line">maps[kv.Key] = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">maps[kv.Key] = <span class="built_in">append</span>(maps[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> key, values := <span class="keyword">range</span> maps &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, fmt.Sprintf(<span class="string">&quot;%v %v\n&quot;</span>, key, w.reducef(key, values)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(MergeName(task.ID), []<span class="type">byte</span>(strings.Join(res, <span class="string">&quot;&quot;</span>)), <span class="number">0600</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.ReportTask_w(task, <span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTask_w(task, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><p><img src="/2023/07/10/MIT6-824-2020-Lab1-MapReduce/test.GIF" alt="test" title="test"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读本文前请先仔细阅读&lt;a href=&quot;%5Bhttp://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html%5D&quot;&gt;Lab 1&lt;/a&gt;实验要求并熟悉基础代码，了解Go中的RPC通信。&lt;br&gt;
Lab环境的配置过程中可能会出现若干问</summary>
      
    
    
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/categories/Distributed-System/"/>
    
    
    <category term="MIT6.824" scheme="https://penpenf28.github.io/tags/MIT6-824/"/>
    
    <category term="Distributed System" scheme="https://penpenf28.github.io/tags/Distributed-System/"/>
    
    <category term="Go" scheme="https://penpenf28.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
